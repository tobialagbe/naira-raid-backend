This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-01T23:24:31.763Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  auth/
    dto/
      check-token.dto.ts
      login.dto.ts
      login.dto.ts.meta
      refresh-token.dto.ts
      refresh-token.dto.ts.meta
      request-password-reset.dto.ts
      request-password-reset.dto.ts.meta
      reset-password.dto.ts
      reset-password.dto.ts.meta
      verify-email.dto.ts
      verify-email.dto.ts.meta
    guards/
      jwt-auth.guard.ts
      jwt-auth.guard.ts.meta
      local-auth.guard.ts
      local-auth.guard.ts.meta
    strategies/
      jwt.strategy.ts
      jwt.strategy.ts.meta
      local.strategy.ts
      local.strategy.ts.meta
    auth.controller.spec.ts
    auth.controller.spec.ts.meta
    auth.controller.ts
    auth.controller.ts.meta
    auth.module.ts
    auth.module.ts.meta
    auth.service.spec.ts
    auth.service.spec.ts.meta
    auth.service.ts
    auth.service.ts.meta
    dto.meta
    guards.meta
    strategies.meta
  battle-royale/
    dto/
      create-event.dto.ts
      register-player.dto.ts
      update-player.dto.ts
    schemas/
      battle-royale-event.schema.ts
      battle-royale-player.schema.ts
    services/
      battle-royale.service.ts
      udp-server-later.service.ts
      udp-server-old.service.ts
      udp-server.service.ts
    battle-royale.controller.ts
    battle-royale.module.ts
  common/
    dto/
      pagination.dto.ts
      pagination.dto.ts.meta
    types/
      game.types.ts
      game.types.ts.meta
    dto.meta
    types.meta
  config/
    configuration.ts
    configuration.ts.meta
  daily-missions/
    controllers/
      daily-missions.controller.ts
    dto/
      create-daily-mission.dto.ts
      create-daily-mission.dto.ts.meta
      create-mission-definition.dto.ts
      update-mission-progress.dto.ts
    schemas/
      daily-mission.schema.ts
      daily-mission.schema.ts.meta
      enemy-color.schema.ts
      mission-definition.schema.ts
      mission-points.schema.ts
      mission-progress.schema.ts
      user-mission-progress.schema.ts
      user-mission-progress.schema.ts.meta
    services/
      daily-missions.service.ts
    daily-missions.controller.spec.ts
    daily-missions.controller.spec.ts.meta
    daily-missions.controller.ts
    daily-missions.controller.ts.meta
    daily-missions.module.ts
    daily-missions.module.ts.meta
    daily-missions.service.spec.ts
    daily-missions.service.spec.ts.meta
    daily-missions.service.ts
    daily-missions.service.ts.meta
    dto.meta
    schemas.meta
  database/
    seeders/
      daily-mission.seeder.ts
      daily-mission.seeder.ts.meta
      daily-missions.seeder.ts
      inventory.seeder.ts
      inventory.seeder.ts.meta
      leaderboard.seeder.ts
      leaderboard.seeder.ts.meta
      player-progress.seeder.ts
      player-progress.seeder.ts.meta
      seed.ts
      seed.ts.meta
      seeder.ts
      seeder.ts.meta
      user-mission-progress.seeder.ts
      user-mission-progress.seeder.ts.meta
      user.seeder.ts
      user.seeder.ts.meta
    database.module.ts
    seed.ts
    seeders.meta
  email/
    interfaces/
      email-metrics.interface.ts
      email-metrics.interface.ts.meta
    templates/
      achievement-unlocked.hbs
      achievement-unlocked.hbs.meta
      reset-password.hbs
      reset-password.hbs.meta
      verify-email.hbs
      verify-email.hbs.meta
      welcome.hbs
      welcome.hbs.meta
    email.controller.ts
    email.controller.ts.meta
    email.health.ts
    email.health.ts.meta
    email.module.ts
    email.module.ts.meta
    email.processor.ts
    email.processor.ts.meta
    email.service.ts
    email.service.ts.meta
    interfaces.meta
    templates.meta
  inventory/
    dto/
      create-inventory-item.dto.ts
      create-inventory-item.dto.ts.meta
      create-user-inventory.dto.ts
      create-user-inventory.dto.ts.meta
    schemas/
      inventory-item.schema.ts
      inventory-item.schema.ts.meta
      user-inventory.schema.ts
      user-inventory.schema.ts.meta
    dto.meta
    inventory.controller.spec.ts
    inventory.controller.spec.ts.meta
    inventory.controller.ts
    inventory.controller.ts.meta
    inventory.module.ts
    inventory.module.ts.meta
    inventory.service.spec.ts
    inventory.service.spec.ts.meta
    inventory.service.ts
    inventory.service.ts.meta
    schemas.meta
  leaderboard/
    dto/
      create-game-session.dto.ts
      create-game-session.dto.ts.meta
      create-leaderboard-entry.dto.ts
      create-leaderboard-entry.dto.ts.meta
      create-leaderboard.dto.ts
      create-leaderboard.dto.ts.meta
    schemas/
      game-session.schema.ts
      game-session.schema.ts.meta
      leaderboard-entry.schema.ts
      leaderboard-entry.schema.ts.meta
      leaderboard.schema.ts
      leaderboard.schema.ts.meta
    dto.meta
    leaderboard.controller.spec.ts
    leaderboard.controller.spec.ts.meta
    leaderboard.controller.ts
    leaderboard.controller.ts.meta
    leaderboard.module.ts
    leaderboard.module.ts.meta
    leaderboard.service.spec.ts
    leaderboard.service.spec.ts.meta
    leaderboard.service.ts
    leaderboard.service.ts.meta
    schemas.meta
  player-progress/
    dto/
      create-player-progress.dto.ts
      create-player-progress.dto.ts.meta
      update-player-progress.dto.ts
      update-player-progress.dto.ts.meta
    schemas/
      player-progress.schema.ts
      player-progress.schema.ts.meta
    dto.meta
    player-progress.controller.ts
    player-progress.controller.ts.meta
    player-progress.module.ts
    player-progress.module.ts.meta
    player-progress.service.ts
    player-progress.service.ts.meta
    schemas.meta
  user/
    dto/
      create-user.dto.ts
      create-user.dto.ts.meta
      update-user.dto.ts
      update-user.dto.ts.meta
    schemas/
      user.schema.ts
      user.schema.ts.meta
    dto.meta
    schemas.meta
    user.controller.spec.ts
    user.controller.spec.ts.meta
    user.controller.ts
    user.controller.ts.meta
    user.module.ts
    user.module.ts.meta
    user.service.spec.ts
    user.service.spec.ts.meta
    user.service.ts
    user.service.ts.meta
  app.controller.spec.ts
  app.controller.spec.ts.meta
  app.controller.ts
  app.controller.ts.meta
  app.module.ts
  app.module.ts.meta
  app.service.ts
  app.service.ts.meta
  auth.meta
  common.meta
  config.meta
  daily-missions.meta
  database.meta
  email.meta
  inventory.meta
  leaderboard.meta
  main.ts
  main.ts.meta
  player-progress.meta
  user.meta
test/
  app.e2e-spec.ts
  app.e2e-spec.ts.meta
  jest-e2e.json
  jest-e2e.json.meta
.eslintrc.js
.gitignore
.prettierrc
backend-repomix-output.txt
dist.meta
nest-cli.json
nest-cli.json.meta
node_modules.meta
package-lock.json.meta
package.json
package.json.meta
README.md
README.md.meta
src.meta
test.meta
tsconfig.build.json
tsconfig.build.json.meta
tsconfig.json
tsconfig.json.meta

================================================================
Files
================================================================

================
File: src/auth/dto/check-token.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsString } from 'class-validator';

export class CheckTokenDto {
  @ApiProperty({ description: 'Current JWT access token' })
  @IsString()
  accessToken: string;

  @ApiProperty({ description: 'Refresh token associated with the user' })
  @IsString()
  refreshToken: string;
}

================
File: src/auth/dto/login.dto.ts
================
import { IsString, IsOptional } from 'class-validator';

export class LoginDto {
  @IsOptional()
  @IsString()
  email?: string;

  @IsOptional()
  @IsString()
  username?: string;

  @IsString()
  password: string;
}

================
File: src/auth/dto/login.dto.ts.meta
================
fileFormatVersion: 2
guid: f8dd0d6823a914dc9a6012109f71b648
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/refresh-token.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class RefreshTokenDto {
  @ApiProperty({
    description: 'Refresh token received during login',
    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  })
  @IsNotEmpty()
  @IsString()
  refreshToken: string;
}

================
File: src/auth/dto/refresh-token.dto.ts.meta
================
fileFormatVersion: 2
guid: 2a912ad6a0f73433d9ff1abf4e72812e
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/request-password-reset.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty } from 'class-validator';

export class RequestPasswordResetDto {
  @ApiProperty({
    description: 'Email address of the user requesting password reset',
    example: 'user@example.com',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;
}

================
File: src/auth/dto/request-password-reset.dto.ts.meta
================
fileFormatVersion: 2
guid: 575958243c9074e3abe37b5c5d033572
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/reset-password.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'Reset token received via email',
    example: 'abc123def456...',
  })
  @IsNotEmpty()
  @IsString()
  token: string;

  @ApiProperty({
    description: 'New password (minimum 8 characters)',
    example: 'newSecurePassword123',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  newPassword: string;
}

================
File: src/auth/dto/reset-password.dto.ts.meta
================
fileFormatVersion: 2
guid: 3322b2f4f9c104104b2fc37197c20b30
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/verify-email.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyEmailDto {
  @ApiProperty({
    description: 'Email verification token received via email',
    example: 'abc123def456...',
  })
  @IsNotEmpty()
  @IsString()
  token: string;
}

================
File: src/auth/dto/verify-email.dto.ts.meta
================
fileFormatVersion: 2
guid: 91d03aa6745fe448e9a95d58af2b2314
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards/jwt-auth.guard.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

// Define interfaces for the JWT error types
interface TokenExpiredError extends Error {
  name: string;
  message: string;
  expiredAt: Date;
}

interface JsonWebTokenError extends Error {
  name: string;
  message: string;
}

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  handleRequest(err, user, info) {
    // If there's an error or no user
    if (err || !user) {
      // TokenExpiredError is a specific error from jsonwebtoken package
      if (info instanceof Error && info.name === 'TokenExpiredError') {
        const tokenError = info as TokenExpiredError;
        throw new UnauthorizedException({
          statusCode: 401,
          message: 'Token expired',
          error: 'Unauthorized',
          expiredAt: tokenError.expiredAt,
        });
      }
      
      // JsonWebTokenError is the general JWT error class
      if (info instanceof Error && info.name === 'JsonWebTokenError') {
        throw new UnauthorizedException({
          statusCode: 401,
          message: 'Invalid token',
          error: 'Unauthorized',
        });
      }
      
      // For any other authentication error
      throw err || new UnauthorizedException({
        statusCode: 401,
        message: info?.message || 'Unauthorized access',
        error: 'Unauthorized',
      });
    }
    
    // If all is good, return the user
    return user;
  }
}

================
File: src/auth/guards/jwt-auth.guard.ts.meta
================
fileFormatVersion: 2
guid: 81dc6a6f6458948fb8091c0acd25e17b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards/local-auth.guard.ts
================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

================
File: src/auth/guards/local-auth.guard.ts.meta
================
fileFormatVersion: 2
guid: 162b22f8578d3485daa6a5f74fd77531
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies/jwt.strategy.ts
================
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined in environment variables');
    }

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}

================
File: src/auth/strategies/jwt.strategy.ts.meta
================
fileFormatVersion: 2
guid: 62fb4f63a197b44e89e5312217b30c8b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies/local.strategy.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      usernameField: 'email',
      passwordField: 'password',
    });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser({ email, password });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}

================
File: src/auth/strategies/local.strategy.ts.meta
================
fileFormatVersion: 2
guid: 98e48d19453e14d72b3033bf0148708f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/auth/auth.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: ca762a559fbb54c378b73f0e6a0fb828
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.controller.ts
================
import { Controller, Post, Body, UseGuards, Request, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBody } from '@nestjs/swagger';
import { AuthService } from './auth.service';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { CreateUserDto } from '../user/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { RequestPasswordResetDto } from './dto/request-password-reset.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { VerifyEmailDto } from './dto/verify-email.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';
import { CheckTokenDto } from './dto/check-token.dto';

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiBody({ type: CreateUserDto })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'User has been successfully registered.',
  })
  @ApiResponse({
    status: HttpStatus.CONFLICT,
    description: 'User with this email or username already exists.',
  })
  async register(@Body() createUserDto: CreateUserDto) {
    return this.authService.register(createUserDto);
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  @ApiOperation({ summary: 'Login with email/username and password' })
  @ApiBody({ type: LoginDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'User has been successfully logged in.',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Invalid credentials.',
  })
  async login(@Request() req, @Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('request-password-reset')
  @ApiOperation({ summary: 'Request a password reset' })
  @ApiBody({ type: RequestPasswordResetDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Password reset instructions sent to email.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'No user found with this email.',
  })
  async requestPasswordReset(@Body() requestPasswordResetDto: RequestPasswordResetDto) {
    return this.authService.requestPasswordReset(requestPasswordResetDto);
  }

  @Post('reset-password')
  @ApiOperation({ summary: 'Reset password using token' })
  @ApiBody({ type: ResetPasswordDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Password has been successfully reset.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid or expired reset token.',
  })
  async resetPassword(@Body() resetPasswordDto: ResetPasswordDto) {
    return this.authService.resetPassword(resetPasswordDto);
  }

  @Post('verify-email')
  @ApiOperation({ summary: 'Verify email using token' })
  @ApiBody({ type: VerifyEmailDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Email has been successfully verified.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid or expired verification token.',
  })
  async verifyEmail(@Body() verifyEmailDto: VerifyEmailDto) {
    return this.authService.verifyEmail(verifyEmailDto);
  }

  @Post('refresh-token')
  @ApiOperation({ summary: 'Get new access token using refresh token' })
  @ApiBody({ type: RefreshTokenDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'New access token generated successfully.',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Invalid or expired refresh token.',
  })
  async refreshToken(@Body() refreshTokenDto: RefreshTokenDto) {
    return this.authService.refreshToken(refreshTokenDto);
  }

  @Post('check-token')
  @ApiOperation({ summary: 'Check if access token is valid and refresh if expired' })
  @ApiBody({ type: CheckTokenDto })
  @ApiResponse({ status: HttpStatus.OK, description: 'Returns a valid access token (and possibly new refresh token).' })
  async checkToken(@Body() body: CheckTokenDto) {
    return this.authService.checkAndRefreshToken(body.accessToken, body.refreshToken);
  }
}

================
File: src/auth/auth.controller.ts.meta
================
fileFormatVersion: 2
guid: 43582518f5add403ab176a997d7543cd
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UserModule } from '../user/user.module';
import { EmailModule } from '../email/email.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';

@Module({
  imports: [
    UserModule,
    EmailModule.register(),
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

================
File: src/auth/auth.module.ts.meta
================
fileFormatVersion: 2
guid: ff0ba45392cfa41d597745905b234ccc
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/auth/auth.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 8f635c6d709d74d2cbdf3354820df03b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.service.ts
================
import { Injectable, UnauthorizedException, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';
import { EmailService } from '../email/email.service';
import { CreateUserDto } from '../user/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { RequestPasswordResetDto } from './dto/request-password-reset.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { VerifyEmailDto } from './dto/verify-email.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';
import * as bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AuthService {
  private readonly resetTokens: Map<string, { email: string; expires: Date }> = new Map();
  private readonly verificationTokens: Map<string, { email: string; expires: Date }> = new Map();
  private readonly refreshTokens: Map<string, { userId: string; expires: Date }> = new Map();

  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly emailService: EmailService,
  ) {}

  async validateUser({ email, password }: { email: string; password: string }) {
    const user = await this.userService.findByEmail(email);
    // console.log(user);
    if (user && await bcrypt.compare(password, user.password)) {
      const { password: _, ...result } = user.toObject();
      return result;
    }
    return null;
  }

  async register(createUserDto: CreateUserDto) {
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    const user = await this.userService.create({
      ...createUserDto,
      password: hashedPassword,
      isEmailVerified: false,
    });

    // Generate email verification token
    const verificationToken = uuidv4();
    this.verificationTokens.set(verificationToken, {
      email: user.email,
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
    });

    // Send verification email
    await this.emailService.sendVerificationEmail(user, verificationToken);

    const { password: _, ...result } = user.toObject();
    return result;
  }

  async login(loginDto: LoginDto) {
    let user;
    if (loginDto.email) {
      user = await this.validateUser({
        email: loginDto.email,
        password: loginDto.password,
      });
    } else if (loginDto.username) {
      const userByUsername = await this.userService.findByUsername(loginDto.username);
      if (userByUsername) {
        user = await this.validateUser({
          email: userByUsername.email,
          password: loginDto.password,
        });
      }
    }

    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { email: user.email, sub: user._id };
    const accessToken = this.jwtService.sign(payload);
    const refreshToken = uuidv4();

    // Store refresh token
    this.refreshTokens.set(refreshToken, {
      userId: user._id.toString(),
      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    });

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      user,
    };
  }

  async requestPasswordReset(requestPasswordResetDto: RequestPasswordResetDto) {
    const user = await this.userService.findByEmail(requestPasswordResetDto.email);
    if (!user) {
      throw new BadRequestException('No user found with this email');
    }

    const resetToken = uuidv4();
    this.resetTokens.set(resetToken, {
      email: user.email,
      expires: new Date(Date.now() + 1 * 60 * 60 * 1000), // 1 hour
    });

    // Send password reset email
    await this.emailService.sendPasswordResetEmail(user, resetToken);

    return { message: 'Password reset instructions sent to your email' };
  }

  async resetPassword(resetPasswordDto: ResetPasswordDto) {
    const tokenData = this.resetTokens.get(resetPasswordDto.token);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new BadRequestException('Invalid or expired reset token');
    }

    const user = await this.userService.findByEmail(tokenData.email);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    const hashedPassword = await bcrypt.hash(resetPasswordDto.newPassword, 10);
    await this.userService.update(user._id.toString(), { password: hashedPassword });

    // Remove used token
    this.resetTokens.delete(resetPasswordDto.token);

    return { message: 'Password successfully reset' };
  }

  async verifyEmail(verifyEmailDto: VerifyEmailDto) {
    const tokenData = this.verificationTokens.get(verifyEmailDto.token);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new BadRequestException('Invalid or expired verification token');
    }

    const user = await this.userService.findByEmail(tokenData.email);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    await this.userService.update(user._id.toString(), { isEmailVerified: true });

    // Remove used token
    this.verificationTokens.delete(verifyEmailDto.token);

    return { message: 'Email successfully verified' };
  }

  async refreshToken(refreshTokenDto: RefreshTokenDto) {
    const tokenData = this.refreshTokens.get(refreshTokenDto.refreshToken);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new UnauthorizedException('Invalid or expired refresh token');
    }

    const user = await this.userService.findById(tokenData.userId);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    const payload = { email: user.email, sub: user._id };
    const accessToken = this.jwtService.sign(payload);
    const newRefreshToken = uuidv4();

    // Store new refresh token and remove old one
    this.refreshTokens.delete(refreshTokenDto.refreshToken);
    this.refreshTokens.set(newRefreshToken, {
      userId: user._id.toString(),
      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    });

    return {
      access_token: accessToken,
      refresh_token: newRefreshToken,
    };
  }

  async checkAndRefreshToken(accessToken: string, refreshToken: string) {
    try {
      // Verify access token. If valid we simply return it.
      this.jwtService.verify(accessToken);
      return { access_token: accessToken };
    } catch (err) {
      // Access token invalid or expired. Attempt refresh.
      const tokenData = this.refreshTokens.get(refreshToken);
      if (!tokenData || tokenData.expires < new Date()) {
        throw new UnauthorizedException('Invalid or expired refresh token');
      }

      const user = await this.userService.findById(tokenData.userId);
      if (!user) {
        throw new BadRequestException('User not found');
      }

      const payload = { email: user.email, sub: user._id };
      const newAccessToken = this.jwtService.sign(payload);
      const newRefreshToken = uuidv4();

      // Replace old refresh token
      this.refreshTokens.delete(refreshToken);
      this.refreshTokens.set(newRefreshToken, {
        userId: user._id.toString(),
        expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      });

      return {
        access_token: newAccessToken,
        refresh_token: newRefreshToken,
      };
    }
  }
}

================
File: src/auth/auth.service.ts.meta
================
fileFormatVersion: 2
guid: aad8b72a81a814fbfb10554dc4346eef
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto.meta
================
fileFormatVersion: 2
guid: 3a6a1fa07a8004cb09bb44aba5484724
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards.meta
================
fileFormatVersion: 2
guid: 9f435a64ad8fe429d952f5f5b922a20d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies.meta
================
fileFormatVersion: 2
guid: 3b24cd2fbd2d949fab03ebad1fabc794
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/battle-royale/dto/create-event.dto.ts
================
import { IsArray, IsBoolean, IsDate, IsNotEmpty, IsNumber, IsOptional, IsPositive, IsString, Max, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class CreateEventDto {
  @IsNotEmpty()
  @IsString()
  title: string;

  @IsNotEmpty()
  @IsString()
  description: string;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  eventDate: Date;

  @IsNotEmpty()
  @IsString()
  startTime: string; // Format: "HH:MM" (24-hour format)

  @IsNumber()
  @Min(0)
  @IsOptional()
  entryFee: number = 0;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsPositive({ each: true })
  prizePools: number[];

  @IsBoolean()
  @IsOptional()
  isActive: boolean = false;

  @IsNumber()
  @Min(10)
  @Max(1000)
  @IsOptional()
  maxPlayers: number = 100;
}

================
File: src/battle-royale/dto/register-player.dto.ts
================
import { IsMongoId, IsNotEmpty } from 'class-validator';
import { Types } from 'mongoose';
 
export class RegisterPlayerDto {
  @IsNotEmpty()
  @IsMongoId()
  eventId: Types.ObjectId;
}

================
File: src/battle-royale/dto/update-player.dto.ts
================
import { IsBoolean, IsIn, IsMongoId, IsNotEmpty, IsNumber, IsObject, IsOptional, IsString, Min } from 'class-validator';
import { Types } from 'mongoose';

export class UpdatePlayerDto {
  @IsNotEmpty()
  @IsMongoId()
  eventId: Types.ObjectId;

  @IsOptional()
  @IsString()
  roomId?: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
  position?: number;

  @IsOptional()
  @IsBoolean()
  entryFeePaid?: boolean;

  @IsOptional()
  @IsIn(['registered', 'active', 'eliminated', 'winner'])
  status?: string;

  @IsOptional()
  @IsObject()
  lastPosition?: {
    x: number;
    y: number;
    z: number;
  };

  @IsOptional()
  @IsObject()
  flip?: {
    x: number;
    y: number;
    z: number;
  };

  @IsOptional()
  @IsNumber()
  rotation?: number;

  @IsOptional()
  @IsBoolean()
  isAlive?: boolean;
}

================
File: src/battle-royale/schemas/battle-royale-event.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BattleRoyaleEventDocument = BattleRoyaleEvent & Document;

@Schema({ timestamps: true })
export class BattleRoyaleEvent {
  _id: Types.ObjectId;

  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true })
  eventDate: Date;

  @Prop({ required: true })
  startTime: string; // Format: "HH:MM" in 24-hour format

  @Prop({ default: 0 })
  entryFee: number;

  @Prop({ required: true })
  prizePools: number[];

  @Prop({ default: false })
  isActive: boolean;

  @Prop({ default: 'upcoming' })
  status: string; // 'upcoming', 'active', 'completed'

  @Prop({ default: 100 })
  maxPlayers: number;

  @Prop({ default: [] })
  rooms: string[]; // List of active room IDs for this event
}

export const BattleRoyaleEventSchema = SchemaFactory.createForClass(BattleRoyaleEvent);

================
File: src/battle-royale/schemas/battle-royale-player.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BattleRoyalePlayerDocument = BattleRoyalePlayer & Document;

@Schema({ timestamps: true })
export class BattleRoyalePlayer {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true })
  username: string;

  @Prop({ type: Types.ObjectId, ref: 'BattleRoyaleEvent', required: true })
  eventId: Types.ObjectId;

  @Prop({ default: null })
  roomId: string;

  @Prop({ default: 0 })
  position: number; // 0 means still alive, 1 is winner, 2 is second place, etc.

  @Prop({ default: false })
  entryFeePaid: boolean;

  @Prop({ default: 'registered' })
  status: string; // 'registered', 'active', 'eliminated', 'winner'

  @Prop({ type: Object, default: { x: 0, y: 0, z: 0 } })
  lastPosition: {
    x: number;
    y: number;
    z: number;
  };

  @Prop({ type: Object, default: { x: 1, y: 1, z: 1 } })
  flip: {
    x: number;
    y: number;
    z: number;
  };

  @Prop({ default: 0 })
  rotation: number;

  @Prop({ default: true })
  isAlive: boolean;
}

export const BattleRoyalePlayerSchema = SchemaFactory.createForClass(BattleRoyalePlayer);

================
File: src/battle-royale/services/battle-royale.service.ts
================
/* eslint-disable max-len */
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { BattleRoyaleEvent, BattleRoyaleEventDocument } from '../schemas/battle-royale-event.schema';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';
import { CreateEventDto } from '../dto/create-event.dto';
import { RegisterPlayerDto } from '../dto/register-player.dto';
import { UpdatePlayerDto } from '../dto/update-player.dto';
import { UserService } from '../../user/user.service';

@Injectable()
export class BattleRoyaleService {
  constructor(
    @InjectModel(BattleRoyaleEvent.name)
    private readonly eventModel: Model<BattleRoyaleEventDocument>,
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
    private readonly userService: UserService,
  ) {}

  /**
   * Create a new Battle Royale event
   */
  async createEvent(createEventDto: CreateEventDto): Promise<BattleRoyaleEventDocument> {
    const event = new this.eventModel(createEventDto);
    return event.save();
  }

  /**
   * Get all events with optional filtering
   */
  async getEvents(status?: string) {
    const query: any = {};
    if (status) {
      query.status = status;
    }

    // Fetch events and convert to plain JS objects
    const events = await this.eventModel
      .find(query)
      .sort({ eventDate: 1, startTime: 1 })
      .lean()
      .exec();

    // Attach number of registered participants to each event
    const eventsWithParticipants = await Promise.all(
      events.map(async (event) => {
        const registeredParticipants = await this.playerModel.countDocuments({
          eventId: event._id,
        });
        return { ...event, registeredParticipants };
      }),
    );

    return eventsWithParticipants;
  }

  /**
   * Get the latest upcoming event
   */
  async getLatestUpcomingEvent() {
    const now = new Date();

    const upcomingEvent = await this.eventModel
      .findOne({
        eventDate: { $gte: now },
        status: 'upcoming',
      })
      .sort({ eventDate: 1, startTime: 1 })
      .lean()
      .exec();

    if (!upcomingEvent) {
      throw new NotFoundException('No upcoming events found');
    }

    const registeredParticipants = await this.playerModel.countDocuments({
      eventId: upcomingEvent._id,
    });

    return { ...upcomingEvent, registeredParticipants };
  }

  /**
   * Get a specific event by ID
   */
  async getEventById(eventId: string): Promise<BattleRoyaleEventDocument> {
    const event = await this.eventModel.findById(eventId).exec();
    
    if (!event) {
      throw new NotFoundException(`Event with ID ${eventId} not found`);
    }
    
    return event;
  }

  /**
   * Register a player for an event
   */
  async registerPlayer(userId: string, registerPlayerDto: RegisterPlayerDto): Promise<BattleRoyalePlayerDocument> {
    const event = await this.getEventById(registerPlayerDto.eventId.toString());
    
    // Check if event is still open for registration
    if (event.status !== 'upcoming') {
      throw new BadRequestException('Registration for this event is closed');
    }
    
    // Convert IDs to strings for consistent comparison
    const userIdString = userId.toString();
    const eventIdString = registerPlayerDto.eventId.toString();
    
    // Check if user is already registered
    const existingRegistration = await this.playerModel.findOne({
      userId: new Types.ObjectId(userIdString),
      eventId: new Types.ObjectId(eventIdString)
    });
    
    if (existingRegistration) {
      throw new BadRequestException('You are already registered for this event');
    }
    
    // Get user details
    const user = await this.userService.findById(userId);
    
    // Create player registration
    const playerData = {
      userId: new Types.ObjectId(userIdString),
      username: user.username,
      eventId: new Types.ObjectId(eventIdString),
      // If there's no entry fee, automatically set as paid
      entryFeePaid: event.entryFee === 0
    };
    
    const player = new this.playerModel(playerData);
    return player.save();
  }

  /**
   * Update player information
   */
  async updatePlayer(userId: string, updatePlayerDto: UpdatePlayerDto): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(updatePlayerDto.eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    if (!player) {
      throw new NotFoundException('Player registration not found');
    }
    
    // Update player fields
    Object.keys(updatePlayerDto).forEach(key => {
      if (key !== 'eventId' && updatePlayerDto[key] !== undefined) {
        player[key] = updatePlayerDto[key];
      }
    });
    
    return player.save();
  }

  /**
   * Get player status for an event
   */
  async getPlayerStatus(userId: string, eventId: string): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    // For debugging - log the query params
    console.log('Looking for player with userId:', userIdObj, 'eventId:', eventIdObj);
    
    if (!player) {
      // Check if there are any registrations for this user to help diagnose
      const allUserRegistrations = await this.playerModel.find({ userId: userIdObj });
      console.log('Found registrations for user:', allUserRegistrations.length);
      
      throw new NotFoundException('Player registration not found');
    }
    
    return player;
  }

  /**
   * Mark player's entry fee as paid
   */
  async markEntryFeePaid(userId: string, eventId: string): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    if (!player) {
      throw new NotFoundException('Player registration not found');
    }
    
    player.entryFeePaid = true;
    return player.save();
  }

  /**
   * Get all players registered for an event
   */
  async getEventPlayers(eventId: string) {
    return this.playerModel.find({ eventId }).exec();
  }

  /**
   * Get leaderboard for an event (players ordered by position)
   */
  async getEventLeaderboard(eventId: string) {
    const players = await this.playerModel.find({
      eventId,
      status: { $in: ['eliminated', 'winner'] },
      position: { $gt: 0 }
    })
    .sort({ position: 1 })
    .exec();
    
    // Players are sorted by position (1 is winner, 2 is second place, etc.)
    return players;
  }

  /**
   * Get the closest upcoming event a user is registered for
   */
  async getClosestUpcomingEventForUser(userId: string) {
    const now = new Date();
    const userIdObj = new Types.ObjectId(userId.toString());

    // Fetch all event IDs the user is registered for
    const registrations = await this.playerModel
      .find({ userId: userIdObj })
      .select('eventId')
      .lean();

    const eventIds = registrations.map((r) => r.eventId);

    if (eventIds.length === 0) {
      throw new NotFoundException('User is not registered for any events');
    }

    // Find the closest upcoming event among the registered ones
    const upcomingEvent = await this.eventModel
      .findOne({
        _id: { $in: eventIds },
        status: 'upcoming',
        eventDate: { $gte: now },
      })
      .sort({ eventDate: 1, startTime: 1 })
      .lean()
      .exec();

    if (!upcomingEvent) {
      throw new NotFoundException('No upcoming registered events found');
    }

    // Attach participant count
    const registeredParticipants = await this.playerModel.countDocuments({
      eventId: upcomingEvent._id,
    });

    return { ...upcomingEvent, registeredParticipants };
  }
}

================
File: src/battle-royale/services/udp-server-later.service.ts
================
/* eslint-disable prefer-const */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import * as dgram from 'dgram';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

@Injectable()
export class UdpServerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(UdpServerService.name);
  private server: dgram.Socket;
  private players: Record<string, any> = {};
  private readonly UDP_PORT = 41234;
  
  // Track last activity time for each player to handle timeouts
  private playerLastActivity: Record<string, number> = {};
  
  // How long a player can be inactive before being considered disconnected (ms)
  private readonly PLAYER_TIMEOUT = 15000; // 15 seconds
  
  // Interval for checking player timeouts (ms)
  private readonly CLEANUP_INTERVAL = 10000; // 10 seconds
  
  // Timer for cleanup
  private cleanupTimer: NodeJS.Timeout;

  constructor(
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
  ) {}

  onModuleInit() {
    this.startServer();
    
    // Start a timer to clean up disconnected players
    this.cleanupTimer = setInterval(() => this.cleanupDisconnectedPlayers(), this.CLEANUP_INTERVAL);
  }

  onModuleDestroy() {
    if (this.server) {
      this.server.close();
    }
    
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
  }

  private startServer() {
    // Create a UDP socket (IPv4)
    this.server = dgram.createSocket('udp4');

    // Configure socket for better performance with mobile clients
    // NOTE: Configure socket options AFTER binding the socket, not before
    this.server.on('listening', () => {
      try {
        // These operations should only be performed after socket is bound
        this.server.setBroadcast(false);
        this.server.setRecvBufferSize(65536); // Larger buffer for mobile clients with inconsistent networking
        this.server.setSendBufferSize(65536);
        
        const address = this.server.address();
        this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
      } catch (err) {
        this.logger.error(`Error configuring socket: ${err.message}`);
      }
    });

    // When we receive a message (datagram):
    this.server.on('message', (msg, rinfo) => {
      try {
        const data = JSON.parse(msg.toString());
        const playerId = data.playerId;

        // Always update the player's network info
        if (playerId && this.players[playerId]) {
          this.players[playerId].address = rinfo.address;
          this.players[playerId].port = rinfo.port;
        }
        
        // Update last activity time for this player
        if (playerId) {
          this.playerLastActivity[playerId] = Date.now();
        }
        
        // Handle ping messages for keeping mobile connections alive
        if (data.type === 'ping') {
          this.handlePing(data, rinfo);
          return;
        }
        
        switch (data.type) {
          case 'connect':
            this.handleConnect(data, rinfo);
            break;
          case 'move':
            this.handleMove(data, rinfo);
            break;
          case 'flip':
            this.handleFlip(data, rinfo);
            break;
          case 'rotate':
            this.handleRotate(data, rinfo);
            break;
          case 'attack':
            this.handleAttack(data, rinfo);
            break;
          case 'damage':
            this.handleDamage(data, rinfo);
            break;
          case 'death':
            this.handleDeath(data, rinfo);
            break;
          default:
            this.logger.warn('Unknown message type:', data.type);
            break;
        }
      } catch (err) {
        this.logger.error('Failed to parse incoming message:', err);
      }
    });

    // Basic error handling
    this.server.on('error', (err) => {
      this.logger.error(`Server error: ${err.stack}`);
      this.server.close();
    });

    // 'listening' event
    // this.server.on('listening', () => {
    //   const address = this.server.address();
    //   this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
    // });

    // Start listening on UDP port
    this.server.bind(this.UDP_PORT);
  }

  /**
   * Handle ping messages (keep-alive)
   */
  private handlePing(data: any, rinfo: dgram.RemoteInfo) {
    // Simply send a pong response back to the client
    this.sendMessage({
      type: 'pong',
      timestamp: data.timestamp || Date.now()
    }, rinfo.address, rinfo.port);
  }

  /**
   * Periodically check for and remove disconnected players
   */
  private cleanupDisconnectedPlayers() {
    const now = Date.now();
    let disconnectedPlayers = [];
    
    for (const [playerId, lastActivity] of Object.entries(this.playerLastActivity)) {
      if (now - lastActivity > this.PLAYER_TIMEOUT) {
        disconnectedPlayers.push(playerId);
      }
    }
    
    // Remove disconnected players
    for (const playerId of disconnectedPlayers) {
      if (this.players[playerId]) {
        const roomId = this.players[playerId].roomId;
        
        this.logger.log(`Player ${playerId} timed out and will be disconnected`);
        
        // Broadcast to other players that this player has disconnected
        this.broadcastExcept({
          type: 'death',
          playerId: playerId,
        }, playerId, roomId);
        
        // Clean up player data
        delete this.players[playerId];
        delete this.playerLastActivity[playerId];
      }
    }
  }

  /**
   * Handle a new player connecting.
   */
  private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const roomId = data.roomId || null;
    const eventId = data.eventId || null;

    // If we already know this player, skip re-adding them
    if (!this.players[playerId]) {
      this.players[playerId] = {
        address: rinfo.address,
        port: rinfo.port,
        roomId,
        eventId,
        position: { x: 0, y: 0, z: 0 },
        flip: { x: 1, y: 1, z: 1 },
        rotation: 0,
        isAlive: true,
        health: 5 // Max health
      };
      this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

      // Update the player's roomId and status in the database if eventId is provided
      if (eventId && roomId) {
        this.updatePlayerInDatabase(playerId, eventId, roomId);
      }
    }

    // const testPlayer = {
    //   playerId: '123456',
    //   position: { x: 1, y: 1, z: 1 },
    //   flip: { x: 1, y: 1, z: 1 },
    //   rotation: 0,
    //   isAlive: true,
    //   health: 5,
    //   bot:true,
    //   roomId: 'test',
    // };

    // A) Send a "connect_ack" back to this newly connected client
    // including a list of existing players so they can spawn them locally.
    const existingPlayersList = Object.entries(this.players)
      .filter(([pid, info]) => info.roomId === roomId) // Only players in the same room
      .map(([pid, info]: [string, any]) => ({
        playerId: pid,
        position: info.position,
        flip: info.flip,
        rotation: info.rotation,
        isAlive: info.isAlive,
        health: info.health,
        bot: false,
        roomId: info.roomId
      }));

    this.sendMessage({
      type: 'connect_ack',
      message: 'Welcome to the server!',
      existingPlayers: existingPlayersList, // Send both test player and real players
    }, rinfo.address, rinfo.port);

    // console.log('broadcast spawn!!! ');

    // B) Broadcast a "spawn" event to all OTHER players that a new player has joined
    this.broadcastExcept({
      type: 'spawn',
      playerId: playerId,
      position: { x: 0, y: 0, z: 0 },
      flip: { x: 1, y: 1, z: 1 },
      rotation: 0,
      isAlive: true,
      health: 5,
      bot: false,
      roomId: roomId,
    }, playerId, roomId);
  }

  /**
   * Handle a player's movement update.
   */
  private handleMove(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return; // ignore if not found or dead

    player.position = data.position;

    // console.log('moved!!! ');

    // Broadcast this movement to all other players in the same room
    this.broadcastExcept({
      type: 'move',
      playerId: playerId,
      position: data.position,
    }, playerId, player.roomId);
  }

  /**
   * Handle flipping (scaling) data.
   */
  private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.flip = data.localScale;

    // console.log('flipped!!! ');

    this.broadcastExcept({
      type: 'flip',
      playerId: playerId,
      flip: data.localScale,
    }, playerId, player.roomId);
  }

  /**
   * Handle rotation data.
   */
  private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.rotation = data.rotation;

    // console.log('rotated!!! ');

    this.broadcastExcept({
      type: 'rotate',
      playerId: playerId,
      rotation: data.rotation,
    }, playerId, player.roomId);
  }

  /**
   * Handle an attack event.
   */
  private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
    console.log('person dey shoot');
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    // console.log('attacking!!! ');

    // Broadcast to everyone except the attacker in the same room
    this.broadcastExcept({
      type: 'attack',
      playerId: playerId,
      shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
      shootDirection: data.shootDirection || { x: 0, y: 0 }
    }, playerId, player.roomId);
  }

  /**
   * Handle damage event
   */
  private handleDamage(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.health = Math.max(0, player.health - data.damage);

    if (player.health <= 0) {
      player.isAlive = false;
      
      // Update database if this is a Battle Royale event
      if (player.eventId) {
        this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
      }
    }

    // console.log('damage!!! ');

    // Broadcast damage to all players in the room
    this.broadcastExcept({
      type: 'damage',
      playerId: playerId,
      damage: data.damage,
      shooterId: data.shooterId,
      currentHealth: player.health
    }, playerId, player.roomId);
  }

  /**
   * Handle a death event.
   */
  private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    player.isAlive = false;

    // Update player position in database
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
    }

    // Broadcast to everyone except the dead player in the same room
    this.broadcastExcept({
      type: 'death',
      playerId: playerId
    }, playerId, player.roomId);
  }

  /**
   * Broadcast a message to all players in a specific room except the specified playerId.
   */
  private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null) {
    let broadcastCount = 0;
    for (const [pid, info] of Object.entries(this.players)) {
      // Skip if it's the excluded player or not in the same room
      if (pid === exceptPlayerId) continue;
      if (roomId && info.roomId !== roomId) continue;

      this.logger.debug(`Broadcasting to ${pid} at ${info.address}:${info.port}`);
      console.log(`Broadcasting to ${pid} at ${info.address}:${info.port}`);
      this.sendMessage(msgObj, info.address, info.port);
      broadcastCount++;
    }
    this.logger.log(`Broadcast message to ${broadcastCount} players in room ${roomId}`);
    console.log(`Broadcast message to ${broadcastCount} players in room ${roomId}`);
  }

  /**
   * Helper function to send a JSON message via UDP with improved error handling.
   */
  private sendMessage(dataObj: any, address: string, port: number) {
    const message = Buffer.from(JSON.stringify(dataObj));
    
    try {
      this.server.send(message, 0, message.length, port, address, (err) => {
        if (err) {
          this.logger.error('Failed to send message:', err);
        }
      });
    } catch (error) {
      this.logger.error('Error sending UDP message:', error);
    }
  }

  /**
   * Update player information in the database
   */
  private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
    try {
      // Find the player by user ID and event ID and update the room ID
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        { 
          roomId, 
          status: 'active',
          isAlive: true,
          position: 0
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} in database:`, error);
    }
  }

  /**
   * Update player death information in the database
   */
  private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
    try {
      // Find the player by user ID and event ID and update status and position
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        { 
          status: position === 1 ? 'winner' : 'eliminated',
          isAlive: false,
          position: position,
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} death in database:`, error);
    }
  }
}

================
File: src/battle-royale/services/udp-server-old.service.ts
================
/* eslint-disable max-len */
// /* eslint-disable @typescript-eslint/no-unused-vars */
// import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
// import * as dgram from 'dgram';
// import { InjectModel } from '@nestjs/mongoose';
// import { Model } from 'mongoose';
// import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

// @Injectable()
// export class UdpServerService implements OnModuleInit, OnModuleDestroy {
//   private readonly logger = new Logger(UdpServerService.name);
//   private server: dgram.Socket;
//   private players: Record<string, any> = {};
//   private readonly UDP_PORT = 41234;

//   constructor(
//     @InjectModel(BattleRoyalePlayer.name)
//     private readonly playerModel: Model<BattleRoyalePlayerDocument>,
//   ) {}

//   onModuleInit() {
//     this.startServer();
//   }

//   onModuleDestroy() {
//     if (this.server) {
//       this.server.close();
//     }
//   }

//   private startServer() {
//     // Create a UDP socket (IPv4)
//     this.server = dgram.createSocket('udp4');

//     // When we receive a message (datagram):
//     this.server.on('message', (msg, rinfo) => {
//       try {
//         const data = JSON.parse(msg.toString());
        
//         switch (data.type) {
//           case 'connect':
//             this.handleConnect(data, rinfo);
//             break;
//           case 'move':
//             this.handleMove(data, rinfo);
//             break;
//           case 'flip':
//             this.handleFlip(data, rinfo);
//             break;
//           case 'rotate':
//             this.handleRotate(data, rinfo);
//             break;
//           case 'attack':
//             this.handleAttack(data, rinfo);
//             break;
//           case 'damage':
//             this.handleDamage(data, rinfo);
//             break;
//           case 'death':
//             this.handleDeath(data, rinfo);
//             break;
//           default:
//             this.logger.warn('Unknown message type:', data.type);
//             break;
//         }
//       } catch (err) {
//         this.logger.error('Failed to parse incoming message:', err);
//       }
//     });

//     // Basic error handling
//     this.server.on('error', (err) => {
//       this.logger.error(`Server error: ${err.stack}`);
//       this.server.close();
//     });

//     // 'listening' event
//     this.server.on('listening', () => {
//       const address = this.server.address();
//       this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
//     });

//     // Start listening on UDP port
//     this.server.bind(this.UDP_PORT);
//   }

//   /**
//    * Handle a new player connecting.
//    */
//   private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const roomId = data.roomId || null;
//     const eventId = data.eventId || null;

//     // If we already know this player, skip re-adding them
//     if (!this.players[playerId]) {
//       this.players[playerId] = {
//         address: rinfo.address,
//         port: rinfo.port,
//         roomId,
//         eventId,
//         position: { x: 0, y: 0, z: 0 },
//         flip: { x: 1, y: 1, z: 1 },
//         rotation: 0,
//         isAlive: true,
//         health: 5 // Max health
//       };
//       this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

//       // Update the player's roomId and status in the database if eventId is provided
//       if (eventId && roomId) {
//         this.updatePlayerInDatabase(playerId, eventId, roomId);
//       }
//     }

//     const testPlayer = {
//       playerId: '123456',
//       position: { x: 1, y: 1, z: 1 },
//       flip: { x: 1, y: 1, z: 1 },
//       rotation: 0,
//       isAlive: true,
//       health: 5,
//       bot:true,
//       roomId: 'test',
//     };

//     // A) Send a "connect_ack" back to this newly connected client
//     // including a list of existing players so they can spawn them locally.
//     const existingPlayersList = Object.entries(this.players)
//       .filter(([pid, info]) => info.roomId === roomId) // Only players in the same room
//       .map(([pid, info]: [string, any]) => ({
//         playerId: pid,
//         position: info.position,
//         flip: info.flip,
//         rotation: info.rotation,
//         isAlive: info.isAlive,
//         health: info.health,
//         bot: false
//       }));

//     this.sendMessage({
//       type: 'connect_ack',
//       message: 'Welcome to the server!',
//       // existingPlayers: existingPlayersList,
//       existingPlayers: [testPlayer, ...existingPlayersList],
//     }, rinfo.address, rinfo.port);

//     console.log('broadcast spawn!!! ');

//     // B) Broadcast a "spawn" event to all OTHER players that a new player has joined
//     this.broadcastExcept({
//       type: 'spawn',
//       playerId: playerId,
//       position: { x: 0, y: 0, z: 0 },
//       flip: { x: 1, y: 1, z: 1 },
//       rotation: 0,
//       isAlive: true,
//       health: 5,
//       bot: false
//     }, playerId, roomId);
//   }

//   /**
//    * Handle a player's movement update.
//    */
//   private handleMove(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return; // ignore if not found or dead

//     player.position = data.position;

//     // Broadcast this movement to all other players in the same room
//     this.broadcastExcept({
//       type: 'move',
//       playerId: playerId,
//       position: data.position
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle flipping (scaling) data.
//    */
//   private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     player.flip = data.localScale;

//     this.broadcastExcept({
//       type: 'flip',
//       playerId: playerId,
//       flip: data.localScale,
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle rotation data.
//    */
//   private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     player.rotation = data.rotation;

//     this.broadcastExcept({
//       type: 'rotate',
//       playerId: playerId,
//       rotation: data.rotation,
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle an attack event.
//    */
//   private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
//     console.log('person dey shoot');
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     console.log('attacking!!! ');

//     // Broadcast to everyone except the attacker in the same room
//     this.broadcastExcept({
//       type: 'attack',
//       playerId: playerId,
//       shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
//       shootDirection: data.shootDirection || { x: 0, y: 0 }
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle damage event
//    */
//   private handleDamage(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     player.health = Math.max(0, player.health - data.damage);

//     if (player.health <= 0) {
//       player.isAlive = false;
      
//       // Update database if this is a Battle Royale event
//       if (player.eventId) {
//         this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
//       }
//     }

//     console.log('damage!!! ');

//     // Broadcast damage to all players in the room
//     this.broadcastExcept({
//       type: 'damage',
//       playerId: playerId,
//       damage: data.damage,
//       shooterId: data.shooterId,
//       currentHealth: player.health
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle a death event.
//    */
//   private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player) return;

//     player.isAlive = false;

//     // Update player position in database
//     if (player.eventId) {
//       this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
//     }

//     // Broadcast to everyone except the dead player in the same room
//     this.broadcastExcept({
//       type: 'death',
//       playerId: playerId
//     }, playerId, player.roomId);
//   }

//   /**
//    * Broadcast a message to all players in a specific room except the specified playerId.
//    */
//   private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null) {
//     for (const [pid, info] of Object.entries(this.players)) {
//       // Skip if it's the excluded player or not in the same room
//       if (pid === exceptPlayerId) continue;
//       if (roomId && info.roomId !== roomId) continue;

//       this.sendMessage(msgObj, info.address, info.port);
//     }
//   }

//   /**
//    * Helper function to send a JSON message via UDP.
//    */
//   private sendMessage(dataObj: any, address: string, port: number) {
//     const message = Buffer.from(JSON.stringify(dataObj));
//     this.server.send(message, port, address, (err) => {
//       if (err) {
//         this.logger.error('Failed to send message:', err);
//       }
//     });
//   }

//   /**
//    * Update player information in the database
//    */
//   private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
//     try {
//       // Find the player by user ID and event ID and update the room ID
//       await this.playerModel.findOneAndUpdate(
//         { userId: playerId, eventId },
//         { 
//           roomId, 
//           status: 'active',
//           isAlive: true,
//           position: 0
//         }
//       );
//     } catch (error) {
//       this.logger.error(`Failed to update player ${playerId} in database:`, error);
//     }
//   }

//   /**
//    * Update player death information in the database
//    */
//   private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
//     try {
//       // Find the player by user ID and event ID and update status and position
//       await this.playerModel.findOneAndUpdate(
//         { userId: playerId, eventId },
//         { 
//           status: position === 1 ? 'winner' : 'eliminated',
//           isAlive: false,
//           position: position,
//         }
//       );
//     } catch (error) {
//       this.logger.error(`Failed to update player ${playerId} death in database:`, error);
//     }
//   }
// }

================
File: src/battle-royale/services/udp-server.service.ts
================
/* eslint-disable prefer-const */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import * as dgram from 'dgram';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

/**
 * UdpServerService
 * ----------------
 * A UDP-based game server handling basic multiplayer events:
 * - Players can connect, move, flip (scale), rotate, attack, take damage, and die.
 * - The server also handles periodic cleanup of inactive players.
 * - Demonstrates how to parse incoming UDP messages, broadcast updates, and maintain minimal state in memory.
 */
@Injectable()
export class UdpServerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(UdpServerService.name);
  private server: dgram.Socket;

  /**
   * players
   * -------
   * A map of playerId => player data. Stored in memory for quick lookups.
   * Example:
   *   this.players[playerId] = {
   *     playerId,      // from data
   *     username,        // from data
   *     address,       // from rinfo
   *     port,          // from rinfo
   *     roomId,
   *     eventId,
   *     position,      // current position
   *     flip,          // scaling
   *     rotation,      // angle
   *     isAlive,
   *     health,
   *   };
   */
  private players: Record<string, any> = {};

  /**
   * playerLastActivity
   * ------------------
   * A map of playerId => last activity timestamp (ms).
   * Used to detect timeouts / disconnections from inactivity.
   */
  private playerLastActivity: Record<string, number> = {};

  /**
   * cashObjects
   * -----------
   * Track spawned cash objects by ID to avoid duplicates.
   * Structure: { [cashId]: { position: {x,y,z}, roomId?: string, eventId?: string } }
   */
  private cashObjects: Record<string, { position: any; roomId?: string; eventId?: string }> = {};

  /**
   * Configuration constants
   */
  private readonly UDP_PORT = 41234;
  private readonly PLAYER_TIMEOUT = 20000;      // 20 seconds inactivity => disconnect
  private readonly CLEANUP_INTERVAL = 25000;    // 25 seconds interval to check for inactivity
  private readonly PING_INTERVAL = 5000;       // Clients should ping every 5 seconds

  /**
   * Timer for the cleanup interval
   */
  private cleanupTimer: NodeJS.Timeout;

  constructor(
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
  ) {}

  /**
   * onModuleInit
   * ------------
   * Called once the NestJS module is initialized.
   * - Starts the UDP server.
   * - Starts a repeated cleanup timer for disconnected players.
   */
  onModuleInit() {
    this.startServer();
    this.cleanupTimer = setInterval(() => this.cleanupDisconnectedPlayers(), this.CLEANUP_INTERVAL);
  }

  /**
   * onModuleDestroy
   * ---------------
   * Called during application shutdown.
   * - Closes the UDP socket and clears the cleanup timer.
   */
  onModuleDestroy() {
    if (this.server) {
      this.server.close();
    }
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
  }

  /**
   * startServer
   * -----------
   * Creates the UDP socket, sets up event handlers, and binds to the configured port.
   */
  private startServer() {
    // Create a UDP socket (IPv4)
    this.server = dgram.createSocket('udp4');

    // Handle "error" events
    this.server.on('error', (err) => {
      this.logger.error(`Server error: ${err.stack}`);
      this.server.close();
    });

    // Handle incoming messages
    this.server.on('message', (msg, rinfo) => {
      try {
        const data = JSON.parse(msg.toString());
        const playerId = data.playerId;

        // Always update player's network info if we already know them
        if (playerId && this.players[playerId]) {
          this.players[playerId].address = rinfo.address;
          this.players[playerId].port = rinfo.port;
        }

        // Update last activity time
        if (playerId) {
          this.playerLastActivity[playerId] = Date.now();
        }

        // Handle ping messages quickly
        if (data.type === 'ping') {
          this.handlePing(data, rinfo);
          return;
        }

        // Main switch for game events
        switch (data.type) {
          case 'connect':
            this.handleConnect(data, rinfo);
            break;
          case 'move':
            this.handleMove(data, rinfo);
            break;
          case 'flip':
            this.handleFlip(data, rinfo);
            break;
          case 'rotate':
            this.handleRotate(data, rinfo);
            break;
          case 'attack':
            this.handleAttack(data, rinfo);
            break;
          case 'damage':
            this.handleDamage(data, rinfo);
            break;
          case 'death':
            this.handleDeath(data, rinfo);
            break;
          case 'disconnect':
            this.handleDisconnect(data, rinfo);
            break;
          case 'cash_spawn':
            this.handleCashSpawn(data);
            break;
          case 'cash_collected':
            this.handleCashCollected(data);
            break;
          default:
            // Use template string for clarity in logs
            this.logger.warn(`Unknown message type: ${data.type}`);
            break;
        }
      } catch (err) {
        this.logger.error('Failed to parse incoming message:', err);
      }
    });

    // Handle "listening" event ONCE (combined into a single event listener)
    this.server.on('listening', () => {
      try {
        // Configure socket options - note that some OSes may ignore these
        this.server.setBroadcast(false);
        this.server.setRecvBufferSize(65536);
        this.server.setSendBufferSize(65536);

        const address = this.server.address();
        this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
      } catch (err) {
        this.logger.error(`Error configuring socket: ${err.message}`);
      }
    });

    // Finally bind the socket to the port
    this.server.bind(this.UDP_PORT);
  }

  /**
   * handlePing
   * ----------
   * Responds to "ping" messages with a "pong" to keep connections alive.
   * Also updates the player's last activity time.
   */
  private handlePing(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    
    // Update last activity time if this is a known player
    if (playerId && this.players[playerId]) {
      this.playerLastActivity[playerId] = Date.now();
    }

    console.log('ping received', data);

    // Send pong response with original timestamp for latency calculation
    // this.sendMessage({
    //   type: 'pong',
    //   timestamp: data.timestamp || Date.now(),
    //   pingInterval: this.PING_INTERVAL, // Tell client how often to ping
    //   nextPingTime: Date.now() + this.PING_INTERVAL // Help client schedule next ping
    // }, rinfo.address, rinfo.port);
  }

  /**
   * cleanupDisconnectedPlayers
   * --------------------------
   * Periodically checks which players have been inactive too long
   * and broadcasts a "disconnect" event for them.
   */
  private cleanupDisconnectedPlayers() {
    const now = Date.now();
    const disconnectedPlayers: string[] = [];

    // Find all players whose last activity exceeded PLAYER_TIMEOUT
    for (const [playerId, lastActivity] of Object.entries(this.playerLastActivity)) {
      if (now - lastActivity > this.PLAYER_TIMEOUT) {
        disconnectedPlayers.push(playerId);
      }
    }

    // Remove each disconnected player from server state
    for (const playerId of disconnectedPlayers) {
      if (this.players[playerId]) {
        const roomId = this.players[playerId].roomId;
        const playerInfo = this.players[playerId]; // Store reference before deletion

        this.logger.log(`Player ${playerId} timed out and will be disconnected.`);

        // Send disconnect message to the timed out player
        this.sendMessage({
          type: 'disconnect',
          playerId: playerId,
          reason: 'inactivity_timeout'
        }, playerInfo.address, playerInfo.port);

        // Broadcast to other players that this player has disconnected
        this.broadcastExcept({
          type: 'disconnect',
          playerId: playerId,
          reason: 'inactivity_timeout'
        }, playerId, roomId);

        // Optionally, if your game logic treats a timeout as an actual elimination
        // you can set isAlive = false or update the DB here, e.g.:
        playerInfo.isAlive = false;
        if (playerInfo.eventId) {
          this.updatePlayerDeathInDatabase(playerId, playerInfo.eventId, /*position=*/0);
        }

        // Clean up memory
        delete this.players[playerId];
        delete this.playerLastActivity[playerId];
      }
    }
  }

  /**
   * handleConnect
   * -------------
   * Handles a new player's "connect" message:
   * - Adds them to the in-memory state if not already there.
   * - Sends back "connect_ack" with current players in the room.
   * - Broadcasts "spawn" to all other players in the same room.
   */
  private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const roomId = data.roomId || null;
    const eventId = data.eventId || null;
    const username = data.username || null;
    // If new to this server, store their info
    if (!this.players[playerId]) {
      this.players[playerId] = {
        address: rinfo.address,
        port: rinfo.port,
        roomId,
        eventId,
        username,
        position: { x: 0, y: 0, z: 0 },
        flip: { x: 1, y: 1, z: 1 },
        rotation: 0,
        isAlive: true,
        health: 20,
      };
      this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

      // Update the player's roomId/status in DB if eventId is provided
      if (eventId && roomId) {
        this.updatePlayerInDatabase(playerId, eventId, roomId);
      }
    }

    // Initialize or update last activity time
    this.playerLastActivity[playerId] = Date.now();

    // Build a list of existing players in the same room AND event
    const existingPlayersList = Object.entries(this.players)
      .filter(([pid, info]) => info.roomId === roomId && info.eventId === eventId)
      .map(([pid, info]) => ({
        playerId: pid,
        username: info.username,
        position: info.position,
        flip: info.flip,
        rotation: info.rotation,
        isAlive: info.isAlive,
        health: info.health,
        bot: false,
        roomId: info.roomId,
        eventId: info.eventId,
      }));

    // Build a list of existing cash objects in the same room AND event
    const existingCashList = Object.entries(this.cashObjects)
      .filter(([cid, cinfo]) => cinfo.roomId === roomId && cinfo.eventId === eventId)
      .map(([cid, cinfo]) => ({
        cashId: cid,
        position: cinfo.position,
      }));

    // A) Acknowledge the new player with current state and ping configuration
    this.sendMessage({
      type: 'connect_ack',
      message: 'Welcome to the server!',
      existingPlayers: existingPlayersList,
      existingCash: existingCashList,
      pingInterval: this.PING_INTERVAL,
      nextPingTime: Date.now() + this.PING_INTERVAL
    }, rinfo.address, rinfo.port);

    // B) Broadcast "spawn" event to all other players in the room AND event
    this.broadcastExcept({
      type: 'spawn',
      playerId: playerId,
      username: username,
      position: { x: 0, y: 0, z: 0 },
      flip: { x: 1, y: 1, z: 1 },
      rotation: 0,
      isAlive: true,
      health: 20,
      bot: false,
      roomId: roomId,
      eventId: eventId,
    }, playerId, roomId, eventId);
  }

  /**
   * handleMove
   * ----------
   * Broadcasts a "move" event to other players in the same room.
   */
  private handleMove(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.position = data.position;

    // Broadcast movement to others in the room AND event
    this.broadcastExcept({
      type: 'move',
      playerId: playerId,
      username: player.username,
      bot: player.bot,
      health: player.health,
      position: data.position,
    }, playerId, player.roomId, player.eventId);
  }

  /**
   * handleFlip
   * ----------
   * Broadcasts a "flip" event (scaling) to other players.
   */
  private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.flip = data.localScale;

    this.broadcastExcept({
      type: 'flip',
      playerId: playerId,
      username: player.username,
      bot: player.bot,
      health: player.health,
      flip: data.localScale,
    }, playerId, player.roomId, player.eventId);
  }

  /**
   * handleRotate
   * ------------
   * Broadcasts a "rotate" event to other players.
   */
  private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.rotation = data.rotation;

    this.broadcastExcept({
      type: 'rotate',
      playerId: playerId,
      username: player.username,
      bot: player.bot,
      health: player.health,
      rotation: data.rotation,
    }, playerId, player.roomId, player.eventId);
  }

  /**
   * handleAttack
   * ------------
   * Broadcasts an "attack" event to other players.
   * NOTE: The attacker is excluded (because they already know they attacked).
   * If the attacker also needs confirmation, you'd need to handle that separately.
   */
  private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    this.broadcastExcept({
      type: 'attack',
      playerId: playerId,
      username: player.username,
      bot: player.bot,
      health: player.health,
      shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
      shootDirection: data.shootDirection || { x: 0, y: 0 },
    }, playerId, player.roomId, player.eventId);
  }

  /**
   * handleDamage
   * ------------
   * Reduces a player's health, checks if they are dead, then broadcasts "damage".
   * If the player dies, optionally updates DB (position, status).
   */
  private handleDamage(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    // Reduce health
    player.health = Math.max(0, player.health - data.damage);

    // Check if death occurred
    // if (player.health <= 0) {
    //   player.isAlive = false;

    //   // Update DB if it's a Battle Royale event
    //   if (player.eventId) {
    //     this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
    //   }
    // }

    // Broadcast damage to other players
    this.broadcastExcept({
      type: 'damage',
      playerId: playerId,
      username: player.username,
      bot: player.bot,
      health: player.health,
      damage: data.damage,
      shooterId: data.shooterId,
      currentHealth: player.health,
    }, playerId, player.roomId, player.eventId);
  }

  /**
   * handleDeath
   * -----------
   * Handles an explicit "death" event from the client (e.g., they've definitely died).
   */
  private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    player.isAlive = false;

    // Calculate player's rank/position (players left + 1)
    const playersLeft = Object.values(this.players).filter(
      (p: any) => p.isAlive && p.roomId === player.roomId && p.eventId === player.eventId
    ).length;
    
    const playerRank = playersLeft + 1;
    this.logger.log(`Player ${playerId} died with rank ${playerRank}, cash collected: ${player.cashCollected || 0}`);

    // Update database for an official death
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, playerRank);
    }

    // Send death stats directly to the player who died
    this.sendMessage(
      {
        type: 'death_stats',
        playerId: playerId,
        rank: playerRank,
        cashCollected: player.cashCollected || 0, 
      },
      player.address, 
      player.port
    );

    // Broadcast "death" to others in the room AND event
    this.broadcastExcept({
      type: 'death',
      playerId: playerId,
    }, playerId, player.roomId, player.eventId);
  }

  /**
   * handleDisconnect
   * ---------------
   * Handles an explicit disconnect message from a client.
   * This allows for clean disconnections without waiting for timeout.
   */
  private handleDisconnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    const roomId = player.roomId;
    const eventId = player.eventId;
    
    // Log the clean disconnect
    this.logger.log(`Player ${playerId} disconnected cleanly`);

    // Broadcast disconnect to other players in the room AND event
    this.broadcastExcept({
      type: 'disconnect',
      playerId: playerId,
    }, playerId, roomId, eventId);

    // If this was a Battle Royale event player, update their status
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, 0);
    }

    // Clean up the player data
    delete this.players[playerId];
    delete this.playerLastActivity[playerId];
  }

  /**
   * broadcastExcept
   * ---------------
   * Sends a message to all players in the same room AND event EXCEPT the given playerId.
   */
  private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null, eventId: string | null = null) {
    let broadcastCount = 0;
    for (const [pid, info] of Object.entries(this.players)) {
      if (pid === exceptPlayerId) continue;
      if (roomId && info.roomId !== roomId) continue;
      if (eventId && info.eventId !== eventId) continue;

      // Debug-level logging for each broadcast
      this.logger.debug(`Broadcasting to ${pid} at ${info.address}:${info.port}`);
      this.sendMessage(msgObj, info.address, info.port);
      broadcastCount++;
    }
    this.logger.log(`Broadcasted '${msgObj.type}' to ${broadcastCount} players in room ${roomId} of event ${eventId}`);
  }

  /**
   * sendMessage
   * -----------
   * Safely sends a JSON-serialized object via UDP.
   */
  private sendMessage(dataObj: any, address: string, port: number) {
    const message = Buffer.from(JSON.stringify(dataObj));
    try {
      this.server.send(message, 0, message.length, port, address, (err) => {
        if (err) {
          this.logger.error('Failed to send message:', err);
        }
      });
    } catch (error) {
      this.logger.error('Error sending UDP message:', error);
    }
  }

  /**
   * updatePlayerInDatabase
   * -----------------------
   * Example function to mark a player as 'active' in a given event & room.
   */
  private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
    try {
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        {
          roomId,
          status: 'active',
          isAlive: true,
          position: 0,
        },
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} in database:`, error);
    }
  }

  /**
   * updatePlayerDeathInDatabase
   * ---------------------------
   * Example function to mark a player as 'eliminated' or 'winner' in the database.
   */
  private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
    try {
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        {
          status: position === 1 ? 'winner' : 'eliminated',
          isAlive: false,
          position: position,
        },
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} death in database:`, error);
    }
  }

  /**
   * handleCashSpawn
   * ---------------
   * Broadcasts a "cash_spawn" event to all players so they instantiate the cash object.
   * Ensures each cashId is only processed once.
   */
  private handleCashSpawn(data: any) {
    const cashId = data.cashId;
    const position = data.position;
    const playerId = data.playerId;
    // Client must provide eventId for cash objects
    const eventId = data.eventId;
    
    if (!cashId) {
      this.logger.warn('Received cash_spawn without cashId');
      return;
    }

    // Determine room and event based on spawning player
    const roomId = playerId && this.players[playerId] ? this.players[playerId].roomId : null;
    const playerEventId = playerId && this.players[playerId] ? this.players[playerId].eventId : null;
    
    // Use provided eventId or player's eventId
    const finalEventId = eventId || playerEventId;

    // Store if not already
    if (!this.cashObjects[cashId]) {
      this.cashObjects[cashId] = { position, roomId, eventId: finalEventId };
    }

    // Broadcast to players in the same room AND event
    this.broadcastExcept(
      {
        type: 'cash_spawn',
        cashId: cashId,
        position: position,
        playerId: playerId,
        eventId: finalEventId,
      },
      playerId,
      roomId,
      finalEventId,
    );
  }

  /**
   * handleCashCollected
   * -------------------
   * Broadcasts a "cash_collected" event and removes it from internal map.
   */
  private handleCashCollected(data: any) {
    const cashId = data.cashId;
    const playerId = data.playerId;
    // Client can provide eventId for better routing
    const eventId = data.eventId;
    // Optional cash amount value (default to 300)
    const cashAmount = 300;
    
    if (!cashId) {
      this.logger.warn('Received cash_collected without cashId');
      return;
    }

    // Track cash collected by player
    if (playerId && this.players[playerId]) {
      // Initialize cash counter if not present
      if (typeof this.players[playerId].cashCollected !== 'number') {
        this.players[playerId].cashCollected = 0;
      }
      
      // Add cash to player's total
      this.players[playerId].cashCollected += cashAmount;
      this.logger.log(`Player ${playerId} collected cash: +${cashAmount}, total: ${this.players[playerId].cashCollected}`);
    }

    // Get room and event from either cash object or player info
    const storedCash = this.cashObjects[cashId] || { roomId: null, eventId: null };
    const roomId = storedCash.roomId || (playerId && this.players[playerId] ? this.players[playerId].roomId : null);
    const playerEventId = playerId && this.players[playerId] ? this.players[playerId].eventId : null;
    
    // Use stored cash eventId, provided eventId, or player's eventId
    const finalEventId = storedCash.eventId || eventId || playerEventId;

    // Remove from cache map
    delete this.cashObjects[cashId];

    // Broadcast to players in the same room AND event
    this.broadcastExcept(
      {
        type: 'cash_collected',
        cashId: cashId,
        playerId: playerId,
        eventId: finalEventId,
        cashAmount: cashAmount,
      },
      playerId,
      roomId,
      finalEventId,
    );
  }
}

================
File: src/battle-royale/battle-royale.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  Patch,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { BattleRoyaleService } from './services/battle-royale.service';
import { CreateEventDto } from './dto/create-event.dto';
import { RegisterPlayerDto } from './dto/register-player.dto';
import { UpdatePlayerDto } from './dto/update-player.dto';
import { ApiTags, ApiOperation, ApiParam, ApiQuery } from '@nestjs/swagger';

@ApiTags('battle-royale')
@Controller('battle-royale')
export class BattleRoyaleController {
  constructor(private readonly battleRoyaleService: BattleRoyaleService) {}

  @UseGuards(JwtAuthGuard)
  @Post('events')
  @ApiOperation({ summary: 'Create a new Battle Royale event' })
  createEvent(@Body() createEventDto: CreateEventDto) {
    return this.battleRoyaleService.createEvent(createEventDto);
  }

  @Get('events')
  @ApiOperation({ summary: 'Get all Battle Royale events' })
  @ApiQuery({ name: 'status', required: false, description: 'Filter by event status' })
  getEvents(@Query('status') status?: string) {
    return this.battleRoyaleService.getEvents(status);
  }

  @Get('events/upcoming')
  @ApiOperation({ summary: 'Get the latest upcoming Battle Royale event' })
  getLatestUpcomingEvent() {
    return this.battleRoyaleService.getLatestUpcomingEvent();
  }

  @Get('events/:id')
  @ApiOperation({ summary: 'Get a specific Battle Royale event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventById(@Param('id') id: string) {
    return this.battleRoyaleService.getEventById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Post('register')
  @ApiOperation({ summary: 'Register for a Battle Royale event' })
  registerPlayer(@Request() req, @Body() registerPlayerDto: RegisterPlayerDto) {
    return this.battleRoyaleService.registerPlayer(req.user.userId, registerPlayerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('players')
  @ApiOperation({ summary: 'Update player information' })
  updatePlayer(@Request() req, @Body() updatePlayerDto: UpdatePlayerDto) {
    return this.battleRoyaleService.updatePlayer(req.user.userId, updatePlayerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('players/status/:eventId')
  @ApiOperation({ summary: 'Get player status for an event' })
  @ApiParam({ name: 'eventId', description: 'Event ID' })
  getPlayerStatus(@Request() req, @Param('eventId') eventId: string) {
    return this.battleRoyaleService.getPlayerStatus(req.user.userId, eventId);
  }

  @UseGuards(JwtAuthGuard)
  @Post('players/pay-entry-fee/:eventId')
  @ApiOperation({ summary: 'Mark entry fee as paid' })
  @ApiParam({ name: 'eventId', description: 'Event ID' })
  markEntryFeePaid(@Request() req, @Param('eventId') eventId: string) {
    return this.battleRoyaleService.markEntryFeePaid(req.user.userId, eventId);
  }

  @Get('events/:id/players')
  @ApiOperation({ summary: 'Get all players registered for an event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventPlayers(@Param('id') id: string) {
    return this.battleRoyaleService.getEventPlayers(id);
  }

  @Get('events/:id/leaderboard')
  @ApiOperation({ summary: 'Get leaderboard for an event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventLeaderboard(@Param('id') id: string) {
    return this.battleRoyaleService.getEventLeaderboard(id);
  }

  @UseGuards(JwtAuthGuard)
  @Get('events/upcoming/registered')
  @ApiOperation({ summary: 'Get the closest upcoming Battle Royale event the authenticated user is registered for' })
  getClosestRegisteredUpcomingEvent(@Request() req) {
    return this.battleRoyaleService.getClosestUpcomingEventForUser(req.user.userId);
  }
}

================
File: src/battle-royale/battle-royale.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { BattleRoyaleController } from './battle-royale.controller';
import { BattleRoyaleService } from './services/battle-royale.service';
import { UdpServerService } from './services/udp-server.service';
import { BattleRoyaleEvent, BattleRoyaleEventSchema } from './schemas/battle-royale-event.schema';
import { BattleRoyalePlayer, BattleRoyalePlayerSchema } from './schemas/battle-royale-player.schema';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    ConfigModule,
    UserModule,
    MongooseModule.forFeature([
      { name: BattleRoyaleEvent.name, schema: BattleRoyaleEventSchema },
      { name: BattleRoyalePlayer.name, schema: BattleRoyalePlayerSchema },
    ]),
  ],
  controllers: [BattleRoyaleController],
  providers: [BattleRoyaleService, UdpServerService],
  exports: [BattleRoyaleService],
})
export class BattleRoyaleModule {}

================
File: src/common/dto/pagination.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 10;
}

================
File: src/common/dto/pagination.dto.ts.meta
================
fileFormatVersion: 2
guid: 0f585f3fec3db452eb852187c2de10a0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/types/game.types.ts
================
export enum GameType {
  NAIRA_RAID = 'naira-raid',
  // Add other games here as needed
}

export interface GameStats {
  totalKills?: number;
  cashCollected?: number;
  // Add other game-specific stats as needed
}

================
File: src/common/types/game.types.ts.meta
================
fileFormatVersion: 2
guid: 7044129c945044bc1ae79cc6a609f850
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/dto.meta
================
fileFormatVersion: 2
guid: 853f3c6dd8c3d47e9b92cc0463762d89
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/types.meta
================
fileFormatVersion: 2
guid: aaf2d9b6ba30c4479b3d74cf75894188
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/config/configuration.ts
================


================
File: src/config/configuration.ts.meta
================
fileFormatVersion: 2
guid: c34c915382c4e4ccc8ead4ff1838f2a3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/controllers/daily-missions.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  UseGuards,
  Request,
  Query,
  Patch,
  Delete,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { DailyMissionsService } from '../services/daily-missions.service';
import { ApiTags, ApiOperation, ApiQuery, ApiParam } from '@nestjs/swagger';
import { UpdateMissionProgressDto } from '../dto/update-mission-progress.dto';
import { CreateMissionDefinitionDto } from '../dto/create-mission-definition.dto';
import { GameType } from '../../common/types/game.types';

@ApiTags('daily-missions')
@Controller('daily-missions')
export class DailyMissionsController {
  constructor(private readonly dailyMissionsService: DailyMissionsService) {}

  @UseGuards(JwtAuthGuard)
  @Post('definitions')
  @ApiOperation({ summary: 'Create a new mission definition' })
  createMissionDefinition(@Body() createDto: CreateMissionDefinitionDto) {
    return this.dailyMissionsService.createMissionDefinition(createDto);
  }

  @Get('definitions')
  @ApiOperation({ summary: 'Get all mission definitions' })
  @ApiQuery({ name: 'activeOnly', required: false, type: Boolean })
  getMissionDefinitions(@Query('activeOnly') activeOnly?: boolean) {
    return this.dailyMissionsService.getMissionDefinitions(activeOnly);
  }

  @Get('definitions/:id')
  @ApiOperation({ summary: 'Get a specific mission definition' })
  @ApiParam({ name: 'id', description: 'Mission definition ID' })
  getMissionDefinitionById(@Param('id') id: string) {
    return this.dailyMissionsService.getMissionDefinitionById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('definitions/:id')
  @ApiOperation({ summary: 'Update a mission definition' })
  @ApiParam({ name: 'id', description: 'Mission definition ID' })
  updateMissionDefinition(
    @Param('id') id: string,
    @Body() updateDto: Partial<CreateMissionDefinitionDto>,
  ) {
    return this.dailyMissionsService.updateMissionDefinition(id, updateDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('definitions/:id')
  @ApiOperation({ summary: 'Deactivate a mission definition' })
  @ApiParam({ name: 'id', description: 'Mission definition ID' })
  deactivateMissionDefinition(@Param('id') id: string) {
    return this.dailyMissionsService.deactivateMissionDefinition(id);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  @ApiOperation({ summary: 'Get daily missions for the current player' })
  getDailyMissions(@Request() req) {
    return this.dailyMissionsService.getDailyMissions(req.user.userId);
  }

  @UseGuards(JwtAuthGuard)
  @Post('progress')
  @ApiOperation({ summary: 'Update mission progress based on game events' })
  updateMissionProgress(
    @Request() req,
    @Body() updateProgressDto: UpdateMissionProgressDto,
  ) {
    return this.dailyMissionsService.updateMissionProgress(
      req.user.userId,
      updateProgressDto.gameId,
      updateProgressDto.matchId,
      updateProgressDto.stats,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Post('claim/:missionProgressId')
  @ApiOperation({ summary: 'Claim rewards for a completed mission' })
  claimMissionReward(
    @Request() req,
    @Param('missionProgressId') missionProgressId: string,
  ) {
    return this.dailyMissionsService.claimMissionReward(
      req.user.userId,
      missionProgressId,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Get('points')
  @ApiOperation({ summary: 'Get total mission points for the current player' })
  getMissionPoints(@Request() req) {
    return this.dailyMissionsService.getMissionPoints(req.user.userId, GameType.NAIRA_RAID);
  }
}

================
File: src/daily-missions/dto/create-daily-mission.dto.ts
================
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { GameType } from '../../common/types/game.types';
import { MissionType } from '../schemas/daily-mission.schema';

export class CreateDailyMissionDto {
  @IsString()
  name: string;

  @IsString()
  description: string;

  @IsEnum(GameType)
  gameId: string;

  @IsEnum(MissionType)
  type: MissionType;

  @IsNumber()
  @Min(1)
  target: number;

  @IsOptional()
  @IsNumber()
  @Min(1)
  matchesRequired?: number;

  @IsNumber()
  @Min(0)
  rewardPoints: number;
}

================
File: src/daily-missions/dto/create-daily-mission.dto.ts.meta
================
fileFormatVersion: 2
guid: a0e63346d703c470fbc4b0b15cc3a24d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/dto/create-mission-definition.dto.ts
================
import { IsEnum, IsNumber, IsObject, IsOptional, IsString, Min } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { MissionType, MissionRequirementType } from '../schemas/mission-definition.schema';

export class ColorRequirementDto {
  @ApiProperty({ description: 'Color identifier from the client' })
  @IsString()
  colorId: string;

  @ApiProperty({ description: 'Color name from the client' })
  @IsString()
  colorName: string;
}

export class SpecialPrizeDto {
  @ApiProperty()
  @IsString()
  description: string;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  limitedToFirst: number;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  remaining: number;
}

export class CreateMissionDefinitionDto {
  @ApiProperty()
  @IsString()
  title: string;

  @ApiProperty()
  @IsString()
  description: string;

  @ApiProperty({ enum: MissionType })
  @IsEnum(MissionType)
  type: MissionType;

  @ApiProperty({ enum: MissionRequirementType })
  @IsEnum(MissionRequirementType)
  requirementType: MissionRequirementType;

  @ApiProperty()
  @IsNumber()
  @Min(1)
  requirementValue: number;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  points: number;

  @ApiProperty({ type: ColorRequirementDto, required: false })
  @IsObject()
  @IsOptional()
  colorRequirement?: ColorRequirementDto;

  @ApiProperty({ type: SpecialPrizeDto, required: false })
  @IsObject()
  @IsOptional()
  specialPrize?: SpecialPrizeDto;
}

================
File: src/daily-missions/dto/update-mission-progress.dto.ts
================
import { IsString, IsNumber, IsObject, ValidateNested, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';

export class ColorKillsDto {
  [key: string]: number;
}

export class GameStatsDto {
  @ApiProperty()
  @IsNumber()
  @Min(0)
  kills: number;

  @ApiProperty({ type: ColorKillsDto })
  @IsObject()
  colorKills: ColorKillsDto;
}

export class UpdateMissionProgressDto {
  @ApiProperty()
  @IsString()
  gameId: string;

  @ApiProperty()
  @IsString()
  matchId: string;

  @ApiProperty({ type: GameStatsDto })
  @ValidateNested()
  @Type(() => GameStatsDto)
  stats: GameStatsDto;
}

================
File: src/daily-missions/schemas/daily-mission.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export enum MissionType {
  TOTAL_KILLS = 'total_kills',
  SINGLE_MATCH_KILLS = 'single_match_kills',
  KILLS_IN_MATCHES = 'kills_in_matches'
}

export type DailyMissionDocument = DailyMission & Document;

@Schema({ timestamps: true })
export class DailyMission {
  _id: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true, enum: MissionType })
  type: MissionType;

  @Prop({ required: true })
  target: number;

  @Prop({ required: function(this: DailyMission) {
    return this.type === MissionType.KILLS_IN_MATCHES;
  } })
  matchesRequired?: number;

  @Prop({ required: true })
  rewardPoints: number;

  @Prop({ default: true })
  isActive: boolean;
}

export const DailyMissionSchema = SchemaFactory.createForClass(DailyMission);

================
File: src/daily-missions/schemas/daily-mission.schema.ts.meta
================
fileFormatVersion: 2
guid: e000e147e649a431d8c018afc8ba071a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas/enemy-color.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type EnemyColorDocument = EnemyColor & Document;

@Schema({ timestamps: true, collection: 'enemycolors' })
export class EnemyColor {
  @Prop({ required: true, unique: true })
  name: string;

  @Prop({ required: true })
  hexCode: string;

  @Prop({ required: true, default: true })
  isActive: boolean;

  @Prop({ type: Object, required: true })
  properties: {
    pointMultiplier: number;
    rarity: string; // common, rare, epic, legendary
    description: string;
  };
}

export const EnemyColorSchema = SchemaFactory.createForClass(EnemyColor);

================
File: src/daily-missions/schemas/mission-definition.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';

export type MissionDefinitionDocument = MissionDefinition & Document;

export enum MissionType {
  DAILY_CUMULATIVE = 'daily_cumulative',
  SINGLE_MATCH = 'single_match',
  COLOR_SPECIFIC_DAILY = 'color_specific_daily',
  COLOR_SPECIFIC_MATCH = 'color_specific_match'
}

export enum MissionRequirementType {
  KILLS = 'kills',
  COLOR_KILLS = 'color_kills',
  SCORE = 'score',
  CASH_COLLECTED = 'cash_collected'
}

@Schema({ timestamps: true, collection: 'missiondefinitions' })
export class MissionDefinition {
  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: MissionType })
  type: string;

  @Prop({ required: true, enum: MissionRequirementType })
  requirementType: string;

  @Prop({ required: true })
  requirementValue: number;

  @Prop({ type: Object, required: false })
  colorRequirement?: {
    colorId: string;
    colorName: string;
  };

  @Prop({ required: true })
  points: number;

  @Prop({ type: Object, required: false })
  specialPrize?: {
    description: string;
    limitedToFirst: number; // Number of players who can claim this prize, 0 means unlimited
    remaining: number; // How many prizes are left
  };

  @Prop({ default: true })
  isActive: boolean;
}

export const MissionDefinitionSchema = SchemaFactory.createForClass(MissionDefinition);

================
File: src/daily-missions/schemas/mission-points.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';

export type MissionPointsDocument = MissionPoints & Document;

@Schema({ timestamps: true })
export class MissionPoints {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ required: true })
  gameId: string;

  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true, default: 0 })
  totalPoints: number; // Accumulates points from all completed missions in the season

  @Prop({ type: [{ type: Object }], default: [] })
  pointHistory: {
    missionId: MongooseSchema.Types.ObjectId;
    points: number;
    date: Date;
  }[];
}

export const MissionPointsSchema = SchemaFactory.createForClass(MissionPoints);

// Create a compound index for efficient lookups
MissionPointsSchema.index({ userId: 1, gameId: 1, seasonNumber: 1 }, { unique: true });

================
File: src/daily-missions/schemas/mission-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { MissionDefinition } from './mission-definition.schema';

export type MissionProgressDocument = MissionProgress & Document;

export enum MissionStatus {
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  CLAIMED = 'claimed'
}

@Schema({ timestamps: true })
export class MissionProgress {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'MissionDefinition', required: true })
  missionId: MissionDefinition;

  @Prop({ required: true })
  date: Date; // The date this mission was assigned

  @Prop({ required: true, default: 0 })
  currentProgress: number;

  @Prop({ type: Object, required: false })
  matchProgress?: {
    matchId: string;
    progress: number;
  }[];

  @Prop({ type: Object, required: false })
  colorProgress?: {
    [colorId: string]: number;
  };

  @Prop({ required: true, enum: MissionStatus, default: MissionStatus.IN_PROGRESS })
  status: string;

  @Prop({ type: Boolean, default: false })
  specialPrizeClaimed: boolean;

  @Prop({ type: Date })
  completedAt?: Date;

  @Prop({ type: Date })
  claimedAt?: Date;
}

export const MissionProgressSchema = SchemaFactory.createForClass(MissionProgress);

================
File: src/daily-missions/schemas/user-mission-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';
import { DailyMission } from './daily-mission.schema';

export type UserMissionProgressDocument = UserMissionProgress & Document;

@Schema({ timestamps: true })
export class UserMissionProgress {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: DailyMission.name, required: true })
  missionId: Types.ObjectId | DailyMission;

  @Prop({ required: true })
  progress: number;

  @Prop({ type: [Number], default: [] })
  matchProgresses: number[]; // For tracking progress in individual matches

  @Prop({ required: true })
  date: Date;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ default: false })
  isCompleted: boolean;

  @Prop({ default: false })
  rewardClaimed: boolean;
}

export const UserMissionProgressSchema = SchemaFactory.createForClass(UserMissionProgress);

// Create compound index for unique mission progress per user per day
UserMissionProgressSchema.index(
  { userId: 1, missionId: 1, date: 1 },
  { unique: true }
);

================
File: src/daily-missions/schemas/user-mission-progress.schema.ts.meta
================
fileFormatVersion: 2
guid: 5fbeeeae2eb9d437eaa357c86f73f04b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/services/daily-missions.service.ts
================
/* eslint-disable max-len */
import { Injectable, NotFoundException, BadRequestException, Inject, forwardRef } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types, Schema as MongooseSchema } from 'mongoose';
import { MissionDefinition, MissionDefinitionDocument, MissionType, MissionRequirementType } from '../schemas/mission-definition.schema';
import { MissionProgress, MissionProgressDocument, MissionStatus } from '../schemas/mission-progress.schema';
import { MissionPoints, MissionPointsDocument } from '../schemas/mission-points.schema';
import { LeaderboardService } from '../../leaderboard/leaderboard.service';
import { GameType } from '../../common/types/game.types';
import { LeaderboardEntry, LeaderboardEntryDocument } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { CreateMissionDefinitionDto } from '../dto/create-mission-definition.dto';

@Injectable()
export class DailyMissionsService {
  constructor(
    @InjectModel(MissionDefinition.name)
    private readonly missionDefinitionModel: Model<MissionDefinitionDocument>,
    @InjectModel(MissionProgress.name)
    private readonly missionProgressModel: Model<MissionProgressDocument>,
    @InjectModel(MissionPoints.name)
    private readonly missionPointsModel: Model<MissionPointsDocument>,
    @Inject(forwardRef(() => LeaderboardService))
    private readonly leaderboardService: LeaderboardService,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
  ) {}

  /**
   * Get daily missions for a player
   * -----------------------------
   * Fetches or creates new daily missions for the player
   */
  async getDailyMissions(userId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get player's missions for today
    let missions = await this.missionProgressModel
      .find({
        userId,
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
      })
      .populate('missionId');

    // If no missions for today, generate new ones
    if (missions.length === 0) {
      missions = await this.generateDailyMissions(userId);
    }

    return missions;
  }

  /**
   * Generate daily missions for a player
   * ----------------------------------
   * Creates a new set of daily missions for the player.
   * Uses the current date to deterministically select missions,
   * ensuring all players get the same missions on any given day.
   */
  private async generateDailyMissions(userId: string) {
    // Get active mission definitions
    const missionDefs = await this.missionDefinitionModel
      .find({ isActive: true })
      .exec();

    if (missionDefs.length < 3) {
      throw new BadRequestException('Not enough active missions available');
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Create a deterministic seed based on the date
    const dateString = today.toISOString().split('T')[0]; // Format: YYYY-MM-DD
    const dateSeed = Array.from(dateString).reduce((acc, char) => acc + char.charCodeAt(0), 0);

    // Sort missions deterministically based on the date
    const sortedMissions = [...missionDefs].sort((a, b) => {
      // Create a unique number for each mission based on its ID and the date
      const aValue = (a._id.toString() + dateSeed).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      const bValue = (b._id.toString() + dateSeed).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return aValue - bValue;
    });

    // Take the first 3 missions after sorting
    const selectedMissions = sortedMissions.slice(0, 3);

    // Create mission progress entries
    const missionProgress = await Promise.all(
      selectedMissions.map(mission => {
        return new this.missionProgressModel({
          userId: new Types.ObjectId(userId),
          missionId: mission._id,
          date: today,
          currentProgress: 0,
          status: MissionStatus.IN_PROGRESS,
        }).save();
      }),
    );

    return missionProgress;
  }

  /**
   * Update mission progress
   * ---------------------
   * Updates progress for missions based on game events
   */
  async updateMissionProgress(
    userId: string,
    gameId: string,
    matchId: string,
    stats: {
      kills: number;
      colorKills: { [colorId: string]: number };
    },
  ) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get today's missions
    const missions = await this.missionProgressModel
      .find({
        userId,
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
        status: { $ne: MissionStatus.CLAIMED },
      })
      .populate('missionId');

    // Process each mission
    for (const mission of missions) {
      const def = mission.missionId as MissionDefinitionDocument;

      switch (def.type) {
        case MissionType.DAILY_CUMULATIVE:
          if (def.requirementType === MissionRequirementType.KILLS) {
            mission.currentProgress += stats.kills;
          }
          break;

        case MissionType.SINGLE_MATCH:
          if (def.requirementType === MissionRequirementType.KILLS) {
            if (!mission.matchProgress) {
              mission.matchProgress = [];
            }
            mission.matchProgress.push({
              matchId,
              progress: stats.kills,
            });
            mission.currentProgress = Math.max(
              ...mission.matchProgress.map(m => m.progress),
            );
          }
          break;

        case MissionType.COLOR_SPECIFIC_DAILY:
          if (def.requirementType === MissionRequirementType.COLOR_KILLS && def.colorRequirement) {
            const colorKills = stats.colorKills[def.colorRequirement.colorId] || 0;
            mission.currentProgress += colorKills;
          }
          break;

        case MissionType.COLOR_SPECIFIC_MATCH:
          if (def.requirementType === MissionRequirementType.COLOR_KILLS && def.colorRequirement) {
            const colorKills = stats.colorKills[def.colorRequirement.colorId] || 0;
            if (!mission.matchProgress) {
              mission.matchProgress = [];
            }
            mission.matchProgress.push({
              matchId,
              progress: colorKills,
            });
            mission.currentProgress = Math.max(
              ...mission.matchProgress.map(m => m.progress),
            );
          }
          break;
      }

      // Check if mission is completed
      if (mission.currentProgress >= def.requirementValue && mission.status === MissionStatus.IN_PROGRESS) {
        mission.status = MissionStatus.COMPLETED;
        mission.completedAt = new Date();
      }

      await mission.save();
    }
  }

  /**
   * Claim mission rewards
   * -------------------
   * Claims rewards for a completed mission
   */
  async claimMissionReward(userId: string, missionProgressId: string) {
    const mission = await this.missionProgressModel
      .findById(missionProgressId)
      .populate('missionId');

    if (!mission) {
      throw new NotFoundException('Mission progress not found');
    }

    if (mission.status !== MissionStatus.COMPLETED) {
      throw new BadRequestException('Mission is not completed');
    }

    const def = mission.missionId as MissionDefinitionDocument;

    // Check if special prize is available
    if (def.specialPrize && def.specialPrize.limitedToFirst > 0) {
      if (def.specialPrize.remaining <= 0) {
        throw new BadRequestException('Special prize is no longer available');
      }
      def.specialPrize.remaining--;
      await def.save();
    }

    // Get current leaderboard
    const currentLeaderboard = await this.leaderboardService.getCurrentLeaderboard(GameType.NAIRA_RAID);
    
    // Update leaderboard entry with extra points
    const leaderboardEntry = await this.leaderboardEntryModel.findOne({
      userId,
      leaderboardId: currentLeaderboard._id,
    });

    if (leaderboardEntry) {
      leaderboardEntry.extraPoints = (leaderboardEntry.extraPoints || 0) + def.points;
      await leaderboardEntry.save();
    }

    // Update mission points tracking
    let missionPoints = await this.missionPointsModel.findOne({
      userId,
      gameId: GameType.NAIRA_RAID,
      seasonNumber: currentLeaderboard.seasonNumber,
    });

    if (!missionPoints) {
      missionPoints = new this.missionPointsModel({
        userId,
        gameId: GameType.NAIRA_RAID,
        seasonNumber: currentLeaderboard.seasonNumber,
        totalPoints: 0,
        pointHistory: [],
      });
    }

    // Add points to history and update total
    const missionDefinition = mission.missionId as MissionDefinitionDocument;
    missionPoints.pointHistory.push({
      missionId: missionDefinition._id as MongooseSchema.Types.ObjectId,
      points: missionDefinition.points,
      date: new Date(),
    });
    missionPoints.totalPoints += missionDefinition.points;
    await missionPoints.save();

    // Update mission status
    mission.status = MissionStatus.CLAIMED;
    mission.claimedAt = new Date();
    await mission.save();

    return {
      claimed: true,
      points: missionDefinition.points,
      specialPrize: def.specialPrize && def.specialPrize.remaining > 0,
    };
  }

  /**
   * Get mission points
   * ----------------
   * Gets the total mission points for a player in the current season
   */
  async getMissionPoints(userId: string, gameId: string): Promise<number> {
    const currentLeaderboard = await this.leaderboardService.getCurrentLeaderboard(gameId);
    
    const points = await this.missionPointsModel.findOne({
      userId,
      gameId,
      seasonNumber: currentLeaderboard.seasonNumber,
    });

    return points?.totalPoints || 0;
  }

  /**
   * Create a new mission definition
   */
  async createMissionDefinition(createDto: CreateMissionDefinitionDto): Promise<MissionDefinitionDocument> {
    // Create the mission definition
    const missionDefinition = new this.missionDefinitionModel({
      ...createDto,
      isActive: true,
    });

    return missionDefinition.save();
  }

  /**
   * Get all mission definitions
   */
  async getMissionDefinitions(activeOnly: boolean = false) {
    const query = activeOnly ? { isActive: true } : {};
    return this.missionDefinitionModel.find(query).exec();
  }

  /**
   * Get a specific mission definition
   */
  async getMissionDefinitionById(id: string): Promise<MissionDefinitionDocument> {
    const mission = await this.missionDefinitionModel.findById(id);
    if (!mission) {
      throw new NotFoundException(`Mission definition with ID ${id} not found`);
    }
    return mission;
  }

  /**
   * Update a mission definition
   */
  async updateMissionDefinition(
    id: string,
    updateDto: Partial<CreateMissionDefinitionDto>,
  ): Promise<MissionDefinitionDocument> {
    const mission = await this.missionDefinitionModel.findByIdAndUpdate(
      id,
      { $set: updateDto },
      { new: true },
    );

    if (!mission) {
      throw new NotFoundException(`Mission definition with ID ${id} not found`);
    }

    return mission;
  }

  /**
   * Deactivate a mission definition
   */
  async deactivateMissionDefinition(id: string): Promise<MissionDefinitionDocument> {
    const mission = await this.missionDefinitionModel.findByIdAndUpdate(
      id,
      { $set: { isActive: false } },
      { new: true },
    );

    if (!mission) {
      throw new NotFoundException(`Mission definition with ID ${id} not found`);
    }

    return mission;
  }
}

================
File: src/daily-missions/daily-missions.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { DailyMissionsController } from './daily-missions.controller';

describe('DailyMissionsController', () => {
  let controller: DailyMissionsController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DailyMissionsController],
    }).compile();

    controller = module.get<DailyMissionsController>(DailyMissionsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/daily-missions/daily-missions.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 4eba985d7059f46fa8053dad2f6f3883
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.controller.ts
================
import { Controller } from '@nestjs/common';

@Controller('daily-missions')
export class DailyMissionsController {}

================
File: src/daily-missions/daily-missions.controller.ts.meta
================
fileFormatVersion: 2
guid: 43b666801c3fe4c7b9783f9d8d0a38e3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { DailyMissionsController } from './controllers/daily-missions.controller';
import { DailyMissionsService } from './services/daily-missions.service';
import { MissionDefinition, MissionDefinitionSchema } from './schemas/mission-definition.schema';
import { MissionProgress, MissionProgressSchema } from './schemas/mission-progress.schema';
import { MissionPoints, MissionPointsSchema } from './schemas/mission-points.schema';
import { LeaderboardModule } from '../leaderboard/leaderboard.module';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../leaderboard/schemas/leaderboard-entry.schema';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => LeaderboardModule),
    MongooseModule.forFeature([
      { name: MissionDefinition.name, schema: MissionDefinitionSchema },
      { name: MissionProgress.name, schema: MissionProgressSchema },
      { name: MissionPoints.name, schema: MissionPointsSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
    ]),
  ],
  controllers: [DailyMissionsController],
  providers: [DailyMissionsService],
  exports: [DailyMissionsService],
})
export class DailyMissionsModule {}

================
File: src/daily-missions/daily-missions.module.ts.meta
================
fileFormatVersion: 2
guid: 0c81bdf25d3b54d0b8fe83f8f5dc127b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { DailyMissionsService } from './daily-missions.service';

describe('DailyMissionsService', () => {
  let service: DailyMissionsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DailyMissionsService],
    }).compile();

    service = module.get<DailyMissionsService>(DailyMissionsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/daily-missions/daily-missions.service.spec.ts.meta
================
fileFormatVersion: 2
guid: f0e5d4d2ac74f4900a25d0ec1de78830
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.service.ts
================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  DailyMission,
  DailyMissionDocument,
} from './schemas/daily-mission.schema';
import {
  UserMissionProgress,
  UserMissionProgressDocument,
} from './schemas/user-mission-progress.schema';
import { CreateDailyMissionDto } from './dto/create-daily-mission.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { MissionType } from './schemas/daily-mission.schema';

@Injectable()
export class DailyMissionsService {
  constructor(
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
    @InjectModel(UserMissionProgress.name)
    private readonly userMissionProgressModel: Model<UserMissionProgressDocument>,
  ) {}

  async createMission(
    createDailyMissionDto: CreateDailyMissionDto,
  ): Promise<DailyMissionDocument> {
    const mission = new this.dailyMissionModel(createDailyMissionDto);
    return mission.save();
  }

  async findAllMissions(gameId: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [missions, total] = await Promise.all([
      this.dailyMissionModel
        .find({ gameId, isActive: true })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.dailyMissionModel.countDocuments({ gameId, isActive: true }),
    ]);

    return {
      missions,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getUserMissionProgress(userId: string, gameId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const activeMissions = await this.dailyMissionModel.find({
      gameId,
      isActive: true,
    });

    const userProgress = await this.userMissionProgressModel
      .find({
        userId,
        missionId: { $in: activeMissions.map((m) => m._id) },
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
      })
      .populate('missionId');

    // Create progress entries for missions that don't have them yet
    const existingMissionIds = userProgress.map((p) => 
      p.missionId._id.toString(),
    );
    const missionsWithoutProgress = activeMissions.filter(
      (m) => !existingMissionIds.includes(m._id.toString()),
    );

    if (missionsWithoutProgress.length > 0) {
      const newProgressEntries = await this.userMissionProgressModel.insertMany(
        missionsWithoutProgress.map((mission) => ({
          userId,
          missionId: mission._id,
          gameId,
          progress: 0,
          matchProgresses: [],
          date: today,
        })),
      );

      userProgress.push(
        ...(await this.userMissionProgressModel
          .find({ _id: { $in: newProgressEntries.map((p) => p._id) } })
          .populate('missionId')),
      );
    }

    return userProgress;
  }

  async updateMissionProgress(
    userId: string,
    gameId: string,
    gameStats: { totalKills: number },
    matchNumber: number,
  ) {
    const userProgress = await this.getUserMissionProgress(userId, gameId);

    const updates = userProgress.map(async (progress) => {
      const mission = progress.missionId as DailyMissionDocument;
      let shouldUpdate = false;
      let newProgress = progress.progress;

      switch (mission.type) {
        case MissionType.TOTAL_KILLS:
          newProgress = progress.progress + gameStats.totalKills;
          shouldUpdate = true;
          break;

        case MissionType.SINGLE_MATCH_KILLS:
          if (gameStats.totalKills > progress.progress) {
            newProgress = gameStats.totalKills;
            shouldUpdate = true;
          }
          break;

        case MissionType.KILLS_IN_MATCHES:
          progress.matchProgresses[matchNumber - 1] = gameStats.totalKills;
          const validMatches = progress.matchProgresses
            .filter((kills) => kills >= mission.target)
            .length;
          newProgress = validMatches;
          shouldUpdate = true;
          break;
      }

      if (shouldUpdate) {
        progress.progress = newProgress;
        progress.isCompleted = newProgress >= mission.target;
        return progress.save();
      }

      return progress;
    });

    return Promise.all(updates);
  }

  async claimReward(userId: string, missionId: string): Promise<number> {
    const progress = await this.userMissionProgressModel
      .findOne({ userId, missionId })
      .populate('missionId');

    if (!progress) {
      throw new NotFoundException('Mission progress not found');
    }

    if (!progress.isCompleted) {
      throw new BadRequestException('Mission not completed');
    }

    if (progress.rewardClaimed) {
      throw new BadRequestException('Reward already claimed');
    }

    progress.rewardClaimed = true;
    await progress.save();

    const mission = progress.missionId as DailyMissionDocument;
    return mission.rewardPoints;
  }
}

================
File: src/daily-missions/daily-missions.service.ts.meta
================
fileFormatVersion: 2
guid: 444557d4d19d645f39aca27235d05cd6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/dto.meta
================
fileFormatVersion: 2
guid: 4e10823e1a09540308108911ed5db7a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas.meta
================
fileFormatVersion: 2
guid: 26b82d9e3a5734c9b8982f2e7fc79e6b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/daily-mission.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { DailyMission, DailyMissionDocument, MissionType } from '../../daily-missions/schemas/daily-mission.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class DailyMissionSeeder {
  constructor(
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
  ) {}

  async seed(): Promise<DailyMissionDocument[]> {
    // Clear existing missions
    await this.dailyMissionModel.deleteMany({});

    const missions: Partial<DailyMission>[] = [];

    // Create missions for each type
    Object.values(MissionType).forEach((type) => {
      const count = faker.number.int({ min: 2, max: 4 }); // 2-4 missions per type
      
      for (let i = 0; i < count; i++) {
        const target = faker.number.int({ min: 5, max: 50 });
        const missionData: Partial<DailyMission> = {
          name: this.generateMissionName(type, target),
          description: this.generateMissionDescription(type, target),
          gameId: GameType.NAIRA_RAID,
          type,
          target,
          rewardPoints: faker.number.int({ min: 100, max: 1000 }),
          isActive: true,
        };

        // Only add matchesRequired for KILLS_IN_MATCHES type
        if (type === MissionType.KILLS_IN_MATCHES) {
          missionData.matchesRequired = faker.number.int({ min: 3, max: 5 });
        }

        missions.push(missionData);
      }
    });

    return this.dailyMissionModel.insertMany(missions) as Promise<DailyMissionDocument[]>;
  }

  private generateMissionName(type: MissionType, target: number): string {
    switch (type) {
      case MissionType.TOTAL_KILLS:
        return `Eliminate ${target} Enemies`;
      case MissionType.SINGLE_MATCH_KILLS:
        return `Get ${target} Kills in One Match`;
      case MissionType.KILLS_IN_MATCHES:
        return `Get ${target} Kills in Multiple Matches`;
      default:
        return `Complete ${target} Objectives`;
    }
  }

  private generateMissionDescription(type: MissionType, target: number): string {
    switch (type) {
      case MissionType.TOTAL_KILLS:
        return `Eliminate a total of ${target} enemies in any number of matches.`;
      case MissionType.SINGLE_MATCH_KILLS:
        return `Eliminate ${target} enemies in a single match.`;
      case MissionType.KILLS_IN_MATCHES:
        return `Get ${target} kills in each of several matches.`;
      default:
        return `Complete ${target} mission objectives.`;
    }
  }
}

================
File: src/database/seeders/daily-mission.seeder.ts.meta
================
fileFormatVersion: 2
guid: 7f76c1a7e7c1047fca7f2ca5303a1eda
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/daily-missions.seeder.ts
================
/* eslint-disable max-len */
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MissionDefinition, MissionType, MissionRequirementType } from '../../daily-missions/schemas/mission-definition.schema';
import { EnemyColor } from '../../daily-missions/schemas/enemy-color.schema';
import { MissionProgress, MissionStatus } from '../../daily-missions/schemas/mission-progress.schema';
import { MissionPoints } from '../../daily-missions/schemas/mission-points.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class DailyMissionsSeeder {
  constructor(
    @InjectModel(MissionDefinition.name)
    private readonly missionDefinitionModel: Model<MissionDefinition>,
    @InjectModel(EnemyColor.name)
    private readonly enemyColorModel: Model<EnemyColor>,
    @InjectModel(MissionProgress.name)
    private readonly missionProgressModel: Model<MissionProgress>,
    @InjectModel(MissionPoints.name)
    private readonly missionPointsModel: Model<MissionPoints>,
  ) {
    console.log('[DailyMissionsSeeder] Constructed');
    console.log(`[DailyMissionsSeeder] MissionDefinition model name: ${MissionDefinition.name}`);
    console.log(`[DailyMissionsSeeder] EnemyColor model name: ${EnemyColor.name}`);
  }

  async seed() {
    try {
      console.log('[DailyMissionsSeeder] Starting daily missions seeding...');
      
      // Clear existing data
      console.log('[DailyMissionsSeeder] Clearing existing data...');
      const [missionDeleteResult, colorDeleteResult, progressDeleteResult, pointsDeleteResult] = await Promise.all([
        this.missionDefinitionModel.deleteMany({}),
        this.enemyColorModel.deleteMany({}),
        this.missionProgressModel.deleteMany({}),
        this.missionPointsModel.deleteMany({}),
      ]);
      console.log(`[DailyMissionsSeeder] Deleted ${missionDeleteResult.deletedCount} mission definitions`);
      console.log(`[DailyMissionsSeeder] Deleted ${colorDeleteResult.deletedCount} enemy colors`);
      console.log(`[DailyMissionsSeeder] Deleted ${progressDeleteResult.deletedCount} mission progresses`);
      console.log(`[DailyMissionsSeeder] Deleted ${pointsDeleteResult.deletedCount} mission points`);

      // Seed enemy colors
      console.log('[DailyMissionsSeeder] Creating enemy colors...');
      const colorData = [
        {
          name: 'Red',
          hexCode: '#FF0000',
          isActive: true,
          properties: {
            pointMultiplier: 1.0,
            rarity: 'common',
            description: 'Basic enemy type',
          },
        },
        {
          name: 'Blue',
          hexCode: '#0000FF',
          isActive: true,
          properties: {
            pointMultiplier: 1.5,
            rarity: 'rare',
            description: 'Faster and more agile',
          },
        },
        {
          name: 'Gold',
          hexCode: '#FFD700',
          isActive: true,
          properties: {
            pointMultiplier: 3.0,
            rarity: 'legendary',
            description: 'Rare and valuable enemy',
          },
        },
      ];

      console.log('[DailyMissionsSeeder] About to create enemy colors with data:', JSON.stringify(colorData, null, 2));
      const colors = await this.enemyColorModel.create(colorData);
      console.log(`[DailyMissionsSeeder] Created ${colors.length} enemy colors`);

      // Log color IDs for debugging
      colors.forEach(color => {
        console.log(`[DailyMissionsSeeder] Created color: ${color.name} with ID: ${color._id}`);
      });

      // Seed mission definitions
      console.log('[DailyMissionsSeeder] Creating mission definitions...');
      const missionData = [
        {
          title: 'Kill Streak',
          description: 'Get 50 kills in a single match',
          type: MissionType.SINGLE_MATCH,
          requirementType: MissionRequirementType.KILLS,
          requirementValue: 50,
          points: 300,
          isActive: true,
        },
        {
          title: 'Daily Hunter',
          description: 'Accumulate 100 kills throughout the day',
          type: MissionType.DAILY_CUMULATIVE,
          requirementType: MissionRequirementType.KILLS,
          requirementValue: 100,
          points: 200,
          isActive: true,
        },
        {
          title: 'Gold Rush',
          description: 'Kill 10 gold enemies in a single match',
          type: MissionType.COLOR_SPECIFIC_MATCH,
          requirementType: MissionRequirementType.COLOR_KILLS,
          requirementValue: 10,
          colorRequirement: {
            colorId: colors[2]._id.toString(),
            colorName: 'Gold',
          },
          points: 500,
          isActive: true,
        },
        {
          title: 'Blue Hunter',
          description: 'Kill 30 blue enemies throughout the day',
          type: MissionType.COLOR_SPECIFIC_DAILY,
          requirementType: MissionRequirementType.COLOR_KILLS,
          requirementValue: 30,
          colorRequirement: {
            colorId: colors[1]._id.toString(),
            colorName: 'Blue',
          },
          points: 300,
          isActive: true,
        },
        {
          title: 'Red Menace',
          description: 'Kill 50 red enemies throughout the day',
          type: MissionType.COLOR_SPECIFIC_DAILY,
          requirementType: MissionRequirementType.COLOR_KILLS,
          requirementValue: 50,
          colorRequirement: {
            colorId: colors[0]._id.toString(),
            colorName: 'Red',
          },
          points: 200,
          isActive: true,
        },
      ];

      console.log('[DailyMissionsSeeder] About to create mission definitions with data:', JSON.stringify(missionData, null, 2));
      const missions = await this.missionDefinitionModel.create(missionData);
      console.log(`[DailyMissionsSeeder] Created ${missions.length} mission definitions`);

      // Log mission details for debugging
      missions.forEach(mission => {
        console.log(`[DailyMissionsSeeder] Created mission: ${mission.title} with ID: ${mission._id}`);
      });

      // Create some sample mission progress and points
      console.log('[DailyMissionsSeeder] Creating sample mission progress and points...');
      
      // Sample user IDs (you might want to get these from actual users)
      const sampleUserIds = [
        '507f1f77bcf86cd799439011',
        '507f1f77bcf86cd799439012',
        '507f1f77bcf86cd799439013'
      ];

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Create mission progress for each user
      for (const userId of sampleUserIds) {
        // Create progress for each mission
        const progressData = missions.map(mission => ({
          userId,
          missionId: mission._id,
          date: today,
          currentProgress: Math.floor(Math.random() * mission.requirementValue),
          status: MissionStatus.IN_PROGRESS,
        }));

        await this.missionProgressModel.create(progressData);
        console.log(`[DailyMissionsSeeder] Created ${progressData.length} mission progresses for user ${userId}`);

        // Create mission points
        const pointsData = {
          userId,
          gameId: GameType.NAIRA_RAID,
          seasonNumber: 1,
          totalPoints: Math.floor(Math.random() * 1000),
          pointHistory: missions.map(mission => ({
            missionId: mission._id,
            points: mission.points,
            date: new Date(),
          })),
        };

        await this.missionPointsModel.create(pointsData);
        console.log(`[DailyMissionsSeeder] Created mission points for user ${userId}`);
      }

      // Verify the data was created
      const colorCount = await this.enemyColorModel.countDocuments();
      const missionCount = await this.missionDefinitionModel.countDocuments();
      const progressCount = await this.missionProgressModel.countDocuments();
      const pointsCount = await this.missionPointsModel.countDocuments();

      console.log(`[DailyMissionsSeeder] Verification - Colors: ${colorCount}, Missions: ${missionCount}, Progresses: ${progressCount}, Points: ${pointsCount}`);

      return {
        colors,
        missions,
        progressCount,
        pointsCount,
      };
    } catch (error) {
      console.error('[DailyMissionsSeeder] Error seeding daily missions:', error.stack || error);
      throw error;
    }
  }
}

================
File: src/database/seeders/inventory.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { InventoryItem, InventoryItemDocument } from '../../inventory/schemas/inventory-item.schema';
import { UserInventory, UserInventoryDocument } from '../../inventory/schemas/user-inventory.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class InventorySeeder {
  constructor(
    @InjectModel(InventoryItem.name)
    private readonly inventoryItemModel: Model<InventoryItemDocument>,
    @InjectModel(UserInventory.name)
    private readonly userInventoryModel: Model<UserInventoryDocument>,
  ) {}

  async seed(users: UserDocument[]) {
    // Clear existing data
    await Promise.all([
      this.inventoryItemModel.deleteMany({}),
      this.userInventoryModel.deleteMany({}),
    ]);

    // Create inventory items
    const items = await this.createInventoryItems();

    // Create user inventories
    const userInventories = await this.createUserInventories(users, items);

    return {
      items,
      userInventories,
    };
  }

  private async createInventoryItems(): Promise<InventoryItemDocument[]> {
    const itemTypes = ['power-up', 'weapon', 'currency', 'boost'];
    const items: Partial<InventoryItem>[] = [];

    // Create 20 random items
    for (let i = 0; i < 20; i++) {
      const type = faker.helpers.arrayElement(itemTypes);
      items.push({
        name: faker.commerce.productName(),
        description: faker.commerce.productDescription(),
        gameId: GameType.NAIRA_RAID,
        type,
        duration: type === 'power-up' ? faker.number.int({ min: 30, max: 300 }) : undefined,
        power: type === 'weapon' ? faker.number.int({ min: 1, max: 100 }) : undefined,
        isActive: true,
      });
    }

    return this.inventoryItemModel.insertMany(items) as Promise<InventoryItemDocument[]>;
  }

  private async createUserInventories(
    users: UserDocument[],
    items: InventoryItemDocument[],
  ): Promise<UserInventoryDocument[]> {
    const userInventories: Partial<UserInventory>[] = [];

    for (const user of users) {
      // Give each user 1-5 random items
      const itemCount = faker.number.int({ min: 1, max: 5 });
      const selectedItems = faker.helpers.arrayElements(items, itemCount);

      for (const item of selectedItems) {
        userInventories.push({
          userId: user._id,
          itemId: item._id,
          quantity: faker.number.int({ min: 1, max: 10 }),
          gameId: GameType.NAIRA_RAID,
          expiresAt: faker.helpers.arrayElement([
            undefined,
            faker.date.future(),
          ]),
        });
      }
    }

    return this.userInventoryModel.insertMany(userInventories) as Promise<UserInventoryDocument[]>;
  }
}

================
File: src/database/seeders/inventory.seeder.ts.meta
================
fileFormatVersion: 2
guid: 84afe2f1dc24f42959c73c6424cc8e8a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/leaderboard.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { Leaderboard, LeaderboardDocument } from '../../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntryDocument } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionDocument } from '../../leaderboard/schemas/game-session.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class LeaderboardSeeder {
  constructor(
    @InjectModel(Leaderboard.name)
    private readonly leaderboardModel: Model<LeaderboardDocument>,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
    @InjectModel(GameSession.name)
    private readonly gameSessionModel: Model<GameSessionDocument>,
  ) {}

  async seed(users: UserDocument[]) {
    // Clear existing data
    await Promise.all([
      this.leaderboardModel.deleteMany({}),
      this.leaderboardEntryModel.deleteMany({}),
      this.gameSessionModel.deleteMany({}),
    ]);

    // Create current season leaderboard
    const currentLeaderboard = await this.leaderboardModel.create({
      seasonNumber: 1,
      seasonStart: new Date(),
      seasonEnd: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days from now
      gameId: GameType.NAIRA_RAID,
      isActive: true,
    });

    // Create leaderboard entries and game sessions for each user
    const leaderboardEntries = [];
    const gameSessions = [];

    for (const user of users) {
      // Create 1-5 game sessions per user
      const sessionCount = faker.number.int({ min: 1, max: 5 });
      for (let i = 0; i < sessionCount; i++) {
        const score = faker.number.int({ min: 100, max: 10000 });
        const totalKills = faker.number.int({ min: 5, max: 50 });
        const cashCollected = faker.number.int({ min: 1000, max: 100000 });

        gameSessions.push({
          userId: user._id,
          gameId: GameType.NAIRA_RAID,
          score,
          gameStats: {
            totalKills,
            cashCollected,
          },
          isCompleted: true,
        });
      }

      // Create leaderboard entry with highest score
      const highestScore = Math.max(...gameSessions
        .filter(session => session.userId.toString() === user._id.toString())
        .map(session => session.score));

      leaderboardEntries.push({
        userId: user._id,
        leaderboardId: currentLeaderboard._id,
        score: highestScore,
        extraPoints: faker.number.int({ min: 0, max: 1000 }),
        seasonNumber: currentLeaderboard.seasonNumber,
        gameId: GameType.NAIRA_RAID,
        gameStats: {
          totalKills: faker.number.int({ min: 50, max: 500 }),
          cashCollected: faker.number.int({ min: 10000, max: 1000000 }),
        },
      });
    }

    await Promise.all([
      this.leaderboardEntryModel.insertMany(leaderboardEntries),
      this.gameSessionModel.insertMany(gameSessions),
    ]);

    return {
      leaderboard: currentLeaderboard,
      entries: leaderboardEntries,
      sessions: gameSessions,
    };
  }
}

================
File: src/database/seeders/leaderboard.seeder.ts.meta
================
fileFormatVersion: 2
guid: b12afed1b0e954a1fbe141f9e8af4f8d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/player-progress.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { PlayerProgress, PlayerProgressDocument } from '../../player-progress/schemas/player-progress.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class PlayerProgressSeeder {
  constructor(
    @InjectModel(PlayerProgress.name)
    private readonly playerProgressModel: Model<PlayerProgressDocument>,
  ) {}

  async seed(users: UserDocument[]): Promise<PlayerProgressDocument[]> {
    // Clear existing progress
    await this.playerProgressModel.deleteMany({});

    const progressRecords: Partial<PlayerProgress>[] = [];

    // Create progress for each user
    for (const user of users) {
      const level = faker.number.int({ min: 1, max: 50 });
      const ranks = ['Rookie', 'Intermediate', 'Advanced', 'Veteran', 'Expert', 'Master', 'Legend'];
      const currentRankIndex = Math.min(Math.floor(level / 7), ranks.length - 1);
      
      // Generate rank history
      const rankHistory = [];
      for (let i = 0; i <= currentRankIndex; i++) {
        rankHistory.push({
          rank: ranks[i],
          achievedAt: faker.date.past(),
        });
      }

      progressRecords.push({
        userId: user._id,
        gameId: GameType.NAIRA_RAID,
        level,
        experience: faker.number.int({ min: 0, max: 999 }),
        experienceToNextLevel: 1000 * Math.pow(1.2, level - 1),
        rank: {
          current: ranks[currentRankIndex],
          history: rankHistory.sort((a, b) => a.achievedAt.getTime() - b.achievedAt.getTime()),
        },
        unlocks: {
          items: [],
          achievements: [],
          powerUps: [],
        },
      });
    }

    return this.playerProgressModel.insertMany(progressRecords) as Promise<PlayerProgressDocument[]>;
  }
}

================
File: src/database/seeders/player-progress.seeder.ts.meta
================
fileFormatVersion: 2
guid: ac50ea2ecb69f49e18d65f5b9c8d0964
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/seed.ts
================
import { NestFactory } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { Module } from '@nestjs/common';
import { User, UserSchema } from '../../user/schemas/user.schema';
import { Leaderboard, LeaderboardSchema } from '../../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from '../../leaderboard/schemas/game-session.schema';
import { InventoryItem, InventoryItemSchema } from '../../inventory/schemas/inventory-item.schema';
import { UserInventory, UserInventorySchema } from '../../inventory/schemas/user-inventory.schema';
import { DailyMission, DailyMissionSchema } from '../../daily-missions/schemas/daily-mission.schema';
import { PlayerProgress, PlayerProgressSchema } from '../../player-progress/schemas/player-progress.schema';
import { UserSeeder } from './user.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { InventorySeeder } from './inventory.seeder';
import { DailyMissionSeeder } from './daily-mission.seeder';
import { PlayerProgressSeeder } from './player-progress.seeder';

@Module({
  imports: [
    ConfigModule.forRoot(),
    MongooseModule.forRoot(process.env.MONGODB_URI),
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
      { name: InventoryItem.name, schema: InventoryItemSchema },
      { name: UserInventory.name, schema: UserInventorySchema },
      { name: DailyMission.name, schema: DailyMissionSchema },
      { name: PlayerProgress.name, schema: PlayerProgressSchema },
    ]),
  ],
  providers: [
    UserSeeder,
    LeaderboardSeeder,
    InventorySeeder,
    DailyMissionSeeder,
    PlayerProgressSeeder,
  ],
})
class SeedModule {}

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);

  const userSeeder = app.get(UserSeeder);
  const leaderboardSeeder = app.get(LeaderboardSeeder);
  const inventorySeeder = app.get(InventorySeeder);
  const dailyMissionSeeder = app.get(DailyMissionSeeder);
  const playerProgressSeeder = app.get(PlayerProgressSeeder);

  try {
    console.log(' Starting database seeding...');

    // Create users first as other entities depend on them
    console.log('Seeding users...');
    const users = await userSeeder.seed();
    console.log(' Users seeded successfully');

    // Create missions before mission progress
    console.log('Seeding daily missions...');
    const missions = await dailyMissionSeeder.seed();
    console.log(' Daily missions seeded successfully');

    // Seed other collections in parallel
    await Promise.all([
      (async () => {
        console.log('Seeding leaderboards...');
        await leaderboardSeeder.seed(users);
        console.log(' Leaderboards seeded successfully');
      })(),
      (async () => {
        console.log('Seeding inventory items...');
        await inventorySeeder.seed(users);
        console.log(' Inventory seeded successfully');
      })(),
      (async () => {
        console.log('Seeding player progress...');
        await playerProgressSeeder.seed(users);
        console.log(' Player progress seeded successfully');
      })(),
    ]);

    console.log(' Database seeding completed successfully!');
  } catch (error) {
    console.error(' Database seeding failed:', error);
    throw error;
  } finally {
    await app.close();
  }
}

bootstrap();

================
File: src/database/seeders/seed.ts.meta
================
fileFormatVersion: 2
guid: 16f147d4af8eb4cdc96c8a905675af14
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/seeder.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { Test } from '@nestjs/testing';
import { UserSeeder } from './user.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { InventorySeeder } from './inventory.seeder';
import { DailyMissionSeeder } from './daily-mission.seeder';
import { PlayerProgressSeeder } from './player-progress.seeder';

@Injectable()
export class Seeder {
  constructor(private readonly configService: ConfigService) {}

  async seed() {
    const moduleRef = await Test.createTestingModule({
      imports: [
        MongooseModule.forRootAsync({
          useFactory: () => ({
            uri: this.configService.get<string>('MONGODB_URI'),
          }),
          inject: [ConfigService],
        }),
      ],
      providers: [
        UserSeeder,
        LeaderboardSeeder,
        InventorySeeder,
        DailyMissionSeeder,
        PlayerProgressSeeder,
      ],
    }).compile();

    const userSeeder = moduleRef.get(UserSeeder);
    const leaderboardSeeder = moduleRef.get(LeaderboardSeeder);
    const inventorySeeder = moduleRef.get(InventorySeeder);
    const dailyMissionSeeder = moduleRef.get(DailyMissionSeeder);
    const playerProgressSeeder = moduleRef.get(PlayerProgressSeeder);

    try {
      console.log(' Starting database seeding...');

      // Create users first as other entities depend on them
      console.log('Seeding users...');
      const users = await userSeeder.seed();
      console.log(' Users seeded successfully');

      // Seed other collections in parallel
      await Promise.all([
        (async () => {
          console.log('Seeding leaderboards...');
          await leaderboardSeeder.seed(users);
          console.log(' Leaderboards seeded successfully');
        })(),
        (async () => {
          console.log('Seeding inventory items...');
          await inventorySeeder.seed(users);
          console.log(' Inventory seeded successfully');
        })(),
        (async () => {
          console.log('Seeding daily missions...');
          await dailyMissionSeeder.seed();
          console.log(' Daily missions seeded successfully');
        })(),
        (async () => {
          console.log('Seeding player progress...');
          await playerProgressSeeder.seed(users);
          console.log(' Player progress seeded successfully');
        })(),
      ]);

      console.log(' Database seeding completed successfully!');
    } catch (error) {
      console.error(' Database seeding failed:', error);
      throw error;
    }
  }
}

================
File: src/database/seeders/seeder.ts.meta
================
fileFormatVersion: 2
guid: 0c5e1ac9e4a9340ac9d862030200dcaf
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/user-mission-progress.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { UserMissionProgress, UserMissionProgressDocument } from '../../daily-missions/schemas/user-mission-progress.schema';
import { DailyMission, DailyMissionDocument } from '../../daily-missions/schemas/daily-mission.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class UserMissionProgressSeeder {
  constructor(
    @InjectModel(UserMissionProgress.name)
    private readonly userMissionProgressModel: Model<UserMissionProgressDocument>,
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
  ) {}

  async seed(users: UserDocument[]): Promise<UserMissionProgressDocument[]> {
    // Clear existing progress
    await this.userMissionProgressModel.deleteMany({});

    // Get all active missions
    const missions = await this.dailyMissionModel.find({ isActive: true });
    if (!missions.length) {
      console.log('No active missions found to create progress for');
      return [];
    }

    const progressRecords: Partial<UserMissionProgress>[] = [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Create progress records for each user
    for (const user of users) {
      // Randomly select 1-3 missions for each user
      const userMissions = faker.helpers.arrayElements(
        missions,
        faker.number.int({ min: 1, max: 3 })
      );

      for (const mission of userMissions) {
        const progress = faker.number.int({ min: 0, max: mission.target });
        const isCompleted = progress >= mission.target;

        progressRecords.push({
          userId: user._id,
          missionId: mission._id,
          progress,
          matchProgresses: mission.matchesRequired 
            ? Array.from({ length: faker.number.int({ min: 0, max: mission.matchesRequired }) }, 
                () => faker.number.int({ min: 0, max: mission.target }))
            : [],
          date: today,
          gameId: GameType.NAIRA_RAID,
          isCompleted,
          rewardClaimed: isCompleted && faker.datatype.boolean(),
        });
      }
    }

    return this.userMissionProgressModel.insertMany(progressRecords) as Promise<UserMissionProgressDocument[]>;
  }
}

================
File: src/database/seeders/user-mission-progress.seeder.ts.meta
================
fileFormatVersion: 2
guid: c1c4643a6b3a944caa02e988482cfc30
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/user.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';
import { User, UserDocument } from '../../user/schemas/user.schema';

@Injectable()
export class UserSeeder {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  async seed(count = 20): Promise<UserDocument[]> {
    // Define the type with required fields
    type CreateUserData = Required<Pick<User, 'firstName' | 'username' | 'email' | 'password'>> &
      Partial<Omit<User, 'firstName' | 'username' | 'email' | 'password' | '_id'>>;

    const users: CreateUserData[] = [];
    const hashedPassword = await bcrypt.hash('password123', 10);

    // Create one admin user with known credentials
    users.push({
      firstName: 'Admin',
      lastName: 'User',
      username: 'admin',
      email: 'admin@nairaraid.com',
      password: hashedPassword,
      isEmailVerified: true,
      points: 1000,
    });

    // Generate random users
    for (let i = 0; i < count - 1; i++) {
      const firstName = faker.person.firstName();
      const lastName = faker.person.lastName();
      
      users.push({
        firstName,
        lastName,
        username: faker.internet.username({ firstName, lastName }).toLowerCase(),
        email: faker.internet.email({ firstName, lastName }).toLowerCase(),
        password: hashedPassword,
        phoneNumber: faker.phone.number(),
        isEmailVerified: faker.datatype.boolean(),
        instagram: faker.internet.username(),
        tiktok: faker.internet.username(),
        points: faker.number.int({ min: 0, max: 10000 }),
      });
    }

    // Clear existing users
    await this.userModel.deleteMany({});

    // Insert new users
    return this.userModel.insertMany(users) as Promise<UserDocument[]>;
  }
}

================
File: src/database/seeders/user.seeder.ts.meta
================
fileFormatVersion: 2
guid: b35da8d99930a472495a02a93558c7cf
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/database.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UserSeeder } from './seeders/user.seeder';
import { LeaderboardSeeder } from './seeders/leaderboard.seeder';
import { DailyMissionsSeeder } from './seeders/daily-missions.seeder';
import { User, UserSchema } from '../user/schemas/user.schema';
import { Leaderboard, LeaderboardSchema } from '../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from '../leaderboard/schemas/game-session.schema';
import { MissionDefinition, MissionDefinitionSchema } from '../daily-missions/schemas/mission-definition.schema';
import { MissionProgress, MissionProgressSchema } from '../daily-missions/schemas/mission-progress.schema';
import { MissionPoints, MissionPointsSchema } from '../daily-missions/schemas/mission-points.schema';
import { EnemyColor, EnemyColorSchema } from '../daily-missions/schemas/enemy-color.schema';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
      { name: MissionDefinition.name, schema: MissionDefinitionSchema },
      { name: MissionProgress.name, schema: MissionProgressSchema },
      { name: MissionPoints.name, schema: MissionPointsSchema },
      { name: EnemyColor.name, schema: EnemyColorSchema },
    ]),
  ],
  providers: [
    UserSeeder,
    LeaderboardSeeder,
    {
      provide: DailyMissionsSeeder,
      useClass: DailyMissionsSeeder,
    },
  ],
  exports: [UserSeeder, LeaderboardSeeder, DailyMissionsSeeder],
})
export class DatabaseModule {}

================
File: src/database/seed.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from '../app.module';
import { DatabaseModule } from './database.module';
import { UserSeeder } from './seeders/user.seeder';
import { LeaderboardSeeder } from './seeders/leaderboard.seeder';
import { DailyMissionsSeeder } from './seeders/daily-missions.seeder';

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule);

  try {
    console.log(' Starting database seeding...');

    // Get all seeders
    const userSeeder = app.get(UserSeeder);
    const dailyMissionsSeeder = app.get(DailyMissionsSeeder);
    const leaderboardSeeder = app.get(LeaderboardSeeder);

    // Seed users first
    console.log('\n Seeding users...');
    const users = await userSeeder.seed();
    console.log(' Users seeded successfully');

    // Seed daily missions before leaderboard
    console.log('\n Seeding daily missions...');
    try {
      const dailyMissionsResult = await dailyMissionsSeeder.seed();
      if (dailyMissionsResult) {
        const { colors, missions } = dailyMissionsResult;
        console.log('\nColors created:', colors.map(c => ({ name: c.name, id: c._id.toString() })));
        console.log('\nMissions created:', missions.map(m => ({ title: m.title, id: m._id.toString() })));
        console.log(' Daily missions seeded successfully');
      } else {
        console.error(' Daily missions seeding failed - no result returned');
      }
    } catch (error) {
      console.error(' Error seeding daily missions:', error);
      throw error;
    }

    // Seed leaderboard data
    console.log('\n Seeding leaderboards...');
    try {
      const leaderboardResult = await leaderboardSeeder.seed(users);
      console.log('Leaderboard created:', JSON.stringify(leaderboardResult, null, 2));
      console.log(' Leaderboards seeded successfully');
    } catch (error) {
      console.error(' Error seeding leaderboards:', error);
      throw error;
    }

    // Verify the seeded data
    console.log('\n Verifying seeded data...');
    try {
      const verifyResult = await dailyMissionsSeeder.seed();
      console.log('Verification complete:', {
        colorsCount: verifyResult.colors.length,
        missionsCount: verifyResult.missions.length
      });
    } catch (error) {
      console.error(' Error verifying seeded data:', error);
      throw error;
    }

    console.log('\n Database seeding completed successfully!');
  } catch (error) {
    console.error('\n Database seeding failed:', error);
    throw error;
  } finally {
    await app.close();
  }
}

bootstrap();

================
File: src/database/seeders.meta
================
fileFormatVersion: 2
guid: 2b76374ec380e40628f6000ff6d0e785
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/interfaces/email-metrics.interface.ts
================
export interface EmailMetrics {
  totalSent: number;
  totalFailed: number;
  averageDeliveryTime: number;
  queueLength?: number;
  lastError?: {
    timestamp: Date;
    error: string;
  };
}

export interface QueueMetrics {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
  processingTime: {
    avg: number;
    min: number;
    max: number;
  };
}

export interface EmailHealthStatus {
  status: 'up' | 'down';
  details: {
    mailer: boolean;
    queue?: boolean;
    lastCheck: Date;
    error?: string;
  };
}

================
File: src/email/interfaces/email-metrics.interface.ts.meta
================
fileFormatVersion: 2
guid: f317e86f37c964dd88a336d9d64b8830
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/achievement-unlocked.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Achievement Unlocked! </title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .achievement {
            background-color: #ffd700;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        .achievement-icon {
            font-size: 48px;
            margin: 10px 0;
        }
        .reward {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Congratulations, {{name}}! </h2>
    
    <div class="achievement">
        <div class="achievement-icon"></div>
        <h3>{{achievementName}}</h3>
        <p>{{achievementDescription}}</p>
    </div>
    
    <div class="reward">
        <h4>Your Rewards:</h4>
        <p>{{rewardDescription}}</p>
        <p>Points Earned: {{points}}</p>
    </div>
    
    <p>Keep up the great work! Want to see your other achievements?</p>
    <a href="{{profileUrl}}" class="button">View Your Profile</a>
    
    <p>Share your achievement:</p>
    <p>
        <a href="{{shareTwitterUrl}}">Twitter</a> |
        <a href="{{shareFacebookUrl}}">Facebook</a> |
        <a href="{{shareInstagramUrl}}">Instagram</a>
    </p>
    
    <div class="footer">
        <p>You received this email because you achieved something awesome in Naira Raid!</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/achievement-unlocked.hbs.meta
================
fileFormatVersion: 2
guid: b16b26dd2181d437dbfeb0f64e27e26f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/reset-password.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Reset Your Password</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #f44336;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Password Reset Request</h2>
    <p>Hello {{name}},</p>
    <p>We received a request to reset your password. Click the button below to create a new password:</p>
    
    <a href="{{resetUrl}}" class="button">Reset Password</a>
    
    <p>Or copy and paste this link in your browser:</p>
    <p>{{resetUrl}}</p>
    
    <p>This password reset link will expire in 1 hour.</p>
    
    <p>If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
    
    <div class="footer">
        <p>This is an automated email, please do not reply.</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/reset-password.hbs.meta
================
fileFormatVersion: 2
guid: 6ff0e0f05a14242319b2570160ee4706
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/verify-email.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Verify Your Email</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Welcome to Naira Raid!</h2>
    <p>Hello {{name}},</p>
    <p>Thank you for registering with Naira Raid. Please verify your email address by clicking the button below:</p>
    
    <a href="{{verificationUrl}}" class="button">Verify Email</a>
    
    <p>Or copy and paste this link in your browser:</p>
    <p>{{verificationUrl}}</p>
    
    <p>This verification link will expire in 24 hours.</p>
    
    <p>If you didn't create an account with Naira Raid, please ignore this email.</p>
    
    <div class="footer">
        <p>This is an automated email, please do not reply.</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/verify-email.hbs.meta
================
fileFormatVersion: 2
guid: e51343393e8c4414380f0880822b7725
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/welcome.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Welcome to Naira Raid!</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .features {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .feature-item {
            margin: 10px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Welcome to Naira Raid! </h2>
    <p>Hello {{name}},</p>
    <p>Thank you for verifying your email! We're excited to have you join our gaming community.</p>
    
    <div class="features">
        <h3>Here's what you can do now:</h3>
        <div class="feature-item"> Complete daily missions to earn rewards</div>
        <div class="feature-item"> Compete in leaderboards</div>
        <div class="feature-item"> Collect and use power-ups</div>
        <div class="feature-item"> Track your progress and achievements</div>
    </div>
    
    <p>Ready to start playing?</p>
    <a href="{{gameUrl}}" class="button">Start Playing Now</a>
    
    <p>Need help getting started? Check out our:</p>
    <ul>
        <li><a href="{{tutorialUrl}}">Game Tutorial</a></li>
        <li><a href="{{faqUrl}}">Frequently Asked Questions</a></li>
        <li><a href="{{supportUrl}}">Support Center</a></li>
    </ul>
    
    <div class="footer">
        <p>Follow us on social media:</p>
        <p>
            <a href="{{instagramUrl}}">Instagram</a> |
            <a href="{{tiktokUrl}}">TikTok</a>
        </p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/welcome.hbs.meta
================
fileFormatVersion: 2
guid: ae0be8f49b4d34a239925c094a5db1da
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.controller.ts
================
import { Controller, Get, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { EmailService } from './email.service';
import { EmailHealthIndicator } from './email.health';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { EmailMetrics, QueueMetrics, EmailHealthStatus } from './interfaces/email-metrics.interface';

@ApiTags('email-monitoring')
@Controller('email/monitoring')
@UseGuards(JwtAuthGuard)
export class EmailMonitoringController {
  constructor(
    private readonly emailService: EmailService,
    private readonly healthIndicator: EmailHealthIndicator,
  ) {}

  @Get('metrics')
  @ApiOperation({ summary: 'Get email metrics' })
  @ApiResponse({
    status: 200,
    description: 'Returns email sending metrics',
    type: 'object',
  })
  async getMetrics(): Promise<EmailMetrics> {
    return this.emailService.getMetrics();
  }

  @Get('queue')
  @ApiOperation({ summary: 'Get queue metrics' })
  @ApiResponse({
    status: 200,
    description: 'Returns queue metrics if queue is enabled, null otherwise',
    type: 'object',
  })
  async getQueueMetrics(): Promise<QueueMetrics | null> {
    return this.emailService.getQueueMetrics();
  }

  @Get('health')
  @ApiOperation({ summary: 'Get email service health status' })
  @ApiResponse({
    status: 200,
    description: 'Returns health status of email service components',
    type: 'object',
  })
  async getHealth(): Promise<EmailHealthStatus> {
    return this.healthIndicator.check();
  }
}

================
File: src/email/email.controller.ts.meta
================
fileFormatVersion: 2
guid: 6bc095fc54c4a4f39b89c7554f88fc94
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.health.ts
================
import { Injectable } from '@nestjs/common';
import { EmailService } from './email.service';
import { EmailHealthStatus } from './interfaces/email-metrics.interface';

@Injectable()
export class EmailHealthIndicator {
  private lastStatus: EmailHealthStatus = {
    status: 'up',
    details: {
      mailer: true,
      lastCheck: new Date(),
    },
  };

  constructor(private readonly emailService: EmailService) {}

  async check(): Promise<EmailHealthStatus> {
    try {
      const health = await this.emailService.checkHealth();
      this.lastStatus = {
        status: health.mailer ? 'up' : 'down',
        details: {
          ...health,
          lastCheck: new Date(),
        },
      };
    } catch (error) {
      this.lastStatus = {
        status: 'down',
        details: {
          mailer: false,
          lastCheck: new Date(),
          error: error.message,
        },
      };
    }

    return this.lastStatus;
  }

  getLastStatus(): EmailHealthStatus {
    return this.lastStatus;
  }
}

================
File: src/email/email.health.ts.meta
================
fileFormatVersion: 2
guid: 2a4b8b19bb9c34fce8a9473a0ad7555f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.module.ts
================
import { Module, DynamicModule } from '@nestjs/common';
import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { BullModule } from '@nestjs/bull';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { join } from 'path';
import { EmailService } from './email.service';
import { EmailProcessor } from './email.processor';
import { EmailHealthIndicator } from './email.health';
import { EmailMonitoringController } from './email.controller';

@Module({})
export class EmailModule {
  static register(): DynamicModule {
    return {
      module: EmailModule,
      imports: [
        ConfigModule,
        MailerModule.forRootAsync({
          imports: [ConfigModule],
          useFactory: async (configService: ConfigService) => ({
            transport: {
              host: configService.get('SMTP_HOST'),
              port: configService.get('SMTP_PORT'),
              secure: configService.get('SMTP_SECURE', false),
              auth: {
                user: configService.get('SMTP_USER'),
                pass: configService.get('SMTP_PASSWORD'),
              },
            },
            defaults: {
              from: `"Naira Raid" <${configService.get('SMTP_FROM')}>`,
            },
            template: {
              dir: join(__dirname, 'templates'),
              adapter: new HandlebarsAdapter(),
              options: {
                strict: true,
              },
            },
          }),
          inject: [ConfigService],
        }),
        ...this.getQueueImports(),
      ],
      providers: [
        EmailService,
        EmailHealthIndicator,
        ...(process.env.USE_EMAIL_QUEUE === 'true' ? [EmailProcessor] : []),
      ],
      controllers: [EmailMonitoringController],
      exports: [EmailService, EmailHealthIndicator],
    };
  }

  private static getQueueImports(): DynamicModule[] {
    if (process.env.USE_EMAIL_QUEUE !== 'true') {
      return [];
    }

    return [
      BullModule.forRootAsync({
        imports: [ConfigModule],
        useFactory: async (configService: ConfigService) => ({
          redis: {
            host: configService.get('REDIS_HOST', 'localhost'),
            port: configService.get('REDIS_PORT', 6379),
            password: configService.get('REDIS_PASSWORD'),
          },
        }),
        inject: [ConfigService],
      }),
      BullModule.registerQueue({
        name: 'email',
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 1000,
          },
          removeOnComplete: true,
        },
      }),
    ];
  }
}

================
File: src/email/email.module.ts.meta
================
fileFormatVersion: 2
guid: 0daa6cd946141461bbffe1b0f107151c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.processor.ts
================
import { Process, Processor } from '@nestjs/bull';
import { Logger } from '@nestjs/common';
import { Job } from 'bull';
import { MailerService } from '@nestjs-modules/mailer';

interface EmailJob {
  to: string;
  subject: string;
  template: string;
  context: Record<string, any>;
}

@Processor('email')
export class EmailProcessor {
  private readonly logger = new Logger(EmailProcessor.name);

  constructor(private readonly mailerService: MailerService) {}

  @Process('send')
  async handleSendEmail(job: Job<EmailJob>) {
    this.logger.debug(`Processing email job ${job.id}`);
    const { to, subject, template, context } = job.data;

    try {
      await this.mailerService.sendMail({
        to,
        subject,
        template,
        context: {
          ...context,
          year: new Date().getFullYear(),
        },
      });
      this.logger.debug(`Email job ${job.id} completed successfully`);
    } catch (error) {
      this.logger.error(`Failed to process email job ${job.id}`, error.stack);
      throw error;
    }
  }
}

================
File: src/email/email.processor.ts.meta
================
fileFormatVersion: 2
guid: 24e56fe08da2b491080c082b96fde3f3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.service.ts
================
import { Injectable, Logger, OnModuleInit, Optional } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { MailerService } from '@nestjs-modules/mailer';
import { UserDocument } from '../user/schemas/user.schema';
import { EmailMetrics, QueueMetrics } from './interfaces/email-metrics.interface';

@Injectable()
export class EmailService implements OnModuleInit {
  private readonly logger = new Logger(EmailService.name);
  private useQueue: boolean;
  private queueAvailable: boolean = false;
  private metrics: EmailMetrics = {
    totalSent: 0,
    totalFailed: 0,
    averageDeliveryTime: 0,
  };
  private deliveryTimes: number[] = [];

  constructor(
    @Optional() @InjectQueue('email') private readonly emailQueue: Queue,
    private readonly mailerService: MailerService,
    private readonly configService: ConfigService,
  ) {
    this.useQueue = this.configService.get<boolean>('USE_EMAIL_QUEUE', false);
  }

  async onModuleInit() {
    await this.validateConfiguration();
    if (this.useQueue) {
      await this.checkQueueAvailability();
    }
  }

  private async validateConfiguration() {
    const requiredConfigs = [
      'SMTP_HOST',
      'SMTP_PORT',
      'SMTP_USER',
      'SMTP_PASSWORD',
      'SMTP_FROM',
      'BASE_URL',
    ];

    const missingConfigs = requiredConfigs.filter(
      config => !this.configService.get(config),
    );

    if (missingConfigs.length > 0) {
      throw new Error(
        `Missing required email configurations: ${missingConfigs.join(', ')}`,
      );
    }

    if (this.useQueue) {
      const requiredRedisConfigs = ['REDIS_HOST', 'REDIS_PORT'];
      const missingRedisConfigs = requiredRedisConfigs.filter(
        config => !this.configService.get(config),
      );

      if (missingRedisConfigs.length > 0) {
        throw new Error(
          `Queue is enabled but missing Redis configurations: ${missingRedisConfigs.join(
            ', ',
          )}`,
        );
      }
    }
  }

  private async checkQueueAvailability() {
    try {
      await this.emailQueue.isReady();
      this.queueAvailable = true;
      this.logger.log('Email queue is available and connected');
    } catch (error) {
      this.queueAvailable = false;
      this.logger.warn(
        'Email queue is not available, falling back to direct email sending',
        error.stack,
      );
    }
  }

  private getBaseUrl(): string {
    return this.configService.get<string>('BASE_URL') || 'http://localhost:3000';
  }

  private getSocialUrls() {
    const baseUrl = this.getBaseUrl();
    return {
      instagramUrl: this.configService.get<string>('INSTAGRAM_URL') || 'https://instagram.com/nairaraid',
      tiktokUrl: this.configService.get<string>('TIKTOK_URL') || 'https://tiktok.com/@nairaraid',
      tutorialUrl: `${baseUrl}/tutorial`,
      faqUrl: `${baseUrl}/faq`,
      supportUrl: `${baseUrl}/support`,
      gameUrl: `${baseUrl}/play`,
    };
  }

  async getMetrics(): Promise<EmailMetrics> {
    const metrics = { ...this.metrics };
    if (this.useQueue && this.queueAvailable) {
      metrics.queueLength = await this.emailQueue.count();
    }
    return metrics;
  }

  async getQueueMetrics(): Promise<QueueMetrics | null> {
    if (!this.useQueue || !this.queueAvailable) {
      return null;
    }

    const [waiting, active, completed, failed, delayed] = await Promise.all([
      this.emailQueue.getWaitingCount(),
      this.emailQueue.getActiveCount(),
      this.emailQueue.getCompletedCount(),
      this.emailQueue.getFailedCount(),
      this.emailQueue.getDelayedCount(),
    ]);

    const jobs = await this.emailQueue.getJobs(['completed']);
    const processingTimes = jobs.map(job => job.processedOn! - job.timestamp);

    return {
      waiting,
      active,
      completed,
      failed,
      delayed,
      processingTime: {
        avg: this.calculateAverage(processingTimes),
        min: Math.min(...processingTimes),
        max: Math.max(...processingTimes),
      },
    };
  }

  async checkHealth(): Promise<{ mailer: boolean; queue?: boolean }> {
    const health = {
      mailer: await this.checkMailerHealth(),
    };

    if (this.useQueue) {
      health['queue'] = await this.checkQueueHealth();
    }

    return health;
  }

  private async checkMailerHealth(): Promise<boolean> {
    try {
      // Check if required SMTP configuration is available
      const requiredConfigs = [
        'SMTP_HOST',
        'SMTP_PORT',
        'SMTP_USER',
        'SMTP_PASSWORD',
        'SMTP_FROM'
      ];

      const missingConfigs = requiredConfigs.filter(
        config => !this.configService.get(config),
      );

      if (missingConfigs.length > 0) {
        throw new Error(`Missing SMTP configurations: ${missingConfigs.join(', ')}`);
      }

      return true;
    } catch (error) {
      this.logger.error('Mailer health check failed', error.stack);
      return false;
    }
  }

  private async checkQueueHealth(): Promise<boolean> {
    try {
      await this.emailQueue.isReady();
      return true;
    } catch (error) {
      this.logger.error('Queue health check failed', error.stack);
      return false;
    }
  }

  private calculateAverage(numbers: number[]): number {
    if (numbers.length === 0) return 0;
    return numbers.reduce((a, b) => a + b, 0) / numbers.length;
  }

  private async updateMetrics(startTime: number, success: boolean): Promise<void> {
    if (success) {
      this.metrics.totalSent++;
      const deliveryTime = Date.now() - startTime;
      this.deliveryTimes.push(deliveryTime);
      
      // Keep only last 100 delivery times for average calculation
      if (this.deliveryTimes.length > 100) {
        this.deliveryTimes.shift();
      }
      
      this.metrics.averageDeliveryTime = this.calculateAverage(this.deliveryTimes);
    } else {
      this.metrics.totalFailed++;
    }
  }

  private async sendEmail(options: {
    to: string;
    subject: string;
    template: string;
    context: Record<string, any>;
  }): Promise<void> {
    const startTime = Date.now();
    const emailData = {
      ...options,
      context: {
        ...options.context,
        year: new Date().getFullYear(),
      },
    };

    try {
      if (this.useQueue && this.queueAvailable) {
        await this.emailQueue.add('send', emailData);
        this.logger.debug(`Email queued successfully to: ${options.to}`);
      } else {
        await this.mailerService.sendMail(emailData);
        this.logger.debug(`Email sent directly to: ${options.to}`);
      }
      await this.updateMetrics(startTime, true);
    } catch (error) {
      await this.updateMetrics(startTime, false);
      this.metrics.lastError = {
        timestamp: new Date(),
        error: error.message,
      };
      this.logger.error(
        `Failed to send email to ${options.to}`,
        error.stack,
      );
      throw error;
    }
  }

  async sendVerificationEmail(user: UserDocument, token: string): Promise<void> {
    const verificationUrl = `${this.getBaseUrl()}/auth/verify-email?token=${token}`;

    await this.sendEmail({
      to: user.email,
      subject: 'Verify your email address',
      template: 'verify-email',
      context: {
        name: user.firstName,
        verificationUrl,
      },
    });
  }

  async sendPasswordResetEmail(user: UserDocument, token: string): Promise<void> {
    const resetUrl = `${this.getBaseUrl()}/auth/reset-password?token=${token}`;

    await this.sendEmail({
      to: user.email,
      subject: 'Reset your password',
      template: 'reset-password',
      context: {
        name: user.firstName,
        resetUrl,
      },
    });
  }

  async sendWelcomeEmail(user: UserDocument): Promise<void> {
    await this.sendEmail({
      to: user.email,
      subject: 'Welcome to Naira Raid! ',
      template: 'welcome',
      context: {
        name: user.firstName,
        ...this.getSocialUrls(),
      },
    });
  }

  async sendAchievementEmail(
    user: UserDocument,
    achievement: {
      name: string;
      description: string;
      reward: string;
      points: number;
    },
  ): Promise<void> {
    const baseUrl = this.getBaseUrl();
    const profileUrl = `${baseUrl}/profile/${user._id}`;
    const achievementId = achievement.name.toLowerCase().replace(/\s+/g, '-');

    await this.sendEmail({
      to: user.email,
      subject: `Achievement Unlocked: ${achievement.name} `,
      template: 'achievement-unlocked',
      context: {
        name: user.firstName,
        achievementName: achievement.name,
        achievementDescription: achievement.description,
        rewardDescription: achievement.reward,
        points: achievement.points,
        profileUrl,
        shareTwitterUrl: `https://twitter.com/intent/tweet?text=I just unlocked ${achievement.name} in Naira Raid!&url=${baseUrl}/achievements/${achievementId}`,
        shareFacebookUrl: `https://www.facebook.com/sharer/sharer.php?u=${baseUrl}/achievements/${achievementId}`,
        shareInstagramUrl: `${baseUrl}/achievements/${achievementId}`,
      },
    });
  }
}

================
File: src/email/email.service.ts.meta
================
fileFormatVersion: 2
guid: f6576934b8d3640cdacd5bd2388d038c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/interfaces.meta
================
fileFormatVersion: 2
guid: dc5cb58df8d79476da4d2604d51eb7ff
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates.meta
================
fileFormatVersion: 2
guid: 2127ee099514a41ed967b5574c169df3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto/create-inventory-item.dto.ts
================
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { GameType } from '../../common/types/game.types';

export class CreateInventoryItemDto {
  @IsString()
    name: string;

  @IsString()
    description: string;

  @IsEnum(GameType)
    gameId: string;

  @IsString()
    type: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
    duration?: number;

  @IsOptional()
  @IsNumber()
  @Min(0)
    power?: number;
}

================
File: src/inventory/dto/create-inventory-item.dto.ts.meta
================
fileFormatVersion: 2
guid: f071d2ac4da734bd9b3d37c1fd97d3ab
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto/create-user-inventory.dto.ts
================
import {
  IsDate,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

export class CreateUserInventoryDto {
  @IsString()
    itemId: string;

  @IsNumber()
  @Min(1)
    quantity: number;

  @IsEnum(GameType)
    gameId: string;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
    expiresAt?: Date;
}

================
File: src/inventory/dto/create-user-inventory.dto.ts.meta
================
fileFormatVersion: 2
guid: 02d492e08e9064aedbafaf4986870cd0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas/inventory-item.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type InventoryItemDocument = InventoryItem & Document;

@Schema({ timestamps: true })
export class InventoryItem {
  _id: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true })
  type: string; // e.g., 'power-up', 'weapon', 'currency'

  @Prop()
  duration?: number; // Duration in seconds if applicable

  @Prop()
  power?: number; // Power/strength if applicable

  @Prop({ default: true })
  isActive: boolean;
}

export const InventoryItemSchema = SchemaFactory.createForClass(InventoryItem);

================
File: src/inventory/schemas/inventory-item.schema.ts.meta
================
fileFormatVersion: 2
guid: 087731dc9cb234966b5da59ab45a4834
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas/user-inventory.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';
import { InventoryItem } from './inventory-item.schema';

export type UserInventoryDocument = UserInventory & Document;

@Schema({ timestamps: true })
export class UserInventory {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: InventoryItem.name, required: true })
  itemId: Types.ObjectId | InventoryItem;

  @Prop({ required: true })
  quantity: number;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop()
  expiresAt?: Date;
}

export const UserInventorySchema = SchemaFactory.createForClass(UserInventory);

// Create compound index for unique item per user per game
UserInventorySchema.index({ userId: 1, itemId: 1, gameId: 1 }, { unique: true });

================
File: src/inventory/schemas/user-inventory.schema.ts.meta
================
fileFormatVersion: 2
guid: 118b6c43b9bc64463ae25c383e6c0ada
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto.meta
================
fileFormatVersion: 2
guid: 2c1597886a9f44d26b604ca185b19d98
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryController } from './inventory.controller';

describe('InventoryController', () => {
  let controller: InventoryController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InventoryController],
    }).compile();

    controller = module.get<InventoryController>(InventoryController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/inventory/inventory.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 7d16e9fc98f0441c091b992e274805d4
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { CreateInventoryItemDto } from './dto/create-inventory-item.dto';
import { CreateUserInventoryDto } from './dto/create-user-inventory.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @UseGuards(JwtAuthGuard)
  @Post('items')
  createItem(@Body() createInventoryItemDto: CreateInventoryItemDto) {
    return this.inventoryService.createItem(createInventoryItemDto);
  }

  @Get('items/:gameId')
  findAllItems(
    @Param('gameId') gameId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.inventoryService.findAllItems(gameId, paginationDto);
  }

  @Get('items/detail/:id')
  findItemById(@Param('id') id: string) {
    return this.inventoryService.findItemById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('items/:id')
  updateItem(
    @Param('id') id: string,
    @Body() updateData: Partial<CreateInventoryItemDto>,
  ) {
    return this.inventoryService.updateItem(id, updateData);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('items/:id')
  deleteItem(@Param('id') id: string) {
    return this.inventoryService.deleteItem(id);
  }

  @UseGuards(JwtAuthGuard)
  @Post('user')
  addToUserInventory(
    @Request() req,
    @Body() createUserInventoryDto: CreateUserInventoryDto,
  ) {
    return this.inventoryService.addToUserInventory(
      req.user.userId,
      createUserInventoryDto,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Get('user/:gameId')
  getUserInventory(
    @Request() req,
    @Param('gameId') gameId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.inventoryService.getUserInventory(
      req.user.userId,
      gameId,
      paginationDto,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Post('user/use/:itemId')
  useInventoryItem(
    @Request() req,
    @Param('itemId') itemId: string,
    @Body('quantity') quantity?: number,
  ) {
    return this.inventoryService.useInventoryItem(
      req.user.userId,
      itemId,
      quantity,
    );
  }
}

================
File: src/inventory/inventory.controller.ts.meta
================
fileFormatVersion: 2
guid: 9cefe20e4ef624e95b1984d96efdbfaa
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { InventoryService } from './inventory.service';
import { InventoryController } from './inventory.controller';
import {
  InventoryItem,
  InventoryItemSchema,
} from './schemas/inventory-item.schema';
import {
  UserInventory,
  UserInventorySchema,
} from './schemas/user-inventory.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: InventoryItem.name, schema: InventoryItemSchema },
      { name: UserInventory.name, schema: UserInventorySchema },
    ]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService],
  exports: [InventoryService],
})
export class InventoryModule {}

================
File: src/inventory/inventory.module.ts.meta
================
fileFormatVersion: 2
guid: 0ffdf00569f104ed2b5a8346cec75875
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryService } from './inventory.service';

describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [InventoryService],
    }).compile();

    service = module.get<InventoryService>(InventoryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/inventory/inventory.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 154b3c8280fd542168ed9468980422ab
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.service.ts
================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  InventoryItem,
  InventoryItemDocument,
} from './schemas/inventory-item.schema';
import {
  UserInventory,
  UserInventoryDocument,
} from './schemas/user-inventory.schema';
import { CreateInventoryItemDto } from './dto/create-inventory-item.dto';
import { CreateUserInventoryDto } from './dto/create-user-inventory.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class InventoryService {
  constructor(
    @InjectModel(InventoryItem.name)
    private readonly inventoryItemModel: Model<InventoryItemDocument>,
    @InjectModel(UserInventory.name)
    private readonly userInventoryModel: Model<UserInventoryDocument>,
  ) {}

  async createItem(
    createInventoryItemDto: CreateInventoryItemDto,
  ): Promise<InventoryItemDocument> {
    const item = new this.inventoryItemModel(createInventoryItemDto);
    return item.save();
  }

  async findAllItems(gameId: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      this.inventoryItemModel
        .find({ gameId, isActive: true })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.inventoryItemModel.countDocuments({ gameId, isActive: true }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findItemById(id: string): Promise<InventoryItemDocument> {
    const item = await this.inventoryItemModel.findById(id);
    if (!item) {
      throw new NotFoundException('Inventory item not found');
    }
    return item;
  }

  async updateItem(
    id: string,
    updateData: Partial<CreateInventoryItemDto>,
  ): Promise<InventoryItemDocument> {
    const item = await this.inventoryItemModel.findByIdAndUpdate(
      id,
      updateData,
      {
        new: true,
      },
    );
    if (!item) {
      throw new NotFoundException('Inventory item not found');
    }
    return item;
  }

  async deleteItem(id: string): Promise<void> {
    const result = await this.inventoryItemModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Inventory item not found');
    }
  }

  async addToUserInventory(
    userId: string,
    createUserInventoryDto: CreateUserInventoryDto,
  ): Promise<UserInventoryDocument> {
    const item = await this.findItemById(createUserInventoryDto.itemId);
    if (!item.isActive) {
      throw new BadRequestException('This item is no longer available');
    }

    const existingInventory = await this.userInventoryModel.findOne({
      userId,
      itemId: createUserInventoryDto.itemId,
      gameId: createUserInventoryDto.gameId,
    });

    if (existingInventory) {
      existingInventory.quantity += createUserInventoryDto.quantity;
      if (createUserInventoryDto.expiresAt) {
        existingInventory.expiresAt = createUserInventoryDto.expiresAt;
      }
      return existingInventory.save();
    }

    const userInventory = new this.userInventoryModel({
      userId,
      ...createUserInventoryDto,
    });
    return userInventory.save();
  }

  async getUserInventory(
    userId: string,
    gameId: string,
    paginationDto: PaginationDto,
  ) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      this.userInventoryModel
        .find({
          userId,
          gameId,
          $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
        })
        .populate('itemId')
        .skip(skip)
        .limit(limit)
        .exec(),
      this.userInventoryModel.countDocuments({
        userId,
        gameId,
        $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
      }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async useInventoryItem(
    userId: string,
    itemId: string,
    quantity = 1,
  ): Promise<UserInventoryDocument> {
    const userInventory = await this.userInventoryModel
      .findOne({
        userId,
        itemId,
        $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
      })
      .populate('itemId');

    if (!userInventory) {
      throw new NotFoundException('Item not found in user inventory');
    }

    if (userInventory.quantity < quantity) {
      throw new BadRequestException('Insufficient quantity');
    }

    userInventory.quantity -= quantity;

    if (userInventory.quantity === 0) {
      await userInventory.deleteOne();
      return null;
    }

    return userInventory.save();
  }
}

================
File: src/inventory/inventory.service.ts.meta
================
fileFormatVersion: 2
guid: 92a13350b6dc642d9acaa63c523747c5
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas.meta
================
fileFormatVersion: 2
guid: 54ff6e3c374dc42e9ae096ae4cd35abf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-game-session.dto.ts
================
import { IsEnum, IsNumber, IsObject, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

// Record of colorId -> number of kills
class ColorKillsDto {
  [key: string]: number;
}

class GameStatsDto {
  @IsNumber()
  @Min(0)
  totalKills: number;

  @IsNumber()
  @Min(0)
  cashCollected: number;

  @IsObject()
  colorKills: ColorKillsDto;
}

export class CreateGameSessionDto {
  @IsEnum(GameType)
  gameId: string;

  @IsNumber()
  @Min(0)
  score: number;

  @ValidateNested()
  @Type(() => GameStatsDto)
  @IsObject()
  gameStats: GameStatsDto;
}

================
File: src/leaderboard/dto/create-game-session.dto.ts.meta
================
fileFormatVersion: 2
guid: 98170b60634254913a765deffc4d1d65
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-leaderboard-entry.dto.ts
================
import { IsEnum, IsNumber, IsObject, IsOptional, Min } from 'class-validator';
import { GameType } from '../../common/types/game.types';

export class CreateLeaderboardEntryDto {
  @IsNumber()
  @Min(0)
  score: number;

  @IsNumber()
  @Min(0)
  @IsOptional()
  extraPoints?: number;

  @IsNumber()
  @Min(1)
  seasonNumber: number;

  @IsEnum(GameType)
  gameId: string;

  @IsObject()
  gameStats: {
    totalKills?: number;
    cashCollected?: number;
  };
}

================
File: src/leaderboard/dto/create-leaderboard-entry.dto.ts.meta
================
fileFormatVersion: 2
guid: 64d427310842741789c7a4b7f14ee156
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-leaderboard.dto.ts
================
import { IsDate, IsEnum, IsNumber, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

export class CreateLeaderboardDto {
  @IsNumber()
  @Min(1)
  seasonNumber: number;

  @Type(() => Date)
  @IsDate()
  seasonStart: Date;

  @Type(() => Date)
  @IsDate()
  seasonEnd: Date;

  @IsEnum(GameType)
  gameId: string;
}

================
File: src/leaderboard/dto/create-leaderboard.dto.ts.meta
================
fileFormatVersion: 2
guid: a5d83126aa4f2421da954f1eb466236c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/game-session.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

export type GameSessionDocument = GameSession & Document;

@Schema({ timestamps: true })
export class GameSession {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true })
  score: number;

  @Prop({ type: Object, required: true })
  gameStats: {
    totalKills: number;
    cashCollected: number;
    colorKills: { [colorId: string]: number };
  };

  @Prop({ default: true })
  isCompleted: boolean;
}

export const GameSessionSchema = SchemaFactory.createForClass(GameSession);

================
File: src/leaderboard/schemas/game-session.schema.ts.meta
================
fileFormatVersion: 2
guid: d9fa05f7d6123475aaede0092bc342cb
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/leaderboard-entry.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { Leaderboard } from './leaderboard.schema';
import { GameType } from '../../common/types/game.types';

export type LeaderboardEntryDocument = LeaderboardEntry & Document;

@Schema({ timestamps: true })
export class LeaderboardEntry {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'Leaderboard', required: true })
  leaderboardId: Leaderboard;

  @Prop({ required: true })
  score: number;

  @Prop({ default: 0 })
  extraPoints: number;

  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ type: Object })
  gameStats: {
    totalKills?: number;
    cashCollected?: number;
  };
}

export const LeaderboardEntrySchema = SchemaFactory.createForClass(LeaderboardEntry);

// Create compound index for unique entries per user per leaderboard
LeaderboardEntrySchema.index({ userId: 1, leaderboardId: 1 }, { unique: true });

================
File: src/leaderboard/schemas/leaderboard-entry.schema.ts.meta
================
fileFormatVersion: 2
guid: acc6dfe0b86444395afe196db610b623
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/leaderboard.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type LeaderboardDocument = Leaderboard & Document;

@Schema({ timestamps: true })
export class Leaderboard {
  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true })
  seasonStart: Date;

  @Prop({ required: true })
  seasonEnd: Date;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ default: true })
  isActive: boolean;
}

export const LeaderboardSchema = SchemaFactory.createForClass(Leaderboard);

================
File: src/leaderboard/schemas/leaderboard.schema.ts.meta
================
fileFormatVersion: 2
guid: bfb39edd798e2422790f667ce6052c5b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto.meta
================
fileFormatVersion: 2
guid: a3881637009d84c91ab8ae08f04e49a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { LeaderboardController } from './leaderboard.controller';

describe('LeaderboardController', () => {
  let controller: LeaderboardController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [LeaderboardController],
    }).compile();

    controller = module.get<LeaderboardController>(LeaderboardController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/leaderboard/leaderboard.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 0bfc5ba95cad94c4f8389299e410ce1c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  DefaultValuePipe,
  ParseIntPipe,
  BadRequestException,
} from '@nestjs/common';
import { LeaderboardService } from './leaderboard.service';
import { CreateLeaderboardDto } from './dto/create-leaderboard.dto';
import { CreateGameSessionDto } from './dto/create-game-session.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiOperation, ApiQuery, ApiResponse, ApiTags } from '@nestjs/swagger';

@ApiTags('leaderboard')
@Controller('leaderboard')
export class LeaderboardController {
  constructor(private readonly leaderboardService: LeaderboardService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  createLeaderboard(@Body() createLeaderboardDto: CreateLeaderboardDto) {
    return this.leaderboardService.createLeaderboard(createLeaderboardDto);
  }

  @Get('current/:gameId')
  getCurrentLeaderboard(@Param('gameId') gameId: string) {
    return this.leaderboardService.getCurrentLeaderboard(gameId);
  }

  @Get('top')
  @ApiOperation({ summary: 'Get top players from the current leaderboard' })
  @ApiQuery({ name: 'gameId', required: true, description: 'Game identifier' })
  @ApiQuery({ name: 'limit', required: false, description: 'Number of players to return (default: 10)' })
  @ApiResponse({
    status: 200,
    description: 'Returns the top players with their position, username, and score',
  })
  getTopPlayers(
    @Query('gameId') gameId: string,
    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number,
  ) {
    if (!gameId) {
      throw new BadRequestException('gameId is required');
    }
    
    return this.leaderboardService.getTopPlayers(gameId, limit);
  }

  @Get(':leaderboardId/entries')
  getLeaderboardEntries(
    @Param('leaderboardId') leaderboardId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.leaderboardService.getLeaderboardEntries(leaderboardId, paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Post('game-session')
  createGameSession(
    @Request() req,
    @Body() createGameSessionDto: CreateGameSessionDto,
  ) {
    return this.leaderboardService.createGameSession(req.user.userId, createGameSessionDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('player-stats/:gameId')
  getPlayerStats(@Request() req, @Param('gameId') gameId: string) {
    return this.leaderboardService.getPlayerStats(req.user.userId, gameId);
  }
}

================
File: src/leaderboard/leaderboard.controller.ts.meta
================
fileFormatVersion: 2
guid: e90109f122656465aa99ae8d480db37a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { LeaderboardService } from './leaderboard.service';
import { LeaderboardController } from './leaderboard.controller';
import { Leaderboard, LeaderboardSchema } from './schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from './schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from './schemas/game-session.schema';
import { DailyMissionsModule } from '../daily-missions/daily-missions.module';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => DailyMissionsModule),
    MongooseModule.forFeature([
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
    ]),
  ],
  controllers: [LeaderboardController],
  providers: [LeaderboardService],
  exports: [LeaderboardService],
})
export class LeaderboardModule {}

================
File: src/leaderboard/leaderboard.module.ts.meta
================
fileFormatVersion: 2
guid: 73b9be81a58b84d818dcbcb327b80ebe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { LeaderboardService } from './leaderboard.service';

describe('LeaderboardService', () => {
  let service: LeaderboardService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [LeaderboardService],
    }).compile();

    service = module.get<LeaderboardService>(LeaderboardService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/leaderboard/leaderboard.service.spec.ts.meta
================
fileFormatVersion: 2
guid: e569a7696b4a54ee688f60363d4ab54d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.service.ts
================
/* eslint-disable max-len */
import { Injectable, NotFoundException, BadRequestException, Inject, forwardRef } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Leaderboard, LeaderboardDocument } from './schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntryDocument } from './schemas/leaderboard-entry.schema';
import { GameSession, GameSessionDocument } from './schemas/game-session.schema';
import { CreateLeaderboardDto } from './dto/create-leaderboard.dto';
import { CreateLeaderboardEntryDto } from './dto/create-leaderboard-entry.dto';
import { CreateGameSessionDto } from './dto/create-game-session.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { DailyMissionsService } from '../daily-missions/services/daily-missions.service';

@Injectable()
export class LeaderboardService {
  constructor(
    @InjectModel(Leaderboard.name)
    private readonly leaderboardModel: Model<LeaderboardDocument>,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
    @InjectModel(GameSession.name)
    private readonly gameSessionModel: Model<GameSessionDocument>,
    @Inject(forwardRef(() => DailyMissionsService))
    private readonly dailyMissionsService: DailyMissionsService,
  ) {}

  async createLeaderboard(createLeaderboardDto: CreateLeaderboardDto): Promise<LeaderboardDocument> {
    const leaderboard = new this.leaderboardModel(createLeaderboardDto);
    return leaderboard.save();
  }

  async getCurrentLeaderboard(gameId: string): Promise<LeaderboardDocument> {
    const leaderboard = await this.leaderboardModel.findOne({
      gameId,
      isActive: true,
      seasonStart: { $lte: new Date() },
      seasonEnd: { $gte: new Date() },
    });

    if (!leaderboard) {
      throw new NotFoundException('No active leaderboard found for this game');
    }

    return leaderboard;
  }

  async getLeaderboardEntries(
    leaderboardId: string,
    paginationDto: PaginationDto,
  ) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    // First aggregate to calculate total scores
    const entries = await this.leaderboardEntryModel
      .aggregate([
        { 
          $match: { 
            leaderboardId: Types.ObjectId.createFromHexString(leaderboardId) 
          } 
        },
        {
          $addFields: {
            totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
          }
        },
        { $sort: { totalScore: -1 } },
        { $skip: skip },
        { $limit: limit },
        {
          $lookup: {
            from: 'users',
            localField: 'userId',
            foreignField: '_id',
            as: 'user'
          }
        },
        { $unwind: '$user' },
        {
          $project: {
            'user.password': 0
          }
        }
      ]);

    const total = await this.leaderboardEntryModel.countDocuments({ leaderboardId });

    return {
      entries,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async createGameSession(userId: string, createGameSessionDto: CreateGameSessionDto): Promise<{
    session: GameSessionDocument;
    position: number;
  }> {
    // Create a new game session
    const session = new this.gameSessionModel({
      userId,
      ...createGameSessionDto,
      isCompleted: true,
    });
    await session.save();

    // Get current leaderboard
    const currentLeaderboard = await this.getCurrentLeaderboard(String(session.gameId));
    
    // Update leaderboard entry if score is higher
    const updatedEntry = await this.updateLeaderboardEntry(String(session.userId), currentLeaderboard._id.toString(), {
      score: session.score,
      gameId: String(session.gameId), 
      seasonNumber: currentLeaderboard.seasonNumber,
      gameStats: session.gameStats,
    });

    // Calculate position using aggregation
    const higherScores = await this.leaderboardEntryModel
      .aggregate([
        {
          $match: {
            leaderboardId: Types.ObjectId.createFromHexString(currentLeaderboard._id.toString())
          }
        },
        {
          $addFields: {
            totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
          }
        },
        {
          $match: {
            totalScore: { $gt: updatedEntry.score + (updatedEntry.extraPoints || 0) }
          }
        },
        {
          $count: 'count'
        }
      ])
      .then(result => (result[0]?.count || 0));

    // Update mission progress
    await this.dailyMissionsService.updateMissionProgress(
      userId,
      String(session.gameId),
      session._id.toString(),
      {
        kills: session.gameStats.totalKills,
        colorKills: session.gameStats.colorKills || {},
      }
    );

    return {
      session,
      position: higherScores + 1
    };
  }

  private async updateLeaderboardEntry(
    userId: string,
    leaderboardId: string | Types.ObjectId,
    data: CreateLeaderboardEntryDto,
  ): Promise<LeaderboardEntryDocument> {
    const existingEntry = await this.leaderboardEntryModel.findOne({
      userId,
      leaderboardId,
    });

    if (!existingEntry) {
      const entry = new this.leaderboardEntryModel({
        userId,
        leaderboardId,
        ...data,
      });
      return entry.save();
    }

    // Only update if new score is higher
    if (data.score > existingEntry.score) {
      existingEntry.score = data.score;
      existingEntry.gameStats = data.gameStats;
      return existingEntry.save();
    }

    return existingEntry;
  }

  /**
   * calculateTotalKills
   * ------------------
   * Calculate total kills across all game sessions for a player
   */
  async calculateTotalKills(userId, gameId) {
    const result = await this.gameSessionModel.aggregate([
      { $match: { userId, gameId, isCompleted: true } },
      { $group: { _id: null, total: { $sum: '$gameStats.totalKills' } } },
    ]);
    return result.length > 0 ? result[0].total : 0;
  }

  /**
   * calculateTotalCash
   * -----------------
   * Calculate total cash collected across all game sessions
   */
  async calculateTotalCash(userId, gameId) {
    const result = await this.gameSessionModel.aggregate([
      { $match: { userId, gameId, isCompleted: true } },
      { $group: { _id: null, total: { $sum: '$gameStats.cashCollected' } } },
    ]);
    return result.length > 0 ? result[0].total : 0;
  }

  /**
   * calculateXP
   * -----------
   * Calculate player's total XP based on lifetime kills
   * XP formula: kills * 10
   */
  private calculateXP(totalKills: number): number {
    return totalKills * 10; // Each kill gives 10 XP
  }

  /**
   * calculateLevel
   * -------------
   * Calculate player's current season level based on kills
   * Level formula: 1 + floor(kills / 100)
   * Every 100 kills = 1 level up, starting from level 1
   */
  private calculateLevel(seasonKills: number): number {
    return 1 + Math.floor(seasonKills / 100); // Every 100 kills = 1 level
  }

  /**
   * getSeasonKills
   * -------------
   * Get total kills for a player in the current season
   */
  private async getSeasonKills(userId: string, leaderboardId: string | Types.ObjectId): Promise<number> {
    const entry = await this.leaderboardEntryModel.findOne({
      userId: new Types.ObjectId(userId),
      leaderboardId: typeof leaderboardId === 'string' ? new Types.ObjectId(leaderboardId) : leaderboardId,
    });

    return entry?.gameStats?.totalKills || 0;
  }

  /**
   * Get player stats for an event
   */
  async getPlayerStats(userId: string, gameId: string) {
    const currentLeaderboard = await this.getCurrentLeaderboard(gameId);
    const entry = await this.leaderboardEntryModel
      .findOne({
        userId,
        leaderboardId: currentLeaderboard._id,
      })
      .populate('userId', '-password');

    // Calculate player rank using aggregation
    const rankResult = await this.leaderboardEntryModel
      .aggregate([
        {
          $match: {
            leaderboardId: Types.ObjectId.createFromHexString(currentLeaderboard._id.toString())
          }
        },
        {
          $addFields: {
            totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
          }
        },
        {
          $sort: { totalScore: -1 }
        },
        {
          $group: {
            _id: null,
            entries: {
              $push: {
                userId: '$userId',
                totalScore: '$totalScore'
              }
            }
          }
        },
        {
          $project: {
            rank: {
              $add: [
                {
                  $indexOfArray: [
                    '$entries.userId',
                    Types.ObjectId.createFromHexString(userId)
                  ]
                },
                1
              ]
            }
          }
        }
      ]);

    const playerRank = rankResult[0]?.rank || 0;

    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);

    const todayEnd = new Date();
    todayEnd.setHours(23, 59, 59, 999);

    const todayGames = await this.gameSessionModel
      .find({
        userId,
        gameId,
        createdAt: { $gte: todayStart, $lte: todayEnd },
        isCompleted: true,
      })
      .sort({ score: -1 });

    // Calculate stats
    const totalKills = await this.calculateTotalKills(userId, gameId);
    const seasonKills = await this.getSeasonKills(
      userId, 
      currentLeaderboard._id.toString()
    );

    const xp = this.calculateXP(totalKills);
    const level = this.calculateLevel(seasonKills);

    return {
      currentSeasonBest: {
        ...entry?.toObject(),
        totalScore: entry ? entry.score + (entry.extraPoints || 0) : 0
      },
      allTimeHighScore: entry ? entry.score + (entry.extraPoints || 0) : 0,
      playerRank,
      todayGames,
      todayBestScore: todayGames[0]?.score || 0,
      gamesPlayedToday: todayGames.length,
      totalGamesPlayed: await this.gameSessionModel.countDocuments({ userId, gameId, isCompleted: true }),
      totalKills,
      totalCashCollected: await this.calculateTotalCash(userId, gameId),
      progression: {
        xp,
        level,
        seasonKills,
        lifetimeKills: totalKills,
        killsToNextLevel: 100 - (seasonKills % 100),
      }
    };
  }

  async getTopPlayers(gameId: string, limit: number = 10) {
    try {
      const currentLeaderboard = await this.getCurrentLeaderboard(gameId);
      
      // Use aggregation to get top players with total score
      const topEntries = await this.leaderboardEntryModel
        .aggregate([
          {
            $match: {
              leaderboardId: Types.ObjectId.createFromHexString(currentLeaderboard._id.toString())
            }
          },
          {
            $addFields: {
              totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
            }
          },
          {
            $sort: { totalScore: -1 }
          },
          {
            $limit: limit
          },
          {
            $lookup: {
              from: 'users',
              localField: 'userId',
              foreignField: '_id',
              as: 'user'
            }
          },
          {
            $unwind: '$user'
          },
          {
            $project: {
              _id: 1,
              totalScore: 1,
              'user.username': 1
            }
          }
        ]);
      
      if (!topEntries || topEntries.length === 0) {
        return {
          gameId,
          leaderboardId: currentLeaderboard._id,
          seasonNumber: currentLeaderboard.seasonNumber,
          entries: [],
        };
      }
      
      const formattedEntries = topEntries.map((entry, index) => ({
        position: index + 1,
        username: entry.user.username || 'Unknown Player',
        score: entry.totalScore,
      }));
      
      return {
        gameId,
        leaderboardId: currentLeaderboard._id,
        seasonNumber: currentLeaderboard.seasonNumber,
        entries: formattedEntries,
      };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      
      console.error('Error fetching top players:', error);
      throw new BadRequestException('Could not retrieve leaderboard data');
    }
  }
}

================
File: src/leaderboard/leaderboard.service.ts.meta
================
fileFormatVersion: 2
guid: d86e1616d2db5491eb48f2477a276c87
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas.meta
================
fileFormatVersion: 2
guid: 0ae86c7a9db0a4d988fbb67e0df585a0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto/create-player-progress.dto.ts
================
import { IsEnum, IsMongoId, IsNotEmpty, IsNumber, Min } from 'class-validator';
import { GameType } from '../../common/types/game.types';
import { Types } from 'mongoose';

export class CreatePlayerProgressDto {
  @IsNotEmpty()
  @IsMongoId()
  userId: Types.ObjectId;

  @IsNotEmpty()
  @IsEnum(GameType)
  gameId: string;

  @IsNotEmpty()
  @IsNumber()
  @Min(1)
  level: number = 1;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  experience: number = 0;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  experienceToNextLevel: number = 1000; // Default value for level 1

  rank: {
    current: string;
    history: { rank: string; achievedAt: Date }[];
  } = {
    current: 'Rookie',
    history: [{ rank: 'Rookie', achievedAt: new Date() }],
  };

  unlocks: {
    items: Types.ObjectId[];
    achievements: Types.ObjectId[];
    powerUps: Types.ObjectId[];
  } = {
    items: [],
    achievements: [],
    powerUps: [],
  };
}

================
File: src/player-progress/dto/create-player-progress.dto.ts.meta
================
fileFormatVersion: 2
guid: bf77b53ce5cff4915be5aa00ecc6424b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto/update-player-progress.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Types } from 'mongoose';

export class UpdatePlayerProgressDto {
  @IsOptional()
  @IsNumber()
  @Min(0)
  experienceGained?: number;

  @IsOptional()
  unlockedItems?: Types.ObjectId[];

  @IsOptional()
  unlockedAchievements?: Types.ObjectId[];

  @IsOptional()
  unlockedPowerUps?: Types.ObjectId[];
}

================
File: src/player-progress/dto/update-player-progress.dto.ts.meta
================
fileFormatVersion: 2
guid: 91caae7e94a6e4040834d67e2aeadaef
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/schemas/player-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type PlayerProgressDocument = PlayerProgress & Document;

@Schema()
class RankHistory {
  @Prop({ required: true })
  rank: string;

  @Prop({ required: true })
  achievedAt: Date;
}

@Schema()
class Unlocks {
  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  items: Types.ObjectId[];

  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  achievements: Types.ObjectId[];

  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  powerUps: Types.ObjectId[];
}

@Schema({ timestamps: true })
export class PlayerProgress {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true, min: 1 })
  level: number;

  @Prop({ required: true, min: 0 })
  experience: number;

  @Prop({ required: true })
  experienceToNextLevel: number;

  @Prop({
    type: {
      current: { type: String, required: true },
      history: { type: [{ rank: String, achievedAt: Date }], default: [] }
    },
    required: true,
  })
  rank: {
    current: string;
    history: RankHistory[];
  };

  @Prop({ type: () => Unlocks, default: {} })
  unlocks: Unlocks;
}

export const PlayerProgressSchema = SchemaFactory.createForClass(PlayerProgress);

// Create compound index for unique progress per user per game
PlayerProgressSchema.index({ userId: 1, gameId: 1 }, { unique: true });

================
File: src/player-progress/schemas/player-progress.schema.ts.meta
================
fileFormatVersion: 2
guid: d9249f3c5cc1a458bb41b9a14054e829
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto.meta
================
fileFormatVersion: 2
guid: 99be4c58e909e4f988bb205fe09ff327
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Put,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam } from '@nestjs/swagger';
import { Types } from 'mongoose';
import { PlayerProgressService } from './player-progress.service';
import { CreatePlayerProgressDto } from './dto/create-player-progress.dto';
import { UpdatePlayerProgressDto } from './dto/update-player-progress.dto';
import { PlayerProgress } from './schemas/player-progress.schema';

@ApiTags('player-progress')
@Controller('player-progress')
export class PlayerProgressController {
  constructor(private readonly playerProgressService: PlayerProgressService) {}

  @Post()
  @ApiOperation({ summary: 'Create new player progress' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'The player progress has been successfully created.',
    type: PlayerProgress,
  })
  create(@Body() createPlayerProgressDto: CreatePlayerProgressDto) {
    return this.playerProgressService.create(createPlayerProgressDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all player progress records' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns all player progress records',
    type: [PlayerProgress],
  })
  findAll() {
    return this.playerProgressService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get player progress by ID' })
  @ApiParam({ name: 'id', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns the player progress record',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  findOne(@Param('id') id: string) {
    return this.playerProgressService.findOne(new Types.ObjectId(id));
  }

  @Get('user/:userId/game/:gameId')
  @ApiOperation({ summary: 'Get player progress by user ID and game ID' })
  @ApiParam({ name: 'userId', type: String })
  @ApiParam({ name: 'gameId', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns the player progress record',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  findByUserAndGame(
    @Param('userId') userId: string,
    @Param('gameId') gameId: string,
  ) {
    return this.playerProgressService.findByUserAndGame(
      new Types.ObjectId(userId),
      gameId,
    );
  }

  @Put('user/:userId/game/:gameId')
  @ApiOperation({ summary: 'Update player progress' })
  @ApiParam({ name: 'userId', type: String })
  @ApiParam({ name: 'gameId', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The player progress has been successfully updated.',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  update(
    @Param('userId') userId: string,
    @Param('gameId') gameId: string,
    @Body() updatePlayerProgressDto: UpdatePlayerProgressDto,
  ) {
    return this.playerProgressService.updateProgress(
      new Types.ObjectId(userId),
      gameId,
      updatePlayerProgressDto,
    );
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete player progress' })
  @ApiParam({ name: 'id', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The player progress has been successfully deleted.',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  remove(@Param('id') id: string) {
    return this.playerProgressService.remove(new Types.ObjectId(id));
  }
}

================
File: src/player-progress/player-progress.controller.ts.meta
================
fileFormatVersion: 2
guid: bdbe8223e034647129f39e24b12576c0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { PlayerProgressService } from './player-progress.service';
import { PlayerProgressController } from './player-progress.controller';
import { PlayerProgress, PlayerProgressSchema } from './schemas/player-progress.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: PlayerProgress.name, schema: PlayerProgressSchema },
    ]),
  ],
  controllers: [PlayerProgressController],
  providers: [PlayerProgressService],
  exports: [PlayerProgressService],
})
export class PlayerProgressModule {}

================
File: src/player-progress/player-progress.module.ts.meta
================
fileFormatVersion: 2
guid: 321afff1fbbb049a59a59c53373d0ae6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { PlayerProgress, PlayerProgressDocument } from './schemas/player-progress.schema';
import { CreatePlayerProgressDto } from './dto/create-player-progress.dto';
import { UpdatePlayerProgressDto } from './dto/update-player-progress.dto';

@Injectable()
export class PlayerProgressService {
  constructor(
    @InjectModel(PlayerProgress.name)
    private readonly playerProgressModel: Model<PlayerProgressDocument>,
  ) {}

  async create(createPlayerProgressDto: CreatePlayerProgressDto): Promise<PlayerProgress> {
    const createdProgress = new this.playerProgressModel(createPlayerProgressDto);
    return createdProgress.save();
  }

  async findAll(): Promise<PlayerProgress[]> {
    return this.playerProgressModel.find().exec();
  }

  async findOne(id: Types.ObjectId): Promise<PlayerProgress> {
    const progress = await this.playerProgressModel.findById(id).exec();
    if (!progress) {
      throw new NotFoundException(`Player progress with ID ${id} not found`);
    }
    return progress;
  }

  async findByUserAndGame(userId: Types.ObjectId, gameId: string): Promise<PlayerProgress> {
    const progress = await this.playerProgressModel
      .findOne({ userId, gameId })
      .exec();
    if (!progress) {
      throw new NotFoundException(`Progress not found for user ${userId} in game ${gameId}`);
    }
    return progress;
  }

  private calculateExperienceForNextLevel(currentLevel: number): number {
    // Experience required for next level increases by 20% each level
    return Math.floor(1000 * Math.pow(1.2, currentLevel - 1));
  }

  private determineRank(level: number): string {
    if (level >= 50) return 'Legend';
    if (level >= 40) return 'Master';
    if (level >= 30) return 'Expert';
    if (level >= 20) return 'Veteran';
    if (level >= 10) return 'Advanced';
    if (level >= 5) return 'Intermediate';
    return 'Rookie';
  }

  async updateProgress(
    userId: Types.ObjectId,
    gameId: string,
    updateDto: UpdatePlayerProgressDto,
  ): Promise<PlayerProgress> {
    const progress = await this.findByUserAndGame(userId, gameId) as PlayerProgressDocument;
    
    if (updateDto.experienceGained) {
      progress.experience += updateDto.experienceGained;
      
      // Level up logic
      while (progress.experience >= progress.experienceToNextLevel) {
        progress.experience -= progress.experienceToNextLevel;
        progress.level += 1;
        progress.experienceToNextLevel = this.calculateExperienceForNextLevel(progress.level);
        
        // Check for rank change
        const newRank = this.determineRank(progress.level);
        if (newRank !== progress.rank.current) {
          progress.rank.current = newRank;
          progress.rank.history.push({
            rank: newRank,
            achievedAt: new Date(),
          });
        }
      }
    }

    // Update unlocks
    if (updateDto.unlockedItems) {
      progress.unlocks.items.push(...updateDto.unlockedItems);
    }
    if (updateDto.unlockedAchievements) {
      progress.unlocks.achievements.push(...updateDto.unlockedAchievements);
    }
    if (updateDto.unlockedPowerUps) {
      progress.unlocks.powerUps.push(...updateDto.unlockedPowerUps);
    }

    return progress.save();
  }

  async remove(id: Types.ObjectId): Promise<PlayerProgress> {
    const deletedProgress = await this.playerProgressModel
      .findByIdAndDelete(id)
      .exec();
    if (!deletedProgress) {
      throw new NotFoundException(`Player progress with ID ${id} not found`);
    }
    return deletedProgress;
  }
}

================
File: src/player-progress/player-progress.service.ts.meta
================
fileFormatVersion: 2
guid: 41839e7aa62054091ad9108d81a822c9
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/schemas.meta
================
fileFormatVersion: 2
guid: 8809ae8696655420eaa1ac9235cf5d5c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto/create-user.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString, MinLength, IsOptional, IsBoolean } from 'class-validator';

export class CreateUserDto {
  @ApiProperty({
    description: 'User\'s first name',
    example: 'John',
  })
  @IsNotEmpty()
  @IsString()
  firstName: string;

  @ApiProperty({
    description: 'User\'s last name',
    example: 'Doe',
    required: false,
  })
  @IsOptional()
  @IsString()
  lastName?: string;

  @ApiProperty({
    description: 'User\'s unique username',
    example: 'johndoe123',
  })
  @IsNotEmpty()
  @IsString()
  username: string;

  @ApiProperty({
    description: 'User\'s email address',
    example: 'john.doe@example.com',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @ApiProperty({
    description: 'User\'s phone number',
    example: '+1234567890',
    required: false,
  })
  @IsOptional()
  @IsString()
  phoneNumber?: string;

  @ApiProperty({
    description: 'User\'s password (minimum 8 characters)',
    example: 'securePassword123',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  password: string;

  @ApiProperty({
    description: 'Whether the user\'s email is verified',
    example: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isEmailVerified?: boolean = false;

  @ApiProperty({
    description: 'User\'s Instagram handle',
    example: '@johndoe',
    required: false,
  })
  @IsOptional()
  @IsString()
  instagram?: string;

  @ApiProperty({
    description: 'User\'s TikTok handle',
    example: '@johndoe',
    required: false,
  })
  @IsOptional()
  @IsString()
  tiktok?: string;
}

================
File: src/user/dto/create-user.dto.ts.meta
================
fileFormatVersion: 2
guid: e669338af4d1c4bce9e240b78553f869
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto/update-user.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString, MinLength } from 'class-validator';

export class UpdateUserDto {
  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  username?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  @MinLength(8)
  password?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  isEmailVerified?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  instagram?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  tiktok?: string;
}

================
File: src/user/dto/update-user.dto.ts.meta
================
fileFormatVersion: 2
guid: 476c5e65ed366404a8660f052105bd26
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/schemas/user.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type UserDocument = User & Document;

@Schema({ timestamps: true })
export class User {
  _id: Types.ObjectId;

  @Prop({ required: true })
  firstName: string;

  @Prop()
  lastName?: string;

  @Prop({ required: true, unique: true })
  username: string;

  @Prop({ required: true, unique: true })
  email: string;

  @Prop()
  phoneNumber?: string;

  @Prop({ required: true })
  password: string;

  @Prop({ default: false })
  isEmailVerified: boolean;

  @Prop({ unique: true, sparse: true })
  instagram?: string;

  @Prop({ unique: true, sparse: true })
  tiktok?: string;

  @Prop({ default: 0 })
  points: number;
}

export const UserSchema = SchemaFactory.createForClass(User);

================
File: src/user/schemas/user.schema.ts.meta
================
fileFormatVersion: 2
guid: 58b754f15916447e6bf6bc76a3f15b6a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto.meta
================
fileFormatVersion: 2
guid: 2020fc2e5f507496a8ead989b0e59a2b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/schemas.meta
================
fileFormatVersion: 2
guid: 83ef1d1717731417085620f5eb75f6b6
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/user/user.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 18d3a0fcc5015424ab06c3c2330f7f25
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  findAll(@Query() paginationDto: PaginationDto) {
    return this.userService.findAll(paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-email/:email')
  findByEmail(@Param('email') email: string) {
    return this.userService.findByEmail(email);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-username/:username')
  findByUsername(@Param('username') username: string) {
    return this.userService.findByUsername(username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-instagram/:instagram')
  findByInstagram(@Param('instagram') instagram: string) {
    return this.userService.findByInstagram(instagram);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-tiktok/:tiktok')
  findByTiktok(@Param('tiktok') tiktok: string) {
    return this.userService.findByTiktok(tiktok);
  }

  @UseGuards(JwtAuthGuard)
  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(id, updateUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }
}

================
File: src/user/user.controller.ts.meta
================
fileFormatVersion: 2
guid: ffa964cf89c784330a74a957fe915852
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { UserService } from './user.service';
import { UserController } from './user.controller';
import { User, UserSchema } from './schemas/user.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}

================
File: src/user/user.module.ts.meta
================
fileFormatVersion: 2
guid: b8fbb0eb536164ea5a6808afd81e9057
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserService],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/user/user.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 2c0c31d2dfba34f0cb4ecb86b14e8990
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.service.ts
================
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<UserDocument> {
    try {
      const user = new this.userModel(createUserDto);
      return await user.save();
    } catch (error) {
      if (error.code === 11000) {
        throw new ConflictException('User with this email or username already exists');
      }
      throw error;
    }
  }

  async findAll(paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      this.userModel
        .find()
        .select('-password')
        .skip(skip)
        .limit(limit)
        .exec(),
      this.userModel.countDocuments(),
    ]);

    return {
      users,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<UserDocument> {
    const user = await this.userModel.findById(id).select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async findByEmail(email: string): Promise<UserDocument> {
    return this.userModel.findOne({ email });
  }

  async findByUsername(username: string): Promise<UserDocument> {
    return this.userModel.findOne({ username });
  }

  async findByInstagram(instagram: string): Promise<UserDocument> {
    return this.userModel.findOne({ instagram });
  }

  async findByTiktok(tiktok: string): Promise<UserDocument> {
    return this.userModel.findOne({ tiktok });
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<UserDocument> {
    try {
      const user = await this.userModel
        .findByIdAndUpdate(id, updateUserDto, { new: true })
        .select('-password');

      if (!user) {
        throw new NotFoundException('User not found');
      }

      return user;
    } catch (error) {
      if (error.code === 11000) {
        throw new ConflictException('Username or email already exists');
      }
      throw error;
    }
  }

  async remove(id: string): Promise<void> {
    const result = await this.userModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('User not found');
    }
  }
}

================
File: src/user/user.service.ts.meta
================
fileFormatVersion: 2
guid: 7a3443df197db49c6bb9d1455b3d03fe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 50dffc16c43354434b04108d669faf54
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.controller.ts.meta
================
fileFormatVersion: 2
guid: a5e13fdbc6f8f482b90cfd96b1b1cea6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './user/user.module';
import { AuthModule } from './auth/auth.module';
import { LeaderboardModule } from './leaderboard/leaderboard.module';
import { InventoryModule } from './inventory/inventory.module';
import { DailyMissionsModule } from './daily-missions/daily-missions.module';
import { PlayerProgressModule } from './player-progress/player-progress.module';
import { EmailModule } from './email/email.module';
import { BattleRoyaleModule } from './battle-royale/battle-royale.module';
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
      cache: true,
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const uri = configService.get<string>('MONGODB_URI');
        return {
          uri: uri + '/test',
        useNewUrlParser: true,
        useUnifiedTopology: true,
        };
      },
      inject: [ConfigService],
    }),
    DatabaseModule,
    UserModule,
    AuthModule,
    LeaderboardModule,
    InventoryModule,
    DailyMissionsModule,
    PlayerProgressModule,
    EmailModule.register(),
    BattleRoyaleModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

================
File: src/app.module.ts.meta
================
fileFormatVersion: 2
guid: 74f84fd8938da4c88badc0d9fa3701cd
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/app.service.ts.meta
================
fileFormatVersion: 2
guid: 301ba0b2266b943f9b82fb1e2dd7e3ff
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth.meta
================
fileFormatVersion: 2
guid: f9355d8391d934dcb9e2de2ada98fc92
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common.meta
================
fileFormatVersion: 2
guid: ce0ed22922c66488887da0301cb4302a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/config.meta
================
fileFormatVersion: 2
guid: c549089747ad04b37a4bf6987e5f4ce2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions.meta
================
fileFormatVersion: 2
guid: 1d8c3c567bbe141eb861e37f8a19dd92
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database.meta
================
fileFormatVersion: 2
guid: b248e256102b94680b30b4f70c3260f2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email.meta
================
fileFormatVersion: 2
guid: dc732dcbc628c46da86279de13f68a7b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory.meta
================
fileFormatVersion: 2
guid: 273db835828334faaa8c70ce586c1496
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard.meta
================
fileFormatVersion: 2
guid: 53800c276ea8644e8a5d8133c0174aa3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable validation pipe
  app.useGlobalPipes(new ValidationPipe());

  // Configure Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('Naira Raid API')
    .setDescription('The Naira Raid game API documentation')
    .setVersion('1.0')
    .addTag('player-progress', 'Player progression system')
    .addTag('inventory', 'Inventory management')
    .addTag('daily-missions', 'Daily missions system')
    .addTag('battle-royale', 'Battle Royale mode and multiplayer')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
}
bootstrap();

================
File: src/main.ts.meta
================
fileFormatVersion: 2
guid: d931ecf329c0241c1840581715c5a6e7
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress.meta
================
fileFormatVersion: 2
guid: 9f309d0061bb746da9a752db63683d4e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user.meta
================
fileFormatVersion: 2
guid: 89e8b7fe76d97476eba25ad56612d8e2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/app.e2e-spec.ts.meta
================
fileFormatVersion: 2
guid: 781a12ab5dbd94a46b97d6b4d556848f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: test/jest-e2e.json.meta
================
fileFormatVersion: 2
guid: 0902dd474475e45bf95b9675d8c5b034
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],
    'max-len': ['warn', { code: 100, ignoreStrings: true, ignoreTemplateLiterals: true }],
    'comma-dangle': ['warn', 'always-multiline'],
    'semi': ['warn', 'always'],
    'quotes': ['warn', 'single', { avoidEscape: true }],
    'indent': 'off',
    '@typescript-eslint/indent': 'off',
    'object-curly-spacing': ['warn', 'always'],
    'array-bracket-spacing': ['warn', 'never'],
    'no-multiple-empty-lines': ['warn', { max: 1, maxEOF: 0 }],
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: backend-repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-24T22:02:14.456Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  auth/
    dto/
      login.dto.ts
      login.dto.ts.meta
      refresh-token.dto.ts
      refresh-token.dto.ts.meta
      request-password-reset.dto.ts
      request-password-reset.dto.ts.meta
      reset-password.dto.ts
      reset-password.dto.ts.meta
      verify-email.dto.ts
      verify-email.dto.ts.meta
    guards/
      jwt-auth.guard.ts
      jwt-auth.guard.ts.meta
      local-auth.guard.ts
      local-auth.guard.ts.meta
    strategies/
      jwt.strategy.ts
      jwt.strategy.ts.meta
      local.strategy.ts
      local.strategy.ts.meta
    auth.controller.spec.ts
    auth.controller.spec.ts.meta
    auth.controller.ts
    auth.controller.ts.meta
    auth.module.ts
    auth.module.ts.meta
    auth.service.spec.ts
    auth.service.spec.ts.meta
    auth.service.ts
    auth.service.ts.meta
    dto.meta
    guards.meta
    strategies.meta
  battle-royale/
    dto/
      create-event.dto.ts
      register-player.dto.ts
      update-player.dto.ts
    schemas/
      battle-royale-event.schema.ts
      battle-royale-player.schema.ts
    services/
      battle-royale.service.ts
      udp-server-later.service.ts
      udp-server-old.service.ts
      udp-server.service.ts
    battle-royale.controller.ts
    battle-royale.module.ts
  common/
    dto/
      pagination.dto.ts
      pagination.dto.ts.meta
    types/
      game.types.ts
      game.types.ts.meta
    dto.meta
    types.meta
  config/
    configuration.ts
    configuration.ts.meta
  daily-missions/
    controllers/
      daily-missions.controller.ts
    dto/
      create-daily-mission.dto.ts
      create-daily-mission.dto.ts.meta
      create-mission-definition.dto.ts
      update-mission-progress.dto.ts
    schemas/
      daily-mission.schema.ts
      daily-mission.schema.ts.meta
      enemy-color.schema.ts
      mission-definition.schema.ts
      mission-points.schema.ts
      mission-progress.schema.ts
      user-mission-progress.schema.ts
      user-mission-progress.schema.ts.meta
    services/
      daily-missions.service.ts
    daily-missions.controller.spec.ts
    daily-missions.controller.spec.ts.meta
    daily-missions.controller.ts
    daily-missions.controller.ts.meta
    daily-missions.module.ts
    daily-missions.module.ts.meta
    daily-missions.service.spec.ts
    daily-missions.service.spec.ts.meta
    daily-missions.service.ts
    daily-missions.service.ts.meta
    dto.meta
    schemas.meta
  database/
    seeders/
      daily-mission.seeder.ts
      daily-mission.seeder.ts.meta
      daily-missions.seeder.ts
      inventory.seeder.ts
      inventory.seeder.ts.meta
      leaderboard.seeder.ts
      leaderboard.seeder.ts.meta
      player-progress.seeder.ts
      player-progress.seeder.ts.meta
      seed.ts
      seed.ts.meta
      seeder.ts
      seeder.ts.meta
      user-mission-progress.seeder.ts
      user-mission-progress.seeder.ts.meta
      user.seeder.ts
      user.seeder.ts.meta
    database.module.ts
    seed.ts
    seeders.meta
  email/
    interfaces/
      email-metrics.interface.ts
      email-metrics.interface.ts.meta
    templates/
      achievement-unlocked.hbs
      achievement-unlocked.hbs.meta
      reset-password.hbs
      reset-password.hbs.meta
      verify-email.hbs
      verify-email.hbs.meta
      welcome.hbs
      welcome.hbs.meta
    email.controller.ts
    email.controller.ts.meta
    email.health.ts
    email.health.ts.meta
    email.module.ts
    email.module.ts.meta
    email.processor.ts
    email.processor.ts.meta
    email.service.ts
    email.service.ts.meta
    interfaces.meta
    templates.meta
  inventory/
    dto/
      create-inventory-item.dto.ts
      create-inventory-item.dto.ts.meta
      create-user-inventory.dto.ts
      create-user-inventory.dto.ts.meta
    schemas/
      inventory-item.schema.ts
      inventory-item.schema.ts.meta
      user-inventory.schema.ts
      user-inventory.schema.ts.meta
    dto.meta
    inventory.controller.spec.ts
    inventory.controller.spec.ts.meta
    inventory.controller.ts
    inventory.controller.ts.meta
    inventory.module.ts
    inventory.module.ts.meta
    inventory.service.spec.ts
    inventory.service.spec.ts.meta
    inventory.service.ts
    inventory.service.ts.meta
    schemas.meta
  leaderboard/
    dto/
      create-game-session.dto.ts
      create-game-session.dto.ts.meta
      create-leaderboard-entry.dto.ts
      create-leaderboard-entry.dto.ts.meta
      create-leaderboard.dto.ts
      create-leaderboard.dto.ts.meta
    schemas/
      game-session.schema.ts
      game-session.schema.ts.meta
      leaderboard-entry.schema.ts
      leaderboard-entry.schema.ts.meta
      leaderboard.schema.ts
      leaderboard.schema.ts.meta
    dto.meta
    leaderboard.controller.spec.ts
    leaderboard.controller.spec.ts.meta
    leaderboard.controller.ts
    leaderboard.controller.ts.meta
    leaderboard.module.ts
    leaderboard.module.ts.meta
    leaderboard.service.spec.ts
    leaderboard.service.spec.ts.meta
    leaderboard.service.ts
    leaderboard.service.ts.meta
    schemas.meta
  player-progress/
    dto/
      create-player-progress.dto.ts
      create-player-progress.dto.ts.meta
      update-player-progress.dto.ts
      update-player-progress.dto.ts.meta
    schemas/
      player-progress.schema.ts
      player-progress.schema.ts.meta
    dto.meta
    player-progress.controller.ts
    player-progress.controller.ts.meta
    player-progress.module.ts
    player-progress.module.ts.meta
    player-progress.service.ts
    player-progress.service.ts.meta
    schemas.meta
  user/
    dto/
      create-user.dto.ts
      create-user.dto.ts.meta
      update-user.dto.ts
      update-user.dto.ts.meta
    schemas/
      user.schema.ts
      user.schema.ts.meta
    dto.meta
    schemas.meta
    user.controller.spec.ts
    user.controller.spec.ts.meta
    user.controller.ts
    user.controller.ts.meta
    user.module.ts
    user.module.ts.meta
    user.service.spec.ts
    user.service.spec.ts.meta
    user.service.ts
    user.service.ts.meta
  app.controller.spec.ts
  app.controller.spec.ts.meta
  app.controller.ts
  app.controller.ts.meta
  app.module.ts
  app.module.ts.meta
  app.service.ts
  app.service.ts.meta
  auth.meta
  common.meta
  config.meta
  daily-missions.meta
  database.meta
  email.meta
  inventory.meta
  leaderboard.meta
  main.ts
  main.ts.meta
  player-progress.meta
  user.meta
test/
  app.e2e-spec.ts
  app.e2e-spec.ts.meta
  jest-e2e.json
  jest-e2e.json.meta
.eslintrc.js
.gitignore
.prettierrc
dist.meta
nest-cli.json
nest-cli.json.meta
node_modules.meta
package-lock.json.meta
package.json
package.json.meta
README.md
README.md.meta
src.meta
test.meta
tsconfig.build.json
tsconfig.build.json.meta
tsconfig.json
tsconfig.json.meta

================================================================
Files
================================================================

================
File: src/auth/dto/login.dto.ts
================
import { IsString, IsOptional } from 'class-validator';

export class LoginDto {
  @IsOptional()
  @IsString()
  email?: string;

  @IsOptional()
  @IsString()
  username?: string;

  @IsString()
  password: string;
}

================
File: src/auth/dto/login.dto.ts.meta
================
fileFormatVersion: 2
guid: f8dd0d6823a914dc9a6012109f71b648
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/refresh-token.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class RefreshTokenDto {
  @ApiProperty({
    description: 'Refresh token received during login',
    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  })
  @IsNotEmpty()
  @IsString()
  refreshToken: string;
}

================
File: src/auth/dto/refresh-token.dto.ts.meta
================
fileFormatVersion: 2
guid: 2a912ad6a0f73433d9ff1abf4e72812e
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/request-password-reset.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty } from 'class-validator';

export class RequestPasswordResetDto {
  @ApiProperty({
    description: 'Email address of the user requesting password reset',
    example: 'user@example.com',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;
}

================
File: src/auth/dto/request-password-reset.dto.ts.meta
================
fileFormatVersion: 2
guid: 575958243c9074e3abe37b5c5d033572
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/reset-password.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'Reset token received via email',
    example: 'abc123def456...',
  })
  @IsNotEmpty()
  @IsString()
  token: string;

  @ApiProperty({
    description: 'New password (minimum 8 characters)',
    example: 'newSecurePassword123',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  newPassword: string;
}

================
File: src/auth/dto/reset-password.dto.ts.meta
================
fileFormatVersion: 2
guid: 3322b2f4f9c104104b2fc37197c20b30
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/verify-email.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyEmailDto {
  @ApiProperty({
    description: 'Email verification token received via email',
    example: 'abc123def456...',
  })
  @IsNotEmpty()
  @IsString()
  token: string;
}

================
File: src/auth/dto/verify-email.dto.ts.meta
================
fileFormatVersion: 2
guid: 91d03aa6745fe448e9a95d58af2b2314
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards/jwt-auth.guard.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

// Define interfaces for the JWT error types
interface TokenExpiredError extends Error {
  name: string;
  message: string;
  expiredAt: Date;
}

interface JsonWebTokenError extends Error {
  name: string;
  message: string;
}

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  handleRequest(err, user, info) {
    // If there's an error or no user
    if (err || !user) {
      // TokenExpiredError is a specific error from jsonwebtoken package
      if (info instanceof Error && info.name === 'TokenExpiredError') {
        const tokenError = info as TokenExpiredError;
        throw new UnauthorizedException({
          statusCode: 401,
          message: 'Token expired',
          error: 'Unauthorized',
          expiredAt: tokenError.expiredAt,
        });
      }
      
      // JsonWebTokenError is the general JWT error class
      if (info instanceof Error && info.name === 'JsonWebTokenError') {
        throw new UnauthorizedException({
          statusCode: 401,
          message: 'Invalid token',
          error: 'Unauthorized',
        });
      }
      
      // For any other authentication error
      throw err || new UnauthorizedException({
        statusCode: 401,
        message: info?.message || 'Unauthorized access',
        error: 'Unauthorized',
      });
    }
    
    // If all is good, return the user
    return user;
  }
}

================
File: src/auth/guards/jwt-auth.guard.ts.meta
================
fileFormatVersion: 2
guid: 81dc6a6f6458948fb8091c0acd25e17b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards/local-auth.guard.ts
================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

================
File: src/auth/guards/local-auth.guard.ts.meta
================
fileFormatVersion: 2
guid: 162b22f8578d3485daa6a5f74fd77531
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies/jwt.strategy.ts
================
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined in environment variables');
    }

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}

================
File: src/auth/strategies/jwt.strategy.ts.meta
================
fileFormatVersion: 2
guid: 62fb4f63a197b44e89e5312217b30c8b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies/local.strategy.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      usernameField: 'email',
      passwordField: 'password',
    });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser({ email, password });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}

================
File: src/auth/strategies/local.strategy.ts.meta
================
fileFormatVersion: 2
guid: 98e48d19453e14d72b3033bf0148708f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/auth/auth.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: ca762a559fbb54c378b73f0e6a0fb828
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.controller.ts
================
import { Controller, Post, Body, UseGuards, Request, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBody } from '@nestjs/swagger';
import { AuthService } from './auth.service';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { CreateUserDto } from '../user/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { RequestPasswordResetDto } from './dto/request-password-reset.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { VerifyEmailDto } from './dto/verify-email.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiBody({ type: CreateUserDto })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'User has been successfully registered.',
  })
  @ApiResponse({
    status: HttpStatus.CONFLICT,
    description: 'User with this email or username already exists.',
  })
  async register(@Body() createUserDto: CreateUserDto) {
    return this.authService.register(createUserDto);
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  @ApiOperation({ summary: 'Login with email/username and password' })
  @ApiBody({ type: LoginDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'User has been successfully logged in.',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Invalid credentials.',
  })
  async login(@Request() req, @Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('request-password-reset')
  @ApiOperation({ summary: 'Request a password reset' })
  @ApiBody({ type: RequestPasswordResetDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Password reset instructions sent to email.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'No user found with this email.',
  })
  async requestPasswordReset(@Body() requestPasswordResetDto: RequestPasswordResetDto) {
    return this.authService.requestPasswordReset(requestPasswordResetDto);
  }

  @Post('reset-password')
  @ApiOperation({ summary: 'Reset password using token' })
  @ApiBody({ type: ResetPasswordDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Password has been successfully reset.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid or expired reset token.',
  })
  async resetPassword(@Body() resetPasswordDto: ResetPasswordDto) {
    return this.authService.resetPassword(resetPasswordDto);
  }

  @Post('verify-email')
  @ApiOperation({ summary: 'Verify email using token' })
  @ApiBody({ type: VerifyEmailDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Email has been successfully verified.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid or expired verification token.',
  })
  async verifyEmail(@Body() verifyEmailDto: VerifyEmailDto) {
    return this.authService.verifyEmail(verifyEmailDto);
  }

  @Post('refresh-token')
  @ApiOperation({ summary: 'Get new access token using refresh token' })
  @ApiBody({ type: RefreshTokenDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'New access token generated successfully.',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Invalid or expired refresh token.',
  })
  async refreshToken(@Body() refreshTokenDto: RefreshTokenDto) {
    return this.authService.refreshToken(refreshTokenDto);
  }
}

================
File: src/auth/auth.controller.ts.meta
================
fileFormatVersion: 2
guid: 43582518f5add403ab176a997d7543cd
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UserModule } from '../user/user.module';
import { EmailModule } from '../email/email.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';

@Module({
  imports: [
    UserModule,
    EmailModule.register(),
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

================
File: src/auth/auth.module.ts.meta
================
fileFormatVersion: 2
guid: ff0ba45392cfa41d597745905b234ccc
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/auth/auth.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 8f635c6d709d74d2cbdf3354820df03b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.service.ts
================
import { Injectable, UnauthorizedException, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';
import { EmailService } from '../email/email.service';
import { CreateUserDto } from '../user/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { RequestPasswordResetDto } from './dto/request-password-reset.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { VerifyEmailDto } from './dto/verify-email.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';
import * as bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AuthService {
  private readonly resetTokens: Map<string, { email: string; expires: Date }> = new Map();
  private readonly verificationTokens: Map<string, { email: string; expires: Date }> = new Map();
  private readonly refreshTokens: Map<string, { userId: string; expires: Date }> = new Map();

  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly emailService: EmailService,
  ) {}

  async validateUser({ email, password }: { email: string; password: string }) {
    const user = await this.userService.findByEmail(email);
    if (user && await bcrypt.compare(password, user.password)) {
      const { password: _, ...result } = user.toObject();
      return result;
    }
    return null;
  }

  async register(createUserDto: CreateUserDto) {
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    const user = await this.userService.create({
      ...createUserDto,
      password: hashedPassword,
      isEmailVerified: false,
    });

    // Generate email verification token
    const verificationToken = uuidv4();
    this.verificationTokens.set(verificationToken, {
      email: user.email,
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
    });

    // Send verification email
    await this.emailService.sendVerificationEmail(user, verificationToken);

    const { password: _, ...result } = user.toObject();
    return result;
  }

  async login(loginDto: LoginDto) {
    let user;
    if (loginDto.email) {
      user = await this.validateUser({
        email: loginDto.email,
        password: loginDto.password,
      });
    } else if (loginDto.username) {
      const userByUsername = await this.userService.findByUsername(loginDto.username);
      if (userByUsername) {
        user = await this.validateUser({
          email: userByUsername.email,
          password: loginDto.password,
        });
      }
    }

    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { email: user.email, sub: user._id };
    const accessToken = this.jwtService.sign(payload);
    const refreshToken = uuidv4();

    // Store refresh token
    this.refreshTokens.set(refreshToken, {
      userId: user._id.toString(),
      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    });

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      user,
    };
  }

  async requestPasswordReset(requestPasswordResetDto: RequestPasswordResetDto) {
    const user = await this.userService.findByEmail(requestPasswordResetDto.email);
    if (!user) {
      throw new BadRequestException('No user found with this email');
    }

    const resetToken = uuidv4();
    this.resetTokens.set(resetToken, {
      email: user.email,
      expires: new Date(Date.now() + 1 * 60 * 60 * 1000), // 1 hour
    });

    // Send password reset email
    await this.emailService.sendPasswordResetEmail(user, resetToken);

    return { message: 'Password reset instructions sent to your email' };
  }

  async resetPassword(resetPasswordDto: ResetPasswordDto) {
    const tokenData = this.resetTokens.get(resetPasswordDto.token);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new BadRequestException('Invalid or expired reset token');
    }

    const user = await this.userService.findByEmail(tokenData.email);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    const hashedPassword = await bcrypt.hash(resetPasswordDto.newPassword, 10);
    await this.userService.update(user._id.toString(), { password: hashedPassword });

    // Remove used token
    this.resetTokens.delete(resetPasswordDto.token);

    return { message: 'Password successfully reset' };
  }

  async verifyEmail(verifyEmailDto: VerifyEmailDto) {
    const tokenData = this.verificationTokens.get(verifyEmailDto.token);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new BadRequestException('Invalid or expired verification token');
    }

    const user = await this.userService.findByEmail(tokenData.email);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    await this.userService.update(user._id.toString(), { isEmailVerified: true });

    // Remove used token
    this.verificationTokens.delete(verifyEmailDto.token);

    return { message: 'Email successfully verified' };
  }

  async refreshToken(refreshTokenDto: RefreshTokenDto) {
    const tokenData = this.refreshTokens.get(refreshTokenDto.refreshToken);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new UnauthorizedException('Invalid or expired refresh token');
    }

    const user = await this.userService.findById(tokenData.userId);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    const payload = { email: user.email, sub: user._id };
    const accessToken = this.jwtService.sign(payload);
    const newRefreshToken = uuidv4();

    // Store new refresh token and remove old one
    this.refreshTokens.delete(refreshTokenDto.refreshToken);
    this.refreshTokens.set(newRefreshToken, {
      userId: user._id.toString(),
      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    });

    return {
      access_token: accessToken,
      refresh_token: newRefreshToken,
    };
  }
}

================
File: src/auth/auth.service.ts.meta
================
fileFormatVersion: 2
guid: aad8b72a81a814fbfb10554dc4346eef
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto.meta
================
fileFormatVersion: 2
guid: 3a6a1fa07a8004cb09bb44aba5484724
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards.meta
================
fileFormatVersion: 2
guid: 9f435a64ad8fe429d952f5f5b922a20d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies.meta
================
fileFormatVersion: 2
guid: 3b24cd2fbd2d949fab03ebad1fabc794
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/battle-royale/dto/create-event.dto.ts
================
import { IsArray, IsBoolean, IsDate, IsNotEmpty, IsNumber, IsOptional, IsPositive, IsString, Max, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class CreateEventDto {
  @IsNotEmpty()
  @IsString()
  title: string;

  @IsNotEmpty()
  @IsString()
  description: string;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  eventDate: Date;

  @IsNotEmpty()
  @IsString()
  startTime: string; // Format: "HH:MM" (24-hour format)

  @IsNumber()
  @Min(0)
  @IsOptional()
  entryFee: number = 0;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsPositive({ each: true })
  prizePools: number[];

  @IsBoolean()
  @IsOptional()
  isActive: boolean = false;

  @IsNumber()
  @Min(10)
  @Max(1000)
  @IsOptional()
  maxPlayers: number = 100;
}

================
File: src/battle-royale/dto/register-player.dto.ts
================
import { IsMongoId, IsNotEmpty } from 'class-validator';
import { Types } from 'mongoose';

export class RegisterPlayerDto {
  @IsNotEmpty()
  @IsMongoId()
  eventId: Types.ObjectId;
}

================
File: src/battle-royale/dto/update-player.dto.ts
================
import { IsBoolean, IsIn, IsMongoId, IsNotEmpty, IsNumber, IsObject, IsOptional, IsString, Min } from 'class-validator';
import { Types } from 'mongoose';

export class UpdatePlayerDto {
  @IsNotEmpty()
  @IsMongoId()
  eventId: Types.ObjectId;

  @IsOptional()
  @IsString()
  roomId?: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
  position?: number;

  @IsOptional()
  @IsBoolean()
  entryFeePaid?: boolean;

  @IsOptional()
  @IsIn(['registered', 'active', 'eliminated', 'winner'])
  status?: string;

  @IsOptional()
  @IsObject()
  lastPosition?: {
    x: number;
    y: number;
    z: number;
  };

  @IsOptional()
  @IsObject()
  flip?: {
    x: number;
    y: number;
    z: number;
  };

  @IsOptional()
  @IsNumber()
  rotation?: number;

  @IsOptional()
  @IsBoolean()
  isAlive?: boolean;
}

================
File: src/battle-royale/schemas/battle-royale-event.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BattleRoyaleEventDocument = BattleRoyaleEvent & Document;

@Schema({ timestamps: true })
export class BattleRoyaleEvent {
  _id: Types.ObjectId;

  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true })
  eventDate: Date;

  @Prop({ required: true })
  startTime: string; // Format: "HH:MM" in 24-hour format

  @Prop({ default: 0 })
  entryFee: number;

  @Prop({ required: true })
  prizePools: number[];

  @Prop({ default: false })
  isActive: boolean;

  @Prop({ default: 'upcoming' })
  status: string; // 'upcoming', 'active', 'completed'

  @Prop({ default: 100 })
  maxPlayers: number;

  @Prop({ default: [] })
  rooms: string[]; // List of active room IDs for this event
}

export const BattleRoyaleEventSchema = SchemaFactory.createForClass(BattleRoyaleEvent);

================
File: src/battle-royale/schemas/battle-royale-player.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BattleRoyalePlayerDocument = BattleRoyalePlayer & Document;

@Schema({ timestamps: true })
export class BattleRoyalePlayer {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true })
  username: string;

  @Prop({ type: Types.ObjectId, ref: 'BattleRoyaleEvent', required: true })
  eventId: Types.ObjectId;

  @Prop({ default: null })
  roomId: string;

  @Prop({ default: 0 })
  position: number; // 0 means still alive, 1 is winner, 2 is second place, etc.

  @Prop({ default: false })
  entryFeePaid: boolean;

  @Prop({ default: 'registered' })
  status: string; // 'registered', 'active', 'eliminated', 'winner'

  @Prop({ type: Object, default: { x: 0, y: 0, z: 0 } })
  lastPosition: {
    x: number;
    y: number;
    z: number;
  };

  @Prop({ type: Object, default: { x: 1, y: 1, z: 1 } })
  flip: {
    x: number;
    y: number;
    z: number;
  };

  @Prop({ default: 0 })
  rotation: number;

  @Prop({ default: true })
  isAlive: boolean;
}

export const BattleRoyalePlayerSchema = SchemaFactory.createForClass(BattleRoyalePlayer);

================
File: src/battle-royale/services/battle-royale.service.ts
================
/* eslint-disable max-len */
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { BattleRoyaleEvent, BattleRoyaleEventDocument } from '../schemas/battle-royale-event.schema';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';
import { CreateEventDto } from '../dto/create-event.dto';
import { RegisterPlayerDto } from '../dto/register-player.dto';
import { UpdatePlayerDto } from '../dto/update-player.dto';
import { UserService } from '../../user/user.service';

@Injectable()
export class BattleRoyaleService {
  constructor(
    @InjectModel(BattleRoyaleEvent.name)
    private readonly eventModel: Model<BattleRoyaleEventDocument>,
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
    private readonly userService: UserService,
  ) {}

  /**
   * Create a new Battle Royale event
   */
  async createEvent(createEventDto: CreateEventDto): Promise<BattleRoyaleEventDocument> {
    const event = new this.eventModel(createEventDto);
    return event.save();
  }

  /**
   * Get all events with optional filtering
   */
  async getEvents(status?: string) {
    const query: any = {};
    
    if (status) {
      query.status = status;
    }
    
    return this.eventModel.find(query).sort({ eventDate: 1, startTime: 1 }).exec();
  }

  /**
   * Get the latest upcoming event
   */
  async getLatestUpcomingEvent() {
    const now = new Date();
    
    // Find the next event that's scheduled after now
    const upcomingEvents = await this.eventModel.find({
      eventDate: { $gte: now },
      status: 'upcoming'
    })
    .sort({ eventDate: 1, startTime: 1 })
    .limit(1)
    .exec();
    
    if (upcomingEvents.length === 0) {
      throw new NotFoundException('No upcoming events found');
    }
    
    return upcomingEvents[0];
  }

  /**
   * Get a specific event by ID
   */
  async getEventById(eventId: string): Promise<BattleRoyaleEventDocument> {
    const event = await this.eventModel.findById(eventId).exec();
    
    if (!event) {
      throw new NotFoundException(`Event with ID ${eventId} not found`);
    }
    
    return event;
  }

  /**
   * Register a player for an event
   */
  async registerPlayer(userId: string, registerPlayerDto: RegisterPlayerDto): Promise<BattleRoyalePlayerDocument> {
    const event = await this.getEventById(registerPlayerDto.eventId.toString());
    
    // Check if event is still open for registration
    if (event.status !== 'upcoming') {
      throw new BadRequestException('Registration for this event is closed');
    }
    
    // Convert IDs to strings for consistent comparison
    const userIdString = userId.toString();
    const eventIdString = registerPlayerDto.eventId.toString();
    
    // Check if user is already registered
    const existingRegistration = await this.playerModel.findOne({
      userId: new Types.ObjectId(userIdString),
      eventId: new Types.ObjectId(eventIdString)
    });
    
    if (existingRegistration) {
      throw new BadRequestException('You are already registered for this event');
    }
    
    // Get user details
    const user = await this.userService.findById(userId);
    
    // Create player registration
    const playerData = {
      userId: new Types.ObjectId(userIdString),
      username: user.username,
      eventId: new Types.ObjectId(eventIdString),
      // If there's no entry fee, automatically set as paid
      entryFeePaid: event.entryFee === 0
    };
    
    const player = new this.playerModel(playerData);
    return player.save();
  }

  /**
   * Update player information
   */
  async updatePlayer(userId: string, updatePlayerDto: UpdatePlayerDto): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(updatePlayerDto.eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    if (!player) {
      throw new NotFoundException('Player registration not found');
    }
    
    // Update player fields
    Object.keys(updatePlayerDto).forEach(key => {
      if (key !== 'eventId' && updatePlayerDto[key] !== undefined) {
        player[key] = updatePlayerDto[key];
      }
    });
    
    return player.save();
  }

  /**
   * Get player status for an event
   */
  async getPlayerStatus(userId: string, eventId: string): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    // For debugging - log the query params
    console.log('Looking for player with userId:', userIdObj, 'eventId:', eventIdObj);
    
    if (!player) {
      // Check if there are any registrations for this user to help diagnose
      const allUserRegistrations = await this.playerModel.find({ userId: userIdObj });
      console.log('Found registrations for user:', allUserRegistrations.length);
      
      throw new NotFoundException('Player registration not found');
    }
    
    return player;
  }

  /**
   * Mark player's entry fee as paid
   */
  async markEntryFeePaid(userId: string, eventId: string): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    if (!player) {
      throw new NotFoundException('Player registration not found');
    }
    
    player.entryFeePaid = true;
    return player.save();
  }

  /**
   * Get all players registered for an event
   */
  async getEventPlayers(eventId: string) {
    return this.playerModel.find({ eventId }).exec();
  }

  /**
   * Get leaderboard for an event (players ordered by position)
   */
  async getEventLeaderboard(eventId: string) {
    const players = await this.playerModel.find({
      eventId,
      status: { $in: ['eliminated', 'winner'] },
      position: { $gt: 0 }
    })
    .sort({ position: 1 })
    .exec();
    
    // Players are sorted by position (1 is winner, 2 is second place, etc.)
    return players;
  }
}

================
File: src/battle-royale/services/udp-server-later.service.ts
================
/* eslint-disable prefer-const */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import * as dgram from 'dgram';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

@Injectable()
export class UdpServerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(UdpServerService.name);
  private server: dgram.Socket;
  private players: Record<string, any> = {};
  private readonly UDP_PORT = 41234;
  
  // Track last activity time for each player to handle timeouts
  private playerLastActivity: Record<string, number> = {};
  
  // How long a player can be inactive before being considered disconnected (ms)
  private readonly PLAYER_TIMEOUT = 15000; // 15 seconds
  
  // Interval for checking player timeouts (ms)
  private readonly CLEANUP_INTERVAL = 10000; // 10 seconds
  
  // Timer for cleanup
  private cleanupTimer: NodeJS.Timeout;

  constructor(
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
  ) {}

  onModuleInit() {
    this.startServer();
    
    // Start a timer to clean up disconnected players
    this.cleanupTimer = setInterval(() => this.cleanupDisconnectedPlayers(), this.CLEANUP_INTERVAL);
  }

  onModuleDestroy() {
    if (this.server) {
      this.server.close();
    }
    
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
  }

  private startServer() {
    // Create a UDP socket (IPv4)
    this.server = dgram.createSocket('udp4');

    // Configure socket for better performance with mobile clients
    // NOTE: Configure socket options AFTER binding the socket, not before
    this.server.on('listening', () => {
      try {
        // These operations should only be performed after socket is bound
        this.server.setBroadcast(false);
        this.server.setRecvBufferSize(65536); // Larger buffer for mobile clients with inconsistent networking
        this.server.setSendBufferSize(65536);
        
        const address = this.server.address();
        this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
      } catch (err) {
        this.logger.error(`Error configuring socket: ${err.message}`);
      }
    });

    // When we receive a message (datagram):
    this.server.on('message', (msg, rinfo) => {
      try {
        const data = JSON.parse(msg.toString());
        const playerId = data.playerId;

        // Always update the player's network info
        if (playerId && this.players[playerId]) {
          this.players[playerId].address = rinfo.address;
          this.players[playerId].port = rinfo.port;
        }
        
        // Update last activity time for this player
        if (playerId) {
          this.playerLastActivity[playerId] = Date.now();
        }
        
        // Handle ping messages for keeping mobile connections alive
        if (data.type === 'ping') {
          this.handlePing(data, rinfo);
          return;
        }
        
        switch (data.type) {
          case 'connect':
            this.handleConnect(data, rinfo);
            break;
          case 'move':
            this.handleMove(data, rinfo);
            break;
          case 'flip':
            this.handleFlip(data, rinfo);
            break;
          case 'rotate':
            this.handleRotate(data, rinfo);
            break;
          case 'attack':
            this.handleAttack(data, rinfo);
            break;
          case 'damage':
            this.handleDamage(data, rinfo);
            break;
          case 'death':
            this.handleDeath(data, rinfo);
            break;
          default:
            this.logger.warn('Unknown message type:', data.type);
            break;
        }
      } catch (err) {
        this.logger.error('Failed to parse incoming message:', err);
      }
    });

    // Basic error handling
    this.server.on('error', (err) => {
      this.logger.error(`Server error: ${err.stack}`);
      this.server.close();
    });

    // 'listening' event
    // this.server.on('listening', () => {
    //   const address = this.server.address();
    //   this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
    // });

    // Start listening on UDP port
    this.server.bind(this.UDP_PORT);
  }

  /**
   * Handle ping messages (keep-alive)
   */
  private handlePing(data: any, rinfo: dgram.RemoteInfo) {
    // Simply send a pong response back to the client
    this.sendMessage({
      type: 'pong',
      timestamp: data.timestamp || Date.now()
    }, rinfo.address, rinfo.port);
  }

  /**
   * Periodically check for and remove disconnected players
   */
  private cleanupDisconnectedPlayers() {
    const now = Date.now();
    let disconnectedPlayers = [];
    
    for (const [playerId, lastActivity] of Object.entries(this.playerLastActivity)) {
      if (now - lastActivity > this.PLAYER_TIMEOUT) {
        disconnectedPlayers.push(playerId);
      }
    }
    
    // Remove disconnected players
    for (const playerId of disconnectedPlayers) {
      if (this.players[playerId]) {
        const roomId = this.players[playerId].roomId;
        
        this.logger.log(`Player ${playerId} timed out and will be disconnected`);
        
        // Broadcast to other players that this player has disconnected
        this.broadcastExcept({
          type: 'death',
          playerId: playerId,
        }, playerId, roomId);
        
        // Clean up player data
        delete this.players[playerId];
        delete this.playerLastActivity[playerId];
      }
    }
  }

  /**
   * Handle a new player connecting.
   */
  private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const roomId = data.roomId || null;
    const eventId = data.eventId || null;

    // If we already know this player, skip re-adding them
    if (!this.players[playerId]) {
      this.players[playerId] = {
        address: rinfo.address,
        port: rinfo.port,
        roomId,
        eventId,
        position: { x: 0, y: 0, z: 0 },
        flip: { x: 1, y: 1, z: 1 },
        rotation: 0,
        isAlive: true,
        health: 5 // Max health
      };
      this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

      // Update the player's roomId and status in the database if eventId is provided
      if (eventId && roomId) {
        this.updatePlayerInDatabase(playerId, eventId, roomId);
      }
    }

    // const testPlayer = {
    //   playerId: '123456',
    //   position: { x: 1, y: 1, z: 1 },
    //   flip: { x: 1, y: 1, z: 1 },
    //   rotation: 0,
    //   isAlive: true,
    //   health: 5,
    //   bot:true,
    //   roomId: 'test',
    // };

    // A) Send a "connect_ack" back to this newly connected client
    // including a list of existing players so they can spawn them locally.
    const existingPlayersList = Object.entries(this.players)
      .filter(([pid, info]) => info.roomId === roomId) // Only players in the same room
      .map(([pid, info]: [string, any]) => ({
        playerId: pid,
        position: info.position,
        flip: info.flip,
        rotation: info.rotation,
        isAlive: info.isAlive,
        health: info.health,
        bot: false,
        roomId: info.roomId
      }));

    this.sendMessage({
      type: 'connect_ack',
      message: 'Welcome to the server!',
      existingPlayers: existingPlayersList, // Send both test player and real players
    }, rinfo.address, rinfo.port);

    // console.log('broadcast spawn!!! ');

    // B) Broadcast a "spawn" event to all OTHER players that a new player has joined
    this.broadcastExcept({
      type: 'spawn',
      playerId: playerId,
      position: { x: 0, y: 0, z: 0 },
      flip: { x: 1, y: 1, z: 1 },
      rotation: 0,
      isAlive: true,
      health: 5,
      bot: false,
      roomId: roomId,
    }, playerId, roomId);
  }

  /**
   * Handle a player's movement update.
   */
  private handleMove(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return; // ignore if not found or dead

    player.position = data.position;

    // console.log('moved!!! ');

    // Broadcast this movement to all other players in the same room
    this.broadcastExcept({
      type: 'move',
      playerId: playerId,
      position: data.position,
    }, playerId, player.roomId);
  }

  /**
   * Handle flipping (scaling) data.
   */
  private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.flip = data.localScale;

    // console.log('flipped!!! ');

    this.broadcastExcept({
      type: 'flip',
      playerId: playerId,
      flip: data.localScale,
    }, playerId, player.roomId);
  }

  /**
   * Handle rotation data.
   */
  private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.rotation = data.rotation;

    // console.log('rotated!!! ');

    this.broadcastExcept({
      type: 'rotate',
      playerId: playerId,
      rotation: data.rotation,
    }, playerId, player.roomId);
  }

  /**
   * Handle an attack event.
   */
  private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
    console.log('person dey shoot');
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    // console.log('attacking!!! ');

    // Broadcast to everyone except the attacker in the same room
    this.broadcastExcept({
      type: 'attack',
      playerId: playerId,
      shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
      shootDirection: data.shootDirection || { x: 0, y: 0 }
    }, playerId, player.roomId);
  }

  /**
   * Handle damage event
   */
  private handleDamage(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.health = Math.max(0, player.health - data.damage);

    if (player.health <= 0) {
      player.isAlive = false;
      
      // Update database if this is a Battle Royale event
      if (player.eventId) {
        this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
      }
    }

    // console.log('damage!!! ');

    // Broadcast damage to all players in the room
    this.broadcastExcept({
      type: 'damage',
      playerId: playerId,
      damage: data.damage,
      shooterId: data.shooterId,
      currentHealth: player.health
    }, playerId, player.roomId);
  }

  /**
   * Handle a death event.
   */
  private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    player.isAlive = false;

    // Update player position in database
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
    }

    // Broadcast to everyone except the dead player in the same room
    this.broadcastExcept({
      type: 'death',
      playerId: playerId
    }, playerId, player.roomId);
  }

  /**
   * Broadcast a message to all players in a specific room except the specified playerId.
   */
  private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null) {
    let broadcastCount = 0;
    for (const [pid, info] of Object.entries(this.players)) {
      // Skip if it's the excluded player or not in the same room
      if (pid === exceptPlayerId) continue;
      if (roomId && info.roomId !== roomId) continue;

      this.logger.debug(`Broadcasting to ${pid} at ${info.address}:${info.port}`);
      console.log(`Broadcasting to ${pid} at ${info.address}:${info.port}`);
      this.sendMessage(msgObj, info.address, info.port);
      broadcastCount++;
    }
    this.logger.log(`Broadcast message to ${broadcastCount} players in room ${roomId}`);
    console.log(`Broadcast message to ${broadcastCount} players in room ${roomId}`);
  }

  /**
   * Helper function to send a JSON message via UDP with improved error handling.
   */
  private sendMessage(dataObj: any, address: string, port: number) {
    const message = Buffer.from(JSON.stringify(dataObj));
    
    try {
      this.server.send(message, 0, message.length, port, address, (err) => {
        if (err) {
          this.logger.error('Failed to send message:', err);
        }
      });
    } catch (error) {
      this.logger.error('Error sending UDP message:', error);
    }
  }

  /**
   * Update player information in the database
   */
  private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
    try {
      // Find the player by user ID and event ID and update the room ID
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        { 
          roomId, 
          status: 'active',
          isAlive: true,
          position: 0
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} in database:`, error);
    }
  }

  /**
   * Update player death information in the database
   */
  private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
    try {
      // Find the player by user ID and event ID and update status and position
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        { 
          status: position === 1 ? 'winner' : 'eliminated',
          isAlive: false,
          position: position,
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} death in database:`, error);
    }
  }
}

================
File: src/battle-royale/services/udp-server-old.service.ts
================
/* eslint-disable max-len */
// /* eslint-disable @typescript-eslint/no-unused-vars */
// import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
// import * as dgram from 'dgram';
// import { InjectModel } from '@nestjs/mongoose';
// import { Model } from 'mongoose';
// import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

// @Injectable()
// export class UdpServerService implements OnModuleInit, OnModuleDestroy {
//   private readonly logger = new Logger(UdpServerService.name);
//   private server: dgram.Socket;
//   private players: Record<string, any> = {};
//   private readonly UDP_PORT = 41234;

//   constructor(
//     @InjectModel(BattleRoyalePlayer.name)
//     private readonly playerModel: Model<BattleRoyalePlayerDocument>,
//   ) {}

//   onModuleInit() {
//     this.startServer();
//   }

//   onModuleDestroy() {
//     if (this.server) {
//       this.server.close();
//     }
//   }

//   private startServer() {
//     // Create a UDP socket (IPv4)
//     this.server = dgram.createSocket('udp4');

//     // When we receive a message (datagram):
//     this.server.on('message', (msg, rinfo) => {
//       try {
//         const data = JSON.parse(msg.toString());
        
//         switch (data.type) {
//           case 'connect':
//             this.handleConnect(data, rinfo);
//             break;
//           case 'move':
//             this.handleMove(data, rinfo);
//             break;
//           case 'flip':
//             this.handleFlip(data, rinfo);
//             break;
//           case 'rotate':
//             this.handleRotate(data, rinfo);
//             break;
//           case 'attack':
//             this.handleAttack(data, rinfo);
//             break;
//           case 'damage':
//             this.handleDamage(data, rinfo);
//             break;
//           case 'death':
//             this.handleDeath(data, rinfo);
//             break;
//           default:
//             this.logger.warn('Unknown message type:', data.type);
//             break;
//         }
//       } catch (err) {
//         this.logger.error('Failed to parse incoming message:', err);
//       }
//     });

//     // Basic error handling
//     this.server.on('error', (err) => {
//       this.logger.error(`Server error: ${err.stack}`);
//       this.server.close();
//     });

//     // 'listening' event
//     this.server.on('listening', () => {
//       const address = this.server.address();
//       this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
//     });

//     // Start listening on UDP port
//     this.server.bind(this.UDP_PORT);
//   }

//   /**
//    * Handle a new player connecting.
//    */
//   private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const roomId = data.roomId || null;
//     const eventId = data.eventId || null;

//     // If we already know this player, skip re-adding them
//     if (!this.players[playerId]) {
//       this.players[playerId] = {
//         address: rinfo.address,
//         port: rinfo.port,
//         roomId,
//         eventId,
//         position: { x: 0, y: 0, z: 0 },
//         flip: { x: 1, y: 1, z: 1 },
//         rotation: 0,
//         isAlive: true,
//         health: 5 // Max health
//       };
//       this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

//       // Update the player's roomId and status in the database if eventId is provided
//       if (eventId && roomId) {
//         this.updatePlayerInDatabase(playerId, eventId, roomId);
//       }
//     }

//     const testPlayer = {
//       playerId: '123456',
//       position: { x: 1, y: 1, z: 1 },
//       flip: { x: 1, y: 1, z: 1 },
//       rotation: 0,
//       isAlive: true,
//       health: 5,
//       bot:true,
//       roomId: 'test',
//     };

//     // A) Send a "connect_ack" back to this newly connected client
//     // including a list of existing players so they can spawn them locally.
//     const existingPlayersList = Object.entries(this.players)
//       .filter(([pid, info]) => info.roomId === roomId) // Only players in the same room
//       .map(([pid, info]: [string, any]) => ({
//         playerId: pid,
//         position: info.position,
//         flip: info.flip,
//         rotation: info.rotation,
//         isAlive: info.isAlive,
//         health: info.health,
//         bot: false
//       }));

//     this.sendMessage({
//       type: 'connect_ack',
//       message: 'Welcome to the server!',
//       // existingPlayers: existingPlayersList,
//       existingPlayers: [testPlayer, ...existingPlayersList],
//     }, rinfo.address, rinfo.port);

//     console.log('broadcast spawn!!! ');

//     // B) Broadcast a "spawn" event to all OTHER players that a new player has joined
//     this.broadcastExcept({
//       type: 'spawn',
//       playerId: playerId,
//       position: { x: 0, y: 0, z: 0 },
//       flip: { x: 1, y: 1, z: 1 },
//       rotation: 0,
//       isAlive: true,
//       health: 5,
//       bot: false
//     }, playerId, roomId);
//   }

//   /**
//    * Handle a player's movement update.
//    */
//   private handleMove(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return; // ignore if not found or dead

//     player.position = data.position;

//     // Broadcast this movement to all other players in the same room
//     this.broadcastExcept({
//       type: 'move',
//       playerId: playerId,
//       position: data.position
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle flipping (scaling) data.
//    */
//   private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     player.flip = data.localScale;

//     this.broadcastExcept({
//       type: 'flip',
//       playerId: playerId,
//       flip: data.localScale,
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle rotation data.
//    */
//   private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     player.rotation = data.rotation;

//     this.broadcastExcept({
//       type: 'rotate',
//       playerId: playerId,
//       rotation: data.rotation,
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle an attack event.
//    */
//   private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
//     console.log('person dey shoot');
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     console.log('attacking!!! ');

//     // Broadcast to everyone except the attacker in the same room
//     this.broadcastExcept({
//       type: 'attack',
//       playerId: playerId,
//       shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
//       shootDirection: data.shootDirection || { x: 0, y: 0 }
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle damage event
//    */
//   private handleDamage(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player || !player.isAlive) return;

//     player.health = Math.max(0, player.health - data.damage);

//     if (player.health <= 0) {
//       player.isAlive = false;
      
//       // Update database if this is a Battle Royale event
//       if (player.eventId) {
//         this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
//       }
//     }

//     console.log('damage!!! ');

//     // Broadcast damage to all players in the room
//     this.broadcastExcept({
//       type: 'damage',
//       playerId: playerId,
//       damage: data.damage,
//       shooterId: data.shooterId,
//       currentHealth: player.health
//     }, playerId, player.roomId);
//   }

//   /**
//    * Handle a death event.
//    */
//   private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
//     const playerId = data.playerId;
//     const player = this.players[playerId];
//     if (!player) return;

//     player.isAlive = false;

//     // Update player position in database
//     if (player.eventId) {
//       this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
//     }

//     // Broadcast to everyone except the dead player in the same room
//     this.broadcastExcept({
//       type: 'death',
//       playerId: playerId
//     }, playerId, player.roomId);
//   }

//   /**
//    * Broadcast a message to all players in a specific room except the specified playerId.
//    */
//   private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null) {
//     for (const [pid, info] of Object.entries(this.players)) {
//       // Skip if it's the excluded player or not in the same room
//       if (pid === exceptPlayerId) continue;
//       if (roomId && info.roomId !== roomId) continue;

//       this.sendMessage(msgObj, info.address, info.port);
//     }
//   }

//   /**
//    * Helper function to send a JSON message via UDP.
//    */
//   private sendMessage(dataObj: any, address: string, port: number) {
//     const message = Buffer.from(JSON.stringify(dataObj));
//     this.server.send(message, port, address, (err) => {
//       if (err) {
//         this.logger.error('Failed to send message:', err);
//       }
//     });
//   }

//   /**
//    * Update player information in the database
//    */
//   private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
//     try {
//       // Find the player by user ID and event ID and update the room ID
//       await this.playerModel.findOneAndUpdate(
//         { userId: playerId, eventId },
//         { 
//           roomId, 
//           status: 'active',
//           isAlive: true,
//           position: 0
//         }
//       );
//     } catch (error) {
//       this.logger.error(`Failed to update player ${playerId} in database:`, error);
//     }
//   }

//   /**
//    * Update player death information in the database
//    */
//   private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
//     try {
//       // Find the player by user ID and event ID and update status and position
//       await this.playerModel.findOneAndUpdate(
//         { userId: playerId, eventId },
//         { 
//           status: position === 1 ? 'winner' : 'eliminated',
//           isAlive: false,
//           position: position,
//         }
//       );
//     } catch (error) {
//       this.logger.error(`Failed to update player ${playerId} death in database:`, error);
//     }
//   }
// }

================
File: src/battle-royale/services/udp-server.service.ts
================
/* eslint-disable prefer-const */
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import * as dgram from 'dgram';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

/**
 * UdpServerService
 * ----------------
 * A UDP-based game server handling basic multiplayer events:
 * - Players can connect, move, flip (scale), rotate, attack, take damage, and die.
 * - The server also handles periodic cleanup of inactive players.
 * - Demonstrates how to parse incoming UDP messages, broadcast updates, and maintain minimal state in memory.
 */
@Injectable()
export class UdpServerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(UdpServerService.name);
  private server: dgram.Socket;

  /**
   * players
   * -------
   * A map of playerId => player data. Stored in memory for quick lookups.
   * Example:
   *   this.players[playerId] = {
   *     address,       // from rinfo
   *     port,          // from rinfo
   *     roomId,
   *     eventId,
   *     position,      // current position
   *     flip,          // scaling
   *     rotation,      // angle
   *     isAlive,
   *     health,
   *   };
   */
  private players: Record<string, any> = {};

  /**
   * playerLastActivity
   * ------------------
   * A map of playerId => last activity timestamp (ms).
   * Used to detect timeouts / disconnections from inactivity.
   */
  private playerLastActivity: Record<string, number> = {};

  /**
   * Configuration constants
   */
  private readonly UDP_PORT = 41234;
  private readonly PLAYER_TIMEOUT = 20000;      // 20 seconds inactivity => disconnect
  private readonly CLEANUP_INTERVAL = 25000;    // 25 seconds interval to check for inactivity
  private readonly PING_INTERVAL = 5000;       // Clients should ping every 5 seconds

  /**
   * Timer for the cleanup interval
   */
  private cleanupTimer: NodeJS.Timeout;

  constructor(
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
  ) {}

  /**
   * onModuleInit
   * ------------
   * Called once the NestJS module is initialized.
   * - Starts the UDP server.
   * - Starts a repeated cleanup timer for disconnected players.
   */
  onModuleInit() {
    this.startServer();
    this.cleanupTimer = setInterval(() => this.cleanupDisconnectedPlayers(), this.CLEANUP_INTERVAL);
  }

  /**
   * onModuleDestroy
   * ---------------
   * Called during application shutdown.
   * - Closes the UDP socket and clears the cleanup timer.
   */
  onModuleDestroy() {
    if (this.server) {
      this.server.close();
    }
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
  }

  /**
   * startServer
   * -----------
   * Creates the UDP socket, sets up event handlers, and binds to the configured port.
   */
  private startServer() {
    // Create a UDP socket (IPv4)
    this.server = dgram.createSocket('udp4');

    // Handle "error" events
    this.server.on('error', (err) => {
      this.logger.error(`Server error: ${err.stack}`);
      this.server.close();
    });

    // Handle incoming messages
    this.server.on('message', (msg, rinfo) => {
      try {
        const data = JSON.parse(msg.toString());
        const playerId = data.playerId;

        // Always update player's network info if we already know them
        if (playerId && this.players[playerId]) {
          this.players[playerId].address = rinfo.address;
          this.players[playerId].port = rinfo.port;
        }

        // Update last activity time
        if (playerId) {
          this.playerLastActivity[playerId] = Date.now();
        }

        // Handle ping messages quickly
        if (data.type === 'ping') {
          this.handlePing(data, rinfo);
          return;
        }

        // Main switch for game events
        switch (data.type) {
          case 'connect':
            this.handleConnect(data, rinfo);
            break;
          case 'move':
            this.handleMove(data, rinfo);
            break;
          case 'flip':
            this.handleFlip(data, rinfo);
            break;
          case 'rotate':
            this.handleRotate(data, rinfo);
            break;
          case 'attack':
            this.handleAttack(data, rinfo);
            break;
          case 'damage':
            this.handleDamage(data, rinfo);
            break;
          case 'death':
            this.handleDeath(data, rinfo);
            break;
          case 'disconnect':
            this.handleDisconnect(data, rinfo);
            break;
          default:
            // Use template string for clarity in logs
            this.logger.warn(`Unknown message type: ${data.type}`);
            break;
        }
      } catch (err) {
        this.logger.error('Failed to parse incoming message:', err);
      }
    });

    // Handle "listening" event ONCE (combined into a single event listener)
    this.server.on('listening', () => {
      try {
        // Configure socket options - note that some OSes may ignore these
        this.server.setBroadcast(false);
        this.server.setRecvBufferSize(65536);
        this.server.setSendBufferSize(65536);

        const address = this.server.address();
        this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
      } catch (err) {
        this.logger.error(`Error configuring socket: ${err.message}`);
      }
    });

    // Finally bind the socket to the port
    this.server.bind(this.UDP_PORT);
  }

  /**
   * handlePing
   * ----------
   * Responds to "ping" messages with a "pong" to keep connections alive.
   * Also updates the player's last activity time.
   */
  private handlePing(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    
    // Update last activity time if this is a known player
    if (playerId && this.players[playerId]) {
      this.playerLastActivity[playerId] = Date.now();
    }

    console.log('ping received', data);

    // Send pong response with original timestamp for latency calculation
    // this.sendMessage({
    //   type: 'pong',
    //   timestamp: data.timestamp || Date.now(),
    //   pingInterval: this.PING_INTERVAL, // Tell client how often to ping
    //   nextPingTime: Date.now() + this.PING_INTERVAL // Help client schedule next ping
    // }, rinfo.address, rinfo.port);
  }

  /**
   * cleanupDisconnectedPlayers
   * --------------------------
   * Periodically checks which players have been inactive too long
   * and broadcasts a "disconnect" event for them.
   */
  private cleanupDisconnectedPlayers() {
    const now = Date.now();
    const disconnectedPlayers: string[] = [];

    // Find all players whose last activity exceeded PLAYER_TIMEOUT
    for (const [playerId, lastActivity] of Object.entries(this.playerLastActivity)) {
      if (now - lastActivity > this.PLAYER_TIMEOUT) {
        disconnectedPlayers.push(playerId);
      }
    }

    // Remove each disconnected player from server state
    for (const playerId of disconnectedPlayers) {
      if (this.players[playerId]) {
        const roomId = this.players[playerId].roomId;
        const playerInfo = this.players[playerId]; // Store reference before deletion

        this.logger.log(`Player ${playerId} timed out and will be disconnected.`);

        // Send disconnect message to the timed out player
        this.sendMessage({
          type: 'disconnect',
          playerId: playerId,
          reason: 'inactivity_timeout'
        }, playerInfo.address, playerInfo.port);

        // Broadcast to other players that this player has disconnected
        this.broadcastExcept({
          type: 'disconnect',
          playerId: playerId,
          reason: 'inactivity_timeout'
        }, playerId, roomId);

        // Optionally, if your game logic treats a timeout as an actual elimination
        // you can set isAlive = false or update the DB here, e.g.:
        playerInfo.isAlive = false;
        if (playerInfo.eventId) {
          this.updatePlayerDeathInDatabase(playerId, playerInfo.eventId, /*position=*/0);
        }

        // Clean up memory
        delete this.players[playerId];
        delete this.playerLastActivity[playerId];
      }
    }
  }

  /**
   * handleConnect
   * -------------
   * Handles a new player's "connect" message:
   * - Adds them to the in-memory state if not already there.
   * - Sends back "connect_ack" with current players in the room.
   * - Broadcasts "spawn" to all other players in the same room.
   */
  private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const roomId = data.roomId || null;
    const eventId = data.eventId || null;

    // If new to this server, store their info
    if (!this.players[playerId]) {
      this.players[playerId] = {
        address: rinfo.address,
        port: rinfo.port,
        roomId,
        eventId,
        position: { x: 0, y: 0, z: 0 },
        flip: { x: 1, y: 1, z: 1 },
        rotation: 0,
        isAlive: true,
        health: 5,
      };
      this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

      // Update the player's roomId/status in DB if eventId is provided
      if (eventId && roomId) {
        this.updatePlayerInDatabase(playerId, eventId, roomId);
      }
    }

    // Initialize or update last activity time
    this.playerLastActivity[playerId] = Date.now();

    // Build a list of existing players in the same room
    const existingPlayersList = Object.entries(this.players)
      .filter(([pid, info]) => info.roomId === roomId)
      .map(([pid, info]) => ({
        playerId: pid,
        position: info.position,
        flip: info.flip,
        rotation: info.rotation,
        isAlive: info.isAlive,
        health: info.health,
        bot: false,
        roomId: info.roomId,
      }));

    // A) Acknowledge the new player with current state and ping configuration
    this.sendMessage({
      type: 'connect_ack',
      message: 'Welcome to the server!',
      existingPlayers: existingPlayersList,
      pingInterval: this.PING_INTERVAL,
      nextPingTime: Date.now() + this.PING_INTERVAL
    }, rinfo.address, rinfo.port);

    // B) Broadcast "spawn" event to all other players in the room
    this.broadcastExcept({
      type: 'spawn',
      playerId: playerId,
      position: { x: 0, y: 0, z: 0 },
      flip: { x: 1, y: 1, z: 1 },
      rotation: 0,
      isAlive: true,
      health: 5,
      bot: false,
      roomId: roomId,
    }, playerId, roomId);
  }

  /**
   * handleMove
   * ----------
   * Broadcasts a "move" event to other players in the same room.
   */
  private handleMove(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.position = data.position;

    // Broadcast movement to others in the room
    this.broadcastExcept({
      type: 'move',
      playerId: playerId,
      position: data.position,
    }, playerId, player.roomId);
  }

  /**
   * handleFlip
   * ----------
   * Broadcasts a "flip" event (scaling) to other players.
   */
  private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.flip = data.localScale;

    this.broadcastExcept({
      type: 'flip',
      playerId: playerId,
      flip: data.localScale,
    }, playerId, player.roomId);
  }

  /**
   * handleRotate
   * ------------
   * Broadcasts a "rotate" event to other players.
   */
  private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.rotation = data.rotation;

    this.broadcastExcept({
      type: 'rotate',
      playerId: playerId,
      rotation: data.rotation,
    }, playerId, player.roomId);
  }

  /**
   * handleAttack
   * ------------
   * Broadcasts an "attack" event to other players.
   * NOTE: The attacker is excluded (because they already know they attacked).
   * If the attacker also needs confirmation, you'd need to handle that separately.
   */
  private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    this.broadcastExcept({
      type: 'attack',
      playerId: playerId,
      shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
      shootDirection: data.shootDirection || { x: 0, y: 0 },
    }, playerId, player.roomId);
  }

  /**
   * handleDamage
   * ------------
   * Reduces a player's health, checks if they are dead, then broadcasts "damage".
   * If the player dies, optionally updates DB (position, status).
   */
  private handleDamage(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    // Reduce health
    player.health = Math.max(0, player.health - data.damage);

    // Check if death occurred
    if (player.health <= 0) {
      player.isAlive = false;

      // Update DB if it's a Battle Royale event
      if (player.eventId) {
        this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
      }
    }

    // Broadcast damage to other players
    this.broadcastExcept({
      type: 'damage',
      playerId: playerId,
      damage: data.damage,
      shooterId: data.shooterId,
      currentHealth: player.health,
    }, playerId, player.roomId);
  }

  /**
   * handleDeath
   * -----------
   * Handles an explicit "death" event from the client (e.g., they've definitely died).
   */
  private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    player.isAlive = false;

    // Update database for an official death
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
    }

    // Broadcast "death" to others in the room
    this.broadcastExcept({
      type: 'death',
      playerId: playerId,
    }, playerId, player.roomId);
  }

  /**
   * handleDisconnect
   * ---------------
   * Handles an explicit disconnect message from a client.
   * This allows for clean disconnections without waiting for timeout.
   */
  private handleDisconnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    const roomId = player.roomId;
    
    // Log the clean disconnect
    this.logger.log(`Player ${playerId} disconnected cleanly`);

    // Broadcast disconnect to other players in the room
    this.broadcastExcept({
      type: 'disconnect',
      playerId: playerId,
    }, playerId, roomId);

    // If this was a Battle Royale event player, update their status
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, 0);
    }

    // Clean up the player data
    delete this.players[playerId];
    delete this.playerLastActivity[playerId];
  }

  /**
   * broadcastExcept
   * ---------------
   * Sends a message to all players in the same room EXCEPT the given playerId.
   */
  private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null) {
    let broadcastCount = 0;
    for (const [pid, info] of Object.entries(this.players)) {
      if (pid === exceptPlayerId) continue;
      if (roomId && info.roomId !== roomId) continue;

      // Debug-level logging for each broadcast
      this.logger.debug(`Broadcasting to ${pid} at ${info.address}:${info.port}`);
      this.sendMessage(msgObj, info.address, info.port);
      broadcastCount++;
    }
    this.logger.log(`Broadcasted '${msgObj.type}' to ${broadcastCount} players in room ${roomId}`);
  }

  /**
   * sendMessage
   * -----------
   * Safely sends a JSON-serialized object via UDP.
   */
  private sendMessage(dataObj: any, address: string, port: number) {
    const message = Buffer.from(JSON.stringify(dataObj));
    try {
      this.server.send(message, 0, message.length, port, address, (err) => {
        if (err) {
          this.logger.error('Failed to send message:', err);
        }
      });
    } catch (error) {
      this.logger.error('Error sending UDP message:', error);
    }
  }

  /**
   * updatePlayerInDatabase
   * -----------------------
   * Example function to mark a player as 'active' in a given event & room.
   */
  private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
    try {
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        {
          roomId,
          status: 'active',
          isAlive: true,
          position: 0,
        },
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} in database:`, error);
    }
  }

  /**
   * updatePlayerDeathInDatabase
   * ---------------------------
   * Example function to mark a player as 'eliminated' or 'winner' in the database.
   */
  private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
    try {
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        {
          status: position === 1 ? 'winner' : 'eliminated',
          isAlive: false,
          position: position,
        },
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} death in database:`, error);
    }
  }
}

================
File: src/battle-royale/battle-royale.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  Patch,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { BattleRoyaleService } from './services/battle-royale.service';
import { CreateEventDto } from './dto/create-event.dto';
import { RegisterPlayerDto } from './dto/register-player.dto';
import { UpdatePlayerDto } from './dto/update-player.dto';
import { ApiTags, ApiOperation, ApiParam, ApiQuery } from '@nestjs/swagger';

@ApiTags('battle-royale')
@Controller('battle-royale')
export class BattleRoyaleController {
  constructor(private readonly battleRoyaleService: BattleRoyaleService) {}

  @UseGuards(JwtAuthGuard)
  @Post('events')
  @ApiOperation({ summary: 'Create a new Battle Royale event' })
  createEvent(@Body() createEventDto: CreateEventDto) {
    return this.battleRoyaleService.createEvent(createEventDto);
  }

  @Get('events')
  @ApiOperation({ summary: 'Get all Battle Royale events' })
  @ApiQuery({ name: 'status', required: false, description: 'Filter by event status' })
  getEvents(@Query('status') status?: string) {
    return this.battleRoyaleService.getEvents(status);
  }

  @Get('events/upcoming')
  @ApiOperation({ summary: 'Get the latest upcoming Battle Royale event' })
  getLatestUpcomingEvent() {
    return this.battleRoyaleService.getLatestUpcomingEvent();
  }

  @Get('events/:id')
  @ApiOperation({ summary: 'Get a specific Battle Royale event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventById(@Param('id') id: string) {
    return this.battleRoyaleService.getEventById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Post('register')
  @ApiOperation({ summary: 'Register for a Battle Royale event' })
  registerPlayer(@Request() req, @Body() registerPlayerDto: RegisterPlayerDto) {
    return this.battleRoyaleService.registerPlayer(req.user.userId, registerPlayerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('players')
  @ApiOperation({ summary: 'Update player information' })
  updatePlayer(@Request() req, @Body() updatePlayerDto: UpdatePlayerDto) {
    return this.battleRoyaleService.updatePlayer(req.user.userId, updatePlayerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('players/status/:eventId')
  @ApiOperation({ summary: 'Get player status for an event' })
  @ApiParam({ name: 'eventId', description: 'Event ID' })
  getPlayerStatus(@Request() req, @Param('eventId') eventId: string) {
    return this.battleRoyaleService.getPlayerStatus(req.user.userId, eventId);
  }

  @UseGuards(JwtAuthGuard)
  @Post('players/pay-entry-fee/:eventId')
  @ApiOperation({ summary: 'Mark entry fee as paid' })
  @ApiParam({ name: 'eventId', description: 'Event ID' })
  markEntryFeePaid(@Request() req, @Param('eventId') eventId: string) {
    return this.battleRoyaleService.markEntryFeePaid(req.user.userId, eventId);
  }

  @Get('events/:id/players')
  @ApiOperation({ summary: 'Get all players registered for an event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventPlayers(@Param('id') id: string) {
    return this.battleRoyaleService.getEventPlayers(id);
  }

  @Get('events/:id/leaderboard')
  @ApiOperation({ summary: 'Get leaderboard for an event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventLeaderboard(@Param('id') id: string) {
    return this.battleRoyaleService.getEventLeaderboard(id);
  }
}

================
File: src/battle-royale/battle-royale.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { BattleRoyaleController } from './battle-royale.controller';
import { BattleRoyaleService } from './services/battle-royale.service';
import { UdpServerService } from './services/udp-server.service';
import { BattleRoyaleEvent, BattleRoyaleEventSchema } from './schemas/battle-royale-event.schema';
import { BattleRoyalePlayer, BattleRoyalePlayerSchema } from './schemas/battle-royale-player.schema';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    ConfigModule,
    UserModule,
    MongooseModule.forFeature([
      { name: BattleRoyaleEvent.name, schema: BattleRoyaleEventSchema },
      { name: BattleRoyalePlayer.name, schema: BattleRoyalePlayerSchema },
    ]),
  ],
  controllers: [BattleRoyaleController],
  providers: [BattleRoyaleService, UdpServerService],
  exports: [BattleRoyaleService],
})
export class BattleRoyaleModule {}

================
File: src/common/dto/pagination.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 10;
}

================
File: src/common/dto/pagination.dto.ts.meta
================
fileFormatVersion: 2
guid: 0f585f3fec3db452eb852187c2de10a0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/types/game.types.ts
================
export enum GameType {
  NAIRA_RAID = 'naira-raid',
  // Add other games here as needed
}

export interface GameStats {
  totalKills?: number;
  cashCollected?: number;
  // Add other game-specific stats as needed
}

================
File: src/common/types/game.types.ts.meta
================
fileFormatVersion: 2
guid: 7044129c945044bc1ae79cc6a609f850
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/dto.meta
================
fileFormatVersion: 2
guid: 853f3c6dd8c3d47e9b92cc0463762d89
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/types.meta
================
fileFormatVersion: 2
guid: aaf2d9b6ba30c4479b3d74cf75894188
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/config/configuration.ts
================


================
File: src/config/configuration.ts.meta
================
fileFormatVersion: 2
guid: c34c915382c4e4ccc8ead4ff1838f2a3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/controllers/daily-missions.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  UseGuards,
  Request,
  Query,
  Patch,
  Delete,
} from '@nestjs/common';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { DailyMissionsService } from '../services/daily-missions.service';
import { ApiTags, ApiOperation, ApiQuery, ApiParam } from '@nestjs/swagger';
import { UpdateMissionProgressDto } from '../dto/update-mission-progress.dto';
import { CreateMissionDefinitionDto } from '../dto/create-mission-definition.dto';
import { GameType } from '../../common/types/game.types';

@ApiTags('daily-missions')
@Controller('daily-missions')
export class DailyMissionsController {
  constructor(private readonly dailyMissionsService: DailyMissionsService) {}

  @UseGuards(JwtAuthGuard)
  @Post('definitions')
  @ApiOperation({ summary: 'Create a new mission definition' })
  createMissionDefinition(@Body() createDto: CreateMissionDefinitionDto) {
    return this.dailyMissionsService.createMissionDefinition(createDto);
  }

  @Get('definitions')
  @ApiOperation({ summary: 'Get all mission definitions' })
  @ApiQuery({ name: 'activeOnly', required: false, type: Boolean })
  getMissionDefinitions(@Query('activeOnly') activeOnly?: boolean) {
    return this.dailyMissionsService.getMissionDefinitions(activeOnly);
  }

  @Get('definitions/:id')
  @ApiOperation({ summary: 'Get a specific mission definition' })
  @ApiParam({ name: 'id', description: 'Mission definition ID' })
  getMissionDefinitionById(@Param('id') id: string) {
    return this.dailyMissionsService.getMissionDefinitionById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('definitions/:id')
  @ApiOperation({ summary: 'Update a mission definition' })
  @ApiParam({ name: 'id', description: 'Mission definition ID' })
  updateMissionDefinition(
    @Param('id') id: string,
    @Body() updateDto: Partial<CreateMissionDefinitionDto>,
  ) {
    return this.dailyMissionsService.updateMissionDefinition(id, updateDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('definitions/:id')
  @ApiOperation({ summary: 'Deactivate a mission definition' })
  @ApiParam({ name: 'id', description: 'Mission definition ID' })
  deactivateMissionDefinition(@Param('id') id: string) {
    return this.dailyMissionsService.deactivateMissionDefinition(id);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  @ApiOperation({ summary: 'Get daily missions for the current player' })
  getDailyMissions(@Request() req) {
    return this.dailyMissionsService.getDailyMissions(req.user.userId);
  }

  @UseGuards(JwtAuthGuard)
  @Post('progress')
  @ApiOperation({ summary: 'Update mission progress based on game events' })
  updateMissionProgress(
    @Request() req,
    @Body() updateProgressDto: UpdateMissionProgressDto,
  ) {
    return this.dailyMissionsService.updateMissionProgress(
      req.user.userId,
      updateProgressDto.gameId,
      updateProgressDto.matchId,
      updateProgressDto.stats,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Post('claim/:missionProgressId')
  @ApiOperation({ summary: 'Claim rewards for a completed mission' })
  claimMissionReward(
    @Request() req,
    @Param('missionProgressId') missionProgressId: string,
  ) {
    return this.dailyMissionsService.claimMissionReward(
      req.user.userId,
      missionProgressId,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Get('points')
  @ApiOperation({ summary: 'Get total mission points for the current player' })
  getMissionPoints(@Request() req) {
    return this.dailyMissionsService.getMissionPoints(req.user.userId, GameType.NAIRA_RAID);
  }
}

================
File: src/daily-missions/dto/create-daily-mission.dto.ts
================
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { GameType } from '../../common/types/game.types';
import { MissionType } from '../schemas/daily-mission.schema';

export class CreateDailyMissionDto {
  @IsString()
  name: string;

  @IsString()
  description: string;

  @IsEnum(GameType)
  gameId: string;

  @IsEnum(MissionType)
  type: MissionType;

  @IsNumber()
  @Min(1)
  target: number;

  @IsOptional()
  @IsNumber()
  @Min(1)
  matchesRequired?: number;

  @IsNumber()
  @Min(0)
  rewardPoints: number;
}

================
File: src/daily-missions/dto/create-daily-mission.dto.ts.meta
================
fileFormatVersion: 2
guid: a0e63346d703c470fbc4b0b15cc3a24d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/dto/create-mission-definition.dto.ts
================
import { IsEnum, IsNumber, IsObject, IsOptional, IsString, Min } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { MissionType, MissionRequirementType } from '../schemas/mission-definition.schema';

export class ColorRequirementDto {
  @ApiProperty({ description: 'Color identifier from the client' })
  @IsString()
  colorId: string;

  @ApiProperty({ description: 'Color name from the client' })
  @IsString()
  colorName: string;
}

export class SpecialPrizeDto {
  @ApiProperty()
  @IsString()
  description: string;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  limitedToFirst: number;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  remaining: number;
}

export class CreateMissionDefinitionDto {
  @ApiProperty()
  @IsString()
  title: string;

  @ApiProperty()
  @IsString()
  description: string;

  @ApiProperty({ enum: MissionType })
  @IsEnum(MissionType)
  type: MissionType;

  @ApiProperty({ enum: MissionRequirementType })
  @IsEnum(MissionRequirementType)
  requirementType: MissionRequirementType;

  @ApiProperty()
  @IsNumber()
  @Min(1)
  requirementValue: number;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  points: number;

  @ApiProperty({ type: ColorRequirementDto, required: false })
  @IsObject()
  @IsOptional()
  colorRequirement?: ColorRequirementDto;

  @ApiProperty({ type: SpecialPrizeDto, required: false })
  @IsObject()
  @IsOptional()
  specialPrize?: SpecialPrizeDto;
}

================
File: src/daily-missions/dto/update-mission-progress.dto.ts
================
import { IsString, IsNumber, IsObject, ValidateNested, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';

export class ColorKillsDto {
  [key: string]: number;
}

export class GameStatsDto {
  @ApiProperty()
  @IsNumber()
  @Min(0)
  kills: number;

  @ApiProperty({ type: ColorKillsDto })
  @IsObject()
  colorKills: ColorKillsDto;
}

export class UpdateMissionProgressDto {
  @ApiProperty()
  @IsString()
  gameId: string;

  @ApiProperty()
  @IsString()
  matchId: string;

  @ApiProperty({ type: GameStatsDto })
  @ValidateNested()
  @Type(() => GameStatsDto)
  stats: GameStatsDto;
}

================
File: src/daily-missions/schemas/daily-mission.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export enum MissionType {
  TOTAL_KILLS = 'total_kills',
  SINGLE_MATCH_KILLS = 'single_match_kills',
  KILLS_IN_MATCHES = 'kills_in_matches'
}

export type DailyMissionDocument = DailyMission & Document;

@Schema({ timestamps: true })
export class DailyMission {
  _id: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true, enum: MissionType })
  type: MissionType;

  @Prop({ required: true })
  target: number;

  @Prop({ required: function(this: DailyMission) {
    return this.type === MissionType.KILLS_IN_MATCHES;
  } })
  matchesRequired?: number;

  @Prop({ required: true })
  rewardPoints: number;

  @Prop({ default: true })
  isActive: boolean;
}

export const DailyMissionSchema = SchemaFactory.createForClass(DailyMission);

================
File: src/daily-missions/schemas/daily-mission.schema.ts.meta
================
fileFormatVersion: 2
guid: e000e147e649a431d8c018afc8ba071a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas/enemy-color.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type EnemyColorDocument = EnemyColor & Document;

@Schema({ timestamps: true, collection: 'enemycolors' })
export class EnemyColor {
  @Prop({ required: true, unique: true })
  name: string;

  @Prop({ required: true })
  hexCode: string;

  @Prop({ required: true, default: true })
  isActive: boolean;

  @Prop({ type: Object, required: true })
  properties: {
    pointMultiplier: number;
    rarity: string; // common, rare, epic, legendary
    description: string;
  };
}

export const EnemyColorSchema = SchemaFactory.createForClass(EnemyColor);

================
File: src/daily-missions/schemas/mission-definition.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';

export type MissionDefinitionDocument = MissionDefinition & Document;

export enum MissionType {
  DAILY_CUMULATIVE = 'daily_cumulative',
  SINGLE_MATCH = 'single_match',
  COLOR_SPECIFIC_DAILY = 'color_specific_daily',
  COLOR_SPECIFIC_MATCH = 'color_specific_match'
}

export enum MissionRequirementType {
  KILLS = 'kills',
  COLOR_KILLS = 'color_kills',
  SCORE = 'score',
  CASH_COLLECTED = 'cash_collected'
}

@Schema({ timestamps: true, collection: 'missiondefinitions' })
export class MissionDefinition {
  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: MissionType })
  type: string;

  @Prop({ required: true, enum: MissionRequirementType })
  requirementType: string;

  @Prop({ required: true })
  requirementValue: number;

  @Prop({ type: Object, required: false })
  colorRequirement?: {
    colorId: string;
    colorName: string;
  };

  @Prop({ required: true })
  points: number;

  @Prop({ type: Object, required: false })
  specialPrize?: {
    description: string;
    limitedToFirst: number; // Number of players who can claim this prize, 0 means unlimited
    remaining: number; // How many prizes are left
  };

  @Prop({ default: true })
  isActive: boolean;
}

export const MissionDefinitionSchema = SchemaFactory.createForClass(MissionDefinition);

================
File: src/daily-missions/schemas/mission-points.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';

export type MissionPointsDocument = MissionPoints & Document;

@Schema({ timestamps: true })
export class MissionPoints {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ required: true })
  gameId: string;

  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true, default: 0 })
  totalPoints: number; // Accumulates points from all completed missions in the season

  @Prop({ type: [{ type: Object }], default: [] })
  pointHistory: {
    missionId: MongooseSchema.Types.ObjectId;
    points: number;
    date: Date;
  }[];
}

export const MissionPointsSchema = SchemaFactory.createForClass(MissionPoints);

// Create a compound index for efficient lookups
MissionPointsSchema.index({ userId: 1, gameId: 1, seasonNumber: 1 }, { unique: true });

================
File: src/daily-missions/schemas/mission-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { MissionDefinition } from './mission-definition.schema';

export type MissionProgressDocument = MissionProgress & Document;

export enum MissionStatus {
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  CLAIMED = 'claimed'
}

@Schema({ timestamps: true })
export class MissionProgress {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'MissionDefinition', required: true })
  missionId: MissionDefinition;

  @Prop({ required: true })
  date: Date; // The date this mission was assigned

  @Prop({ required: true, default: 0 })
  currentProgress: number;

  @Prop({ type: Object, required: false })
  matchProgress?: {
    matchId: string;
    progress: number;
  }[];

  @Prop({ type: Object, required: false })
  colorProgress?: {
    [colorId: string]: number;
  };

  @Prop({ required: true, enum: MissionStatus, default: MissionStatus.IN_PROGRESS })
  status: string;

  @Prop({ type: Boolean, default: false })
  specialPrizeClaimed: boolean;

  @Prop({ type: Date })
  completedAt?: Date;

  @Prop({ type: Date })
  claimedAt?: Date;
}

export const MissionProgressSchema = SchemaFactory.createForClass(MissionProgress);

================
File: src/daily-missions/schemas/user-mission-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';
import { DailyMission } from './daily-mission.schema';

export type UserMissionProgressDocument = UserMissionProgress & Document;

@Schema({ timestamps: true })
export class UserMissionProgress {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: DailyMission.name, required: true })
  missionId: Types.ObjectId | DailyMission;

  @Prop({ required: true })
  progress: number;

  @Prop({ type: [Number], default: [] })
  matchProgresses: number[]; // For tracking progress in individual matches

  @Prop({ required: true })
  date: Date;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ default: false })
  isCompleted: boolean;

  @Prop({ default: false })
  rewardClaimed: boolean;
}

export const UserMissionProgressSchema = SchemaFactory.createForClass(UserMissionProgress);

// Create compound index for unique mission progress per user per day
UserMissionProgressSchema.index(
  { userId: 1, missionId: 1, date: 1 },
  { unique: true }
);

================
File: src/daily-missions/schemas/user-mission-progress.schema.ts.meta
================
fileFormatVersion: 2
guid: 5fbeeeae2eb9d437eaa357c86f73f04b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/services/daily-missions.service.ts
================
/* eslint-disable max-len */
import { Injectable, NotFoundException, BadRequestException, Inject, forwardRef } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types, Schema as MongooseSchema } from 'mongoose';
import { MissionDefinition, MissionDefinitionDocument, MissionType, MissionRequirementType } from '../schemas/mission-definition.schema';
import { MissionProgress, MissionProgressDocument, MissionStatus } from '../schemas/mission-progress.schema';
import { MissionPoints, MissionPointsDocument } from '../schemas/mission-points.schema';
import { LeaderboardService } from '../../leaderboard/leaderboard.service';
import { GameType } from '../../common/types/game.types';
import { LeaderboardEntry, LeaderboardEntryDocument } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { CreateMissionDefinitionDto } from '../dto/create-mission-definition.dto';

@Injectable()
export class DailyMissionsService {
  constructor(
    @InjectModel(MissionDefinition.name)
    private readonly missionDefinitionModel: Model<MissionDefinitionDocument>,
    @InjectModel(MissionProgress.name)
    private readonly missionProgressModel: Model<MissionProgressDocument>,
    @InjectModel(MissionPoints.name)
    private readonly missionPointsModel: Model<MissionPointsDocument>,
    @Inject(forwardRef(() => LeaderboardService))
    private readonly leaderboardService: LeaderboardService,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
  ) {}

  /**
   * Get daily missions for a player
   * -----------------------------
   * Fetches or creates new daily missions for the player
   */
  async getDailyMissions(userId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get player's missions for today
    let missions = await this.missionProgressModel
      .find({
        userId,
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
      })
      .populate('missionId');

    // If no missions for today, generate new ones
    if (missions.length === 0) {
      missions = await this.generateDailyMissions(userId);
    }

    return missions;
  }

  /**
   * Generate daily missions for a player
   * ----------------------------------
   * Creates a new set of daily missions for the player.
   * Uses the current date to deterministically select missions,
   * ensuring all players get the same missions on any given day.
   */
  private async generateDailyMissions(userId: string) {
    // Get active mission definitions
    const missionDefs = await this.missionDefinitionModel
      .find({ isActive: true })
      .exec();

    if (missionDefs.length < 3) {
      throw new BadRequestException('Not enough active missions available');
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Create a deterministic seed based on the date
    const dateString = today.toISOString().split('T')[0]; // Format: YYYY-MM-DD
    const dateSeed = Array.from(dateString).reduce((acc, char) => acc + char.charCodeAt(0), 0);

    // Sort missions deterministically based on the date
    const sortedMissions = [...missionDefs].sort((a, b) => {
      // Create a unique number for each mission based on its ID and the date
      const aValue = (a._id.toString() + dateSeed).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      const bValue = (b._id.toString() + dateSeed).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return aValue - bValue;
    });

    // Take the first 3 missions after sorting
    const selectedMissions = sortedMissions.slice(0, 3);

    // Create mission progress entries
    const missionProgress = await Promise.all(
      selectedMissions.map(mission => {
        return new this.missionProgressModel({
          userId: new Types.ObjectId(userId),
          missionId: mission._id,
          date: today,
          currentProgress: 0,
          status: MissionStatus.IN_PROGRESS,
        }).save();
      }),
    );

    return missionProgress;
  }

  /**
   * Update mission progress
   * ---------------------
   * Updates progress for missions based on game events
   */
  async updateMissionProgress(
    userId: string,
    gameId: string,
    matchId: string,
    stats: {
      kills: number;
      colorKills: { [colorId: string]: number };
    },
  ) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get today's missions
    const missions = await this.missionProgressModel
      .find({
        userId,
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
        status: { $ne: MissionStatus.CLAIMED },
      })
      .populate('missionId');

    // Process each mission
    for (const mission of missions) {
      const def = mission.missionId as MissionDefinitionDocument;

      switch (def.type) {
        case MissionType.DAILY_CUMULATIVE:
          if (def.requirementType === MissionRequirementType.KILLS) {
            mission.currentProgress += stats.kills;
          }
          break;

        case MissionType.SINGLE_MATCH:
          if (def.requirementType === MissionRequirementType.KILLS) {
            if (!mission.matchProgress) {
              mission.matchProgress = [];
            }
            mission.matchProgress.push({
              matchId,
              progress: stats.kills,
            });
            mission.currentProgress = Math.max(
              ...mission.matchProgress.map(m => m.progress),
            );
          }
          break;

        case MissionType.COLOR_SPECIFIC_DAILY:
          if (def.requirementType === MissionRequirementType.COLOR_KILLS && def.colorRequirement) {
            const colorKills = stats.colorKills[def.colorRequirement.colorId] || 0;
            mission.currentProgress += colorKills;
          }
          break;

        case MissionType.COLOR_SPECIFIC_MATCH:
          if (def.requirementType === MissionRequirementType.COLOR_KILLS && def.colorRequirement) {
            const colorKills = stats.colorKills[def.colorRequirement.colorId] || 0;
            if (!mission.matchProgress) {
              mission.matchProgress = [];
            }
            mission.matchProgress.push({
              matchId,
              progress: colorKills,
            });
            mission.currentProgress = Math.max(
              ...mission.matchProgress.map(m => m.progress),
            );
          }
          break;
      }

      // Check if mission is completed
      if (mission.currentProgress >= def.requirementValue && mission.status === MissionStatus.IN_PROGRESS) {
        mission.status = MissionStatus.COMPLETED;
        mission.completedAt = new Date();
      }

      await mission.save();
    }
  }

  /**
   * Claim mission rewards
   * -------------------
   * Claims rewards for a completed mission
   */
  async claimMissionReward(userId: string, missionProgressId: string) {
    const mission = await this.missionProgressModel
      .findById(missionProgressId)
      .populate('missionId');

    if (!mission) {
      throw new NotFoundException('Mission progress not found');
    }

    if (mission.status !== MissionStatus.COMPLETED) {
      throw new BadRequestException('Mission is not completed');
    }

    const def = mission.missionId as MissionDefinitionDocument;

    // Check if special prize is available
    if (def.specialPrize && def.specialPrize.limitedToFirst > 0) {
      if (def.specialPrize.remaining <= 0) {
        throw new BadRequestException('Special prize is no longer available');
      }
      def.specialPrize.remaining--;
      await def.save();
    }

    // Get current leaderboard
    const currentLeaderboard = await this.leaderboardService.getCurrentLeaderboard(GameType.NAIRA_RAID);
    
    // Update leaderboard entry with extra points
    const leaderboardEntry = await this.leaderboardEntryModel.findOne({
      userId,
      leaderboardId: currentLeaderboard._id,
    });

    if (leaderboardEntry) {
      leaderboardEntry.extraPoints = (leaderboardEntry.extraPoints || 0) + def.points;
      await leaderboardEntry.save();
    }

    // Update mission points tracking
    let missionPoints = await this.missionPointsModel.findOne({
      userId,
      gameId: GameType.NAIRA_RAID,
      seasonNumber: currentLeaderboard.seasonNumber,
    });

    if (!missionPoints) {
      missionPoints = new this.missionPointsModel({
        userId,
        gameId: GameType.NAIRA_RAID,
        seasonNumber: currentLeaderboard.seasonNumber,
        totalPoints: 0,
        pointHistory: [],
      });
    }

    // Add points to history and update total
    const missionDefinition = mission.missionId as MissionDefinitionDocument;
    missionPoints.pointHistory.push({
      missionId: missionDefinition._id as MongooseSchema.Types.ObjectId,
      points: missionDefinition.points,
      date: new Date(),
    });
    missionPoints.totalPoints += missionDefinition.points;
    await missionPoints.save();

    // Update mission status
    mission.status = MissionStatus.CLAIMED;
    mission.claimedAt = new Date();
    await mission.save();

    return {
      claimed: true,
      points: missionDefinition.points,
      specialPrize: def.specialPrize && def.specialPrize.remaining > 0,
    };
  }

  /**
   * Get mission points
   * ----------------
   * Gets the total mission points for a player in the current season
   */
  async getMissionPoints(userId: string, gameId: string): Promise<number> {
    const currentLeaderboard = await this.leaderboardService.getCurrentLeaderboard(gameId);
    
    const points = await this.missionPointsModel.findOne({
      userId,
      gameId,
      seasonNumber: currentLeaderboard.seasonNumber,
    });

    return points?.totalPoints || 0;
  }

  /**
   * Create a new mission definition
   */
  async createMissionDefinition(createDto: CreateMissionDefinitionDto): Promise<MissionDefinitionDocument> {
    // Create the mission definition
    const missionDefinition = new this.missionDefinitionModel({
      ...createDto,
      isActive: true,
    });

    return missionDefinition.save();
  }

  /**
   * Get all mission definitions
   */
  async getMissionDefinitions(activeOnly: boolean = false) {
    const query = activeOnly ? { isActive: true } : {};
    return this.missionDefinitionModel.find(query).exec();
  }

  /**
   * Get a specific mission definition
   */
  async getMissionDefinitionById(id: string): Promise<MissionDefinitionDocument> {
    const mission = await this.missionDefinitionModel.findById(id);
    if (!mission) {
      throw new NotFoundException(`Mission definition with ID ${id} not found`);
    }
    return mission;
  }

  /**
   * Update a mission definition
   */
  async updateMissionDefinition(
    id: string,
    updateDto: Partial<CreateMissionDefinitionDto>,
  ): Promise<MissionDefinitionDocument> {
    const mission = await this.missionDefinitionModel.findByIdAndUpdate(
      id,
      { $set: updateDto },
      { new: true },
    );

    if (!mission) {
      throw new NotFoundException(`Mission definition with ID ${id} not found`);
    }

    return mission;
  }

  /**
   * Deactivate a mission definition
   */
  async deactivateMissionDefinition(id: string): Promise<MissionDefinitionDocument> {
    const mission = await this.missionDefinitionModel.findByIdAndUpdate(
      id,
      { $set: { isActive: false } },
      { new: true },
    );

    if (!mission) {
      throw new NotFoundException(`Mission definition with ID ${id} not found`);
    }

    return mission;
  }
}

================
File: src/daily-missions/daily-missions.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { DailyMissionsController } from './daily-missions.controller';

describe('DailyMissionsController', () => {
  let controller: DailyMissionsController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DailyMissionsController],
    }).compile();

    controller = module.get<DailyMissionsController>(DailyMissionsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/daily-missions/daily-missions.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 4eba985d7059f46fa8053dad2f6f3883
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.controller.ts
================
import { Controller } from '@nestjs/common';

@Controller('daily-missions')
export class DailyMissionsController {}

================
File: src/daily-missions/daily-missions.controller.ts.meta
================
fileFormatVersion: 2
guid: 43b666801c3fe4c7b9783f9d8d0a38e3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { DailyMissionsController } from './controllers/daily-missions.controller';
import { DailyMissionsService } from './services/daily-missions.service';
import { MissionDefinition, MissionDefinitionSchema } from './schemas/mission-definition.schema';
import { MissionProgress, MissionProgressSchema } from './schemas/mission-progress.schema';
import { MissionPoints, MissionPointsSchema } from './schemas/mission-points.schema';
import { LeaderboardModule } from '../leaderboard/leaderboard.module';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../leaderboard/schemas/leaderboard-entry.schema';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => LeaderboardModule),
    MongooseModule.forFeature([
      { name: MissionDefinition.name, schema: MissionDefinitionSchema },
      { name: MissionProgress.name, schema: MissionProgressSchema },
      { name: MissionPoints.name, schema: MissionPointsSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
    ]),
  ],
  controllers: [DailyMissionsController],
  providers: [DailyMissionsService],
  exports: [DailyMissionsService],
})
export class DailyMissionsModule {}

================
File: src/daily-missions/daily-missions.module.ts.meta
================
fileFormatVersion: 2
guid: 0c81bdf25d3b54d0b8fe83f8f5dc127b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { DailyMissionsService } from './daily-missions.service';

describe('DailyMissionsService', () => {
  let service: DailyMissionsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DailyMissionsService],
    }).compile();

    service = module.get<DailyMissionsService>(DailyMissionsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/daily-missions/daily-missions.service.spec.ts.meta
================
fileFormatVersion: 2
guid: f0e5d4d2ac74f4900a25d0ec1de78830
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.service.ts
================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  DailyMission,
  DailyMissionDocument,
} from './schemas/daily-mission.schema';
import {
  UserMissionProgress,
  UserMissionProgressDocument,
} from './schemas/user-mission-progress.schema';
import { CreateDailyMissionDto } from './dto/create-daily-mission.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { MissionType } from './schemas/daily-mission.schema';

@Injectable()
export class DailyMissionsService {
  constructor(
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
    @InjectModel(UserMissionProgress.name)
    private readonly userMissionProgressModel: Model<UserMissionProgressDocument>,
  ) {}

  async createMission(
    createDailyMissionDto: CreateDailyMissionDto,
  ): Promise<DailyMissionDocument> {
    const mission = new this.dailyMissionModel(createDailyMissionDto);
    return mission.save();
  }

  async findAllMissions(gameId: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [missions, total] = await Promise.all([
      this.dailyMissionModel
        .find({ gameId, isActive: true })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.dailyMissionModel.countDocuments({ gameId, isActive: true }),
    ]);

    return {
      missions,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getUserMissionProgress(userId: string, gameId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const activeMissions = await this.dailyMissionModel.find({
      gameId,
      isActive: true,
    });

    const userProgress = await this.userMissionProgressModel
      .find({
        userId,
        missionId: { $in: activeMissions.map((m) => m._id) },
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
      })
      .populate('missionId');

    // Create progress entries for missions that don't have them yet
    const existingMissionIds = userProgress.map((p) => 
      p.missionId._id.toString(),
    );
    const missionsWithoutProgress = activeMissions.filter(
      (m) => !existingMissionIds.includes(m._id.toString()),
    );

    if (missionsWithoutProgress.length > 0) {
      const newProgressEntries = await this.userMissionProgressModel.insertMany(
        missionsWithoutProgress.map((mission) => ({
          userId,
          missionId: mission._id,
          gameId,
          progress: 0,
          matchProgresses: [],
          date: today,
        })),
      );

      userProgress.push(
        ...(await this.userMissionProgressModel
          .find({ _id: { $in: newProgressEntries.map((p) => p._id) } })
          .populate('missionId')),
      );
    }

    return userProgress;
  }

  async updateMissionProgress(
    userId: string,
    gameId: string,
    gameStats: { totalKills: number },
    matchNumber: number,
  ) {
    const userProgress = await this.getUserMissionProgress(userId, gameId);

    const updates = userProgress.map(async (progress) => {
      const mission = progress.missionId as DailyMissionDocument;
      let shouldUpdate = false;
      let newProgress = progress.progress;

      switch (mission.type) {
        case MissionType.TOTAL_KILLS:
          newProgress = progress.progress + gameStats.totalKills;
          shouldUpdate = true;
          break;

        case MissionType.SINGLE_MATCH_KILLS:
          if (gameStats.totalKills > progress.progress) {
            newProgress = gameStats.totalKills;
            shouldUpdate = true;
          }
          break;

        case MissionType.KILLS_IN_MATCHES:
          progress.matchProgresses[matchNumber - 1] = gameStats.totalKills;
          const validMatches = progress.matchProgresses
            .filter((kills) => kills >= mission.target)
            .length;
          newProgress = validMatches;
          shouldUpdate = true;
          break;
      }

      if (shouldUpdate) {
        progress.progress = newProgress;
        progress.isCompleted = newProgress >= mission.target;
        return progress.save();
      }

      return progress;
    });

    return Promise.all(updates);
  }

  async claimReward(userId: string, missionId: string): Promise<number> {
    const progress = await this.userMissionProgressModel
      .findOne({ userId, missionId })
      .populate('missionId');

    if (!progress) {
      throw new NotFoundException('Mission progress not found');
    }

    if (!progress.isCompleted) {
      throw new BadRequestException('Mission not completed');
    }

    if (progress.rewardClaimed) {
      throw new BadRequestException('Reward already claimed');
    }

    progress.rewardClaimed = true;
    await progress.save();

    const mission = progress.missionId as DailyMissionDocument;
    return mission.rewardPoints;
  }
}

================
File: src/daily-missions/daily-missions.service.ts.meta
================
fileFormatVersion: 2
guid: 444557d4d19d645f39aca27235d05cd6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/dto.meta
================
fileFormatVersion: 2
guid: 4e10823e1a09540308108911ed5db7a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas.meta
================
fileFormatVersion: 2
guid: 26b82d9e3a5734c9b8982f2e7fc79e6b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/daily-mission.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { DailyMission, DailyMissionDocument, MissionType } from '../../daily-missions/schemas/daily-mission.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class DailyMissionSeeder {
  constructor(
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
  ) {}

  async seed(): Promise<DailyMissionDocument[]> {
    // Clear existing missions
    await this.dailyMissionModel.deleteMany({});

    const missions: Partial<DailyMission>[] = [];

    // Create missions for each type
    Object.values(MissionType).forEach((type) => {
      const count = faker.number.int({ min: 2, max: 4 }); // 2-4 missions per type
      
      for (let i = 0; i < count; i++) {
        const target = faker.number.int({ min: 5, max: 50 });
        const missionData: Partial<DailyMission> = {
          name: this.generateMissionName(type, target),
          description: this.generateMissionDescription(type, target),
          gameId: GameType.NAIRA_RAID,
          type,
          target,
          rewardPoints: faker.number.int({ min: 100, max: 1000 }),
          isActive: true,
        };

        // Only add matchesRequired for KILLS_IN_MATCHES type
        if (type === MissionType.KILLS_IN_MATCHES) {
          missionData.matchesRequired = faker.number.int({ min: 3, max: 5 });
        }

        missions.push(missionData);
      }
    });

    return this.dailyMissionModel.insertMany(missions) as Promise<DailyMissionDocument[]>;
  }

  private generateMissionName(type: MissionType, target: number): string {
    switch (type) {
      case MissionType.TOTAL_KILLS:
        return `Eliminate ${target} Enemies`;
      case MissionType.SINGLE_MATCH_KILLS:
        return `Get ${target} Kills in One Match`;
      case MissionType.KILLS_IN_MATCHES:
        return `Get ${target} Kills in Multiple Matches`;
      default:
        return `Complete ${target} Objectives`;
    }
  }

  private generateMissionDescription(type: MissionType, target: number): string {
    switch (type) {
      case MissionType.TOTAL_KILLS:
        return `Eliminate a total of ${target} enemies in any number of matches.`;
      case MissionType.SINGLE_MATCH_KILLS:
        return `Eliminate ${target} enemies in a single match.`;
      case MissionType.KILLS_IN_MATCHES:
        return `Get ${target} kills in each of several matches.`;
      default:
        return `Complete ${target} mission objectives.`;
    }
  }
}

================
File: src/database/seeders/daily-mission.seeder.ts.meta
================
fileFormatVersion: 2
guid: 7f76c1a7e7c1047fca7f2ca5303a1eda
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/daily-missions.seeder.ts
================
/* eslint-disable max-len */
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MissionDefinition, MissionType, MissionRequirementType } from '../../daily-missions/schemas/mission-definition.schema';
import { EnemyColor } from '../../daily-missions/schemas/enemy-color.schema';
import { MissionProgress, MissionStatus } from '../../daily-missions/schemas/mission-progress.schema';
import { MissionPoints } from '../../daily-missions/schemas/mission-points.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class DailyMissionsSeeder {
  constructor(
    @InjectModel(MissionDefinition.name)
    private readonly missionDefinitionModel: Model<MissionDefinition>,
    @InjectModel(EnemyColor.name)
    private readonly enemyColorModel: Model<EnemyColor>,
    @InjectModel(MissionProgress.name)
    private readonly missionProgressModel: Model<MissionProgress>,
    @InjectModel(MissionPoints.name)
    private readonly missionPointsModel: Model<MissionPoints>,
  ) {
    console.log('[DailyMissionsSeeder] Constructed');
    console.log(`[DailyMissionsSeeder] MissionDefinition model name: ${MissionDefinition.name}`);
    console.log(`[DailyMissionsSeeder] EnemyColor model name: ${EnemyColor.name}`);
  }

  async seed() {
    try {
      console.log('[DailyMissionsSeeder] Starting daily missions seeding...');
      
      // Clear existing data
      console.log('[DailyMissionsSeeder] Clearing existing data...');
      const [missionDeleteResult, colorDeleteResult, progressDeleteResult, pointsDeleteResult] = await Promise.all([
        this.missionDefinitionModel.deleteMany({}),
        this.enemyColorModel.deleteMany({}),
        this.missionProgressModel.deleteMany({}),
        this.missionPointsModel.deleteMany({}),
      ]);
      console.log(`[DailyMissionsSeeder] Deleted ${missionDeleteResult.deletedCount} mission definitions`);
      console.log(`[DailyMissionsSeeder] Deleted ${colorDeleteResult.deletedCount} enemy colors`);
      console.log(`[DailyMissionsSeeder] Deleted ${progressDeleteResult.deletedCount} mission progresses`);
      console.log(`[DailyMissionsSeeder] Deleted ${pointsDeleteResult.deletedCount} mission points`);

      // Seed enemy colors
      console.log('[DailyMissionsSeeder] Creating enemy colors...');
      const colorData = [
        {
          name: 'Red',
          hexCode: '#FF0000',
          isActive: true,
          properties: {
            pointMultiplier: 1.0,
            rarity: 'common',
            description: 'Basic enemy type',
          },
        },
        {
          name: 'Blue',
          hexCode: '#0000FF',
          isActive: true,
          properties: {
            pointMultiplier: 1.5,
            rarity: 'rare',
            description: 'Faster and more agile',
          },
        },
        {
          name: 'Gold',
          hexCode: '#FFD700',
          isActive: true,
          properties: {
            pointMultiplier: 3.0,
            rarity: 'legendary',
            description: 'Rare and valuable enemy',
          },
        },
      ];

      console.log('[DailyMissionsSeeder] About to create enemy colors with data:', JSON.stringify(colorData, null, 2));
      const colors = await this.enemyColorModel.create(colorData);
      console.log(`[DailyMissionsSeeder] Created ${colors.length} enemy colors`);

      // Log color IDs for debugging
      colors.forEach(color => {
        console.log(`[DailyMissionsSeeder] Created color: ${color.name} with ID: ${color._id}`);
      });

      // Seed mission definitions
      console.log('[DailyMissionsSeeder] Creating mission definitions...');
      const missionData = [
        {
          title: 'Kill Streak',
          description: 'Get 50 kills in a single match',
          type: MissionType.SINGLE_MATCH,
          requirementType: MissionRequirementType.KILLS,
          requirementValue: 50,
          points: 300,
          isActive: true,
        },
        {
          title: 'Daily Hunter',
          description: 'Accumulate 100 kills throughout the day',
          type: MissionType.DAILY_CUMULATIVE,
          requirementType: MissionRequirementType.KILLS,
          requirementValue: 100,
          points: 200,
          isActive: true,
        },
        {
          title: 'Gold Rush',
          description: 'Kill 10 gold enemies in a single match',
          type: MissionType.COLOR_SPECIFIC_MATCH,
          requirementType: MissionRequirementType.COLOR_KILLS,
          requirementValue: 10,
          colorRequirement: {
            colorId: colors[2]._id.toString(),
            colorName: 'Gold',
          },
          points: 500,
          isActive: true,
        },
        {
          title: 'Blue Hunter',
          description: 'Kill 30 blue enemies throughout the day',
          type: MissionType.COLOR_SPECIFIC_DAILY,
          requirementType: MissionRequirementType.COLOR_KILLS,
          requirementValue: 30,
          colorRequirement: {
            colorId: colors[1]._id.toString(),
            colorName: 'Blue',
          },
          points: 300,
          isActive: true,
        },
        {
          title: 'Red Menace',
          description: 'Kill 50 red enemies throughout the day',
          type: MissionType.COLOR_SPECIFIC_DAILY,
          requirementType: MissionRequirementType.COLOR_KILLS,
          requirementValue: 50,
          colorRequirement: {
            colorId: colors[0]._id.toString(),
            colorName: 'Red',
          },
          points: 200,
          isActive: true,
        },
      ];

      console.log('[DailyMissionsSeeder] About to create mission definitions with data:', JSON.stringify(missionData, null, 2));
      const missions = await this.missionDefinitionModel.create(missionData);
      console.log(`[DailyMissionsSeeder] Created ${missions.length} mission definitions`);

      // Log mission details for debugging
      missions.forEach(mission => {
        console.log(`[DailyMissionsSeeder] Created mission: ${mission.title} with ID: ${mission._id}`);
      });

      // Create some sample mission progress and points
      console.log('[DailyMissionsSeeder] Creating sample mission progress and points...');
      
      // Sample user IDs (you might want to get these from actual users)
      const sampleUserIds = [
        '507f1f77bcf86cd799439011',
        '507f1f77bcf86cd799439012',
        '507f1f77bcf86cd799439013'
      ];

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Create mission progress for each user
      for (const userId of sampleUserIds) {
        // Create progress for each mission
        const progressData = missions.map(mission => ({
          userId,
          missionId: mission._id,
          date: today,
          currentProgress: Math.floor(Math.random() * mission.requirementValue),
          status: MissionStatus.IN_PROGRESS,
        }));

        await this.missionProgressModel.create(progressData);
        console.log(`[DailyMissionsSeeder] Created ${progressData.length} mission progresses for user ${userId}`);

        // Create mission points
        const pointsData = {
          userId,
          gameId: GameType.NAIRA_RAID,
          seasonNumber: 1,
          totalPoints: Math.floor(Math.random() * 1000),
          pointHistory: missions.map(mission => ({
            missionId: mission._id,
            points: mission.points,
            date: new Date(),
          })),
        };

        await this.missionPointsModel.create(pointsData);
        console.log(`[DailyMissionsSeeder] Created mission points for user ${userId}`);
      }

      // Verify the data was created
      const colorCount = await this.enemyColorModel.countDocuments();
      const missionCount = await this.missionDefinitionModel.countDocuments();
      const progressCount = await this.missionProgressModel.countDocuments();
      const pointsCount = await this.missionPointsModel.countDocuments();

      console.log(`[DailyMissionsSeeder] Verification - Colors: ${colorCount}, Missions: ${missionCount}, Progresses: ${progressCount}, Points: ${pointsCount}`);

      return {
        colors,
        missions,
        progressCount,
        pointsCount,
      };
    } catch (error) {
      console.error('[DailyMissionsSeeder] Error seeding daily missions:', error.stack || error);
      throw error;
    }
  }
}

================
File: src/database/seeders/inventory.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { InventoryItem, InventoryItemDocument } from '../../inventory/schemas/inventory-item.schema';
import { UserInventory, UserInventoryDocument } from '../../inventory/schemas/user-inventory.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class InventorySeeder {
  constructor(
    @InjectModel(InventoryItem.name)
    private readonly inventoryItemModel: Model<InventoryItemDocument>,
    @InjectModel(UserInventory.name)
    private readonly userInventoryModel: Model<UserInventoryDocument>,
  ) {}

  async seed(users: UserDocument[]) {
    // Clear existing data
    await Promise.all([
      this.inventoryItemModel.deleteMany({}),
      this.userInventoryModel.deleteMany({}),
    ]);

    // Create inventory items
    const items = await this.createInventoryItems();

    // Create user inventories
    const userInventories = await this.createUserInventories(users, items);

    return {
      items,
      userInventories,
    };
  }

  private async createInventoryItems(): Promise<InventoryItemDocument[]> {
    const itemTypes = ['power-up', 'weapon', 'currency', 'boost'];
    const items: Partial<InventoryItem>[] = [];

    // Create 20 random items
    for (let i = 0; i < 20; i++) {
      const type = faker.helpers.arrayElement(itemTypes);
      items.push({
        name: faker.commerce.productName(),
        description: faker.commerce.productDescription(),
        gameId: GameType.NAIRA_RAID,
        type,
        duration: type === 'power-up' ? faker.number.int({ min: 30, max: 300 }) : undefined,
        power: type === 'weapon' ? faker.number.int({ min: 1, max: 100 }) : undefined,
        isActive: true,
      });
    }

    return this.inventoryItemModel.insertMany(items) as Promise<InventoryItemDocument[]>;
  }

  private async createUserInventories(
    users: UserDocument[],
    items: InventoryItemDocument[],
  ): Promise<UserInventoryDocument[]> {
    const userInventories: Partial<UserInventory>[] = [];

    for (const user of users) {
      // Give each user 1-5 random items
      const itemCount = faker.number.int({ min: 1, max: 5 });
      const selectedItems = faker.helpers.arrayElements(items, itemCount);

      for (const item of selectedItems) {
        userInventories.push({
          userId: user._id,
          itemId: item._id,
          quantity: faker.number.int({ min: 1, max: 10 }),
          gameId: GameType.NAIRA_RAID,
          expiresAt: faker.helpers.arrayElement([
            undefined,
            faker.date.future(),
          ]),
        });
      }
    }

    return this.userInventoryModel.insertMany(userInventories) as Promise<UserInventoryDocument[]>;
  }
}

================
File: src/database/seeders/inventory.seeder.ts.meta
================
fileFormatVersion: 2
guid: 84afe2f1dc24f42959c73c6424cc8e8a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/leaderboard.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { Leaderboard, LeaderboardDocument } from '../../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntryDocument } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionDocument } from '../../leaderboard/schemas/game-session.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class LeaderboardSeeder {
  constructor(
    @InjectModel(Leaderboard.name)
    private readonly leaderboardModel: Model<LeaderboardDocument>,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
    @InjectModel(GameSession.name)
    private readonly gameSessionModel: Model<GameSessionDocument>,
  ) {}

  async seed(users: UserDocument[]) {
    // Clear existing data
    await Promise.all([
      this.leaderboardModel.deleteMany({}),
      this.leaderboardEntryModel.deleteMany({}),
      this.gameSessionModel.deleteMany({}),
    ]);

    // Create current season leaderboard
    const currentLeaderboard = await this.leaderboardModel.create({
      seasonNumber: 1,
      seasonStart: new Date(),
      seasonEnd: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days from now
      gameId: GameType.NAIRA_RAID,
      isActive: true,
    });

    // Create leaderboard entries and game sessions for each user
    const leaderboardEntries = [];
    const gameSessions = [];

    for (const user of users) {
      // Create 1-5 game sessions per user
      const sessionCount = faker.number.int({ min: 1, max: 5 });
      for (let i = 0; i < sessionCount; i++) {
        const score = faker.number.int({ min: 100, max: 10000 });
        const totalKills = faker.number.int({ min: 5, max: 50 });
        const cashCollected = faker.number.int({ min: 1000, max: 100000 });

        gameSessions.push({
          userId: user._id,
          gameId: GameType.NAIRA_RAID,
          score,
          gameStats: {
            totalKills,
            cashCollected,
          },
          isCompleted: true,
        });
      }

      // Create leaderboard entry with highest score
      const highestScore = Math.max(...gameSessions
        .filter(session => session.userId.toString() === user._id.toString())
        .map(session => session.score));

      leaderboardEntries.push({
        userId: user._id,
        leaderboardId: currentLeaderboard._id,
        score: highestScore,
        extraPoints: faker.number.int({ min: 0, max: 1000 }),
        seasonNumber: currentLeaderboard.seasonNumber,
        gameId: GameType.NAIRA_RAID,
        gameStats: {
          totalKills: faker.number.int({ min: 50, max: 500 }),
          cashCollected: faker.number.int({ min: 10000, max: 1000000 }),
        },
      });
    }

    await Promise.all([
      this.leaderboardEntryModel.insertMany(leaderboardEntries),
      this.gameSessionModel.insertMany(gameSessions),
    ]);

    return {
      leaderboard: currentLeaderboard,
      entries: leaderboardEntries,
      sessions: gameSessions,
    };
  }
}

================
File: src/database/seeders/leaderboard.seeder.ts.meta
================
fileFormatVersion: 2
guid: b12afed1b0e954a1fbe141f9e8af4f8d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/player-progress.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { PlayerProgress, PlayerProgressDocument } from '../../player-progress/schemas/player-progress.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class PlayerProgressSeeder {
  constructor(
    @InjectModel(PlayerProgress.name)
    private readonly playerProgressModel: Model<PlayerProgressDocument>,
  ) {}

  async seed(users: UserDocument[]): Promise<PlayerProgressDocument[]> {
    // Clear existing progress
    await this.playerProgressModel.deleteMany({});

    const progressRecords: Partial<PlayerProgress>[] = [];

    // Create progress for each user
    for (const user of users) {
      const level = faker.number.int({ min: 1, max: 50 });
      const ranks = ['Rookie', 'Intermediate', 'Advanced', 'Veteran', 'Expert', 'Master', 'Legend'];
      const currentRankIndex = Math.min(Math.floor(level / 7), ranks.length - 1);
      
      // Generate rank history
      const rankHistory = [];
      for (let i = 0; i <= currentRankIndex; i++) {
        rankHistory.push({
          rank: ranks[i],
          achievedAt: faker.date.past(),
        });
      }

      progressRecords.push({
        userId: user._id,
        gameId: GameType.NAIRA_RAID,
        level,
        experience: faker.number.int({ min: 0, max: 999 }),
        experienceToNextLevel: 1000 * Math.pow(1.2, level - 1),
        rank: {
          current: ranks[currentRankIndex],
          history: rankHistory.sort((a, b) => a.achievedAt.getTime() - b.achievedAt.getTime()),
        },
        unlocks: {
          items: [],
          achievements: [],
          powerUps: [],
        },
      });
    }

    return this.playerProgressModel.insertMany(progressRecords) as Promise<PlayerProgressDocument[]>;
  }
}

================
File: src/database/seeders/player-progress.seeder.ts.meta
================
fileFormatVersion: 2
guid: ac50ea2ecb69f49e18d65f5b9c8d0964
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/seed.ts
================
import { NestFactory } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { Module } from '@nestjs/common';
import { User, UserSchema } from '../../user/schemas/user.schema';
import { Leaderboard, LeaderboardSchema } from '../../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from '../../leaderboard/schemas/game-session.schema';
import { InventoryItem, InventoryItemSchema } from '../../inventory/schemas/inventory-item.schema';
import { UserInventory, UserInventorySchema } from '../../inventory/schemas/user-inventory.schema';
import { DailyMission, DailyMissionSchema } from '../../daily-missions/schemas/daily-mission.schema';
import { PlayerProgress, PlayerProgressSchema } from '../../player-progress/schemas/player-progress.schema';
import { UserSeeder } from './user.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { InventorySeeder } from './inventory.seeder';
import { DailyMissionSeeder } from './daily-mission.seeder';
import { PlayerProgressSeeder } from './player-progress.seeder';

@Module({
  imports: [
    ConfigModule.forRoot(),
    MongooseModule.forRoot(process.env.MONGODB_URI),
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
      { name: InventoryItem.name, schema: InventoryItemSchema },
      { name: UserInventory.name, schema: UserInventorySchema },
      { name: DailyMission.name, schema: DailyMissionSchema },
      { name: PlayerProgress.name, schema: PlayerProgressSchema },
    ]),
  ],
  providers: [
    UserSeeder,
    LeaderboardSeeder,
    InventorySeeder,
    DailyMissionSeeder,
    PlayerProgressSeeder,
  ],
})
class SeedModule {}

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);

  const userSeeder = app.get(UserSeeder);
  const leaderboardSeeder = app.get(LeaderboardSeeder);
  const inventorySeeder = app.get(InventorySeeder);
  const dailyMissionSeeder = app.get(DailyMissionSeeder);
  const playerProgressSeeder = app.get(PlayerProgressSeeder);

  try {
    console.log(' Starting database seeding...');

    // Create users first as other entities depend on them
    console.log('Seeding users...');
    const users = await userSeeder.seed();
    console.log(' Users seeded successfully');

    // Create missions before mission progress
    console.log('Seeding daily missions...');
    const missions = await dailyMissionSeeder.seed();
    console.log(' Daily missions seeded successfully');

    // Seed other collections in parallel
    await Promise.all([
      (async () => {
        console.log('Seeding leaderboards...');
        await leaderboardSeeder.seed(users);
        console.log(' Leaderboards seeded successfully');
      })(),
      (async () => {
        console.log('Seeding inventory items...');
        await inventorySeeder.seed(users);
        console.log(' Inventory seeded successfully');
      })(),
      (async () => {
        console.log('Seeding player progress...');
        await playerProgressSeeder.seed(users);
        console.log(' Player progress seeded successfully');
      })(),
    ]);

    console.log(' Database seeding completed successfully!');
  } catch (error) {
    console.error(' Database seeding failed:', error);
    throw error;
  } finally {
    await app.close();
  }
}

bootstrap();

================
File: src/database/seeders/seed.ts.meta
================
fileFormatVersion: 2
guid: 16f147d4af8eb4cdc96c8a905675af14
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/seeder.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { Test } from '@nestjs/testing';
import { UserSeeder } from './user.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { InventorySeeder } from './inventory.seeder';
import { DailyMissionSeeder } from './daily-mission.seeder';
import { PlayerProgressSeeder } from './player-progress.seeder';

@Injectable()
export class Seeder {
  constructor(private readonly configService: ConfigService) {}

  async seed() {
    const moduleRef = await Test.createTestingModule({
      imports: [
        MongooseModule.forRootAsync({
          useFactory: () => ({
            uri: this.configService.get<string>('MONGODB_URI'),
          }),
          inject: [ConfigService],
        }),
      ],
      providers: [
        UserSeeder,
        LeaderboardSeeder,
        InventorySeeder,
        DailyMissionSeeder,
        PlayerProgressSeeder,
      ],
    }).compile();

    const userSeeder = moduleRef.get(UserSeeder);
    const leaderboardSeeder = moduleRef.get(LeaderboardSeeder);
    const inventorySeeder = moduleRef.get(InventorySeeder);
    const dailyMissionSeeder = moduleRef.get(DailyMissionSeeder);
    const playerProgressSeeder = moduleRef.get(PlayerProgressSeeder);

    try {
      console.log(' Starting database seeding...');

      // Create users first as other entities depend on them
      console.log('Seeding users...');
      const users = await userSeeder.seed();
      console.log(' Users seeded successfully');

      // Seed other collections in parallel
      await Promise.all([
        (async () => {
          console.log('Seeding leaderboards...');
          await leaderboardSeeder.seed(users);
          console.log(' Leaderboards seeded successfully');
        })(),
        (async () => {
          console.log('Seeding inventory items...');
          await inventorySeeder.seed(users);
          console.log(' Inventory seeded successfully');
        })(),
        (async () => {
          console.log('Seeding daily missions...');
          await dailyMissionSeeder.seed();
          console.log(' Daily missions seeded successfully');
        })(),
        (async () => {
          console.log('Seeding player progress...');
          await playerProgressSeeder.seed(users);
          console.log(' Player progress seeded successfully');
        })(),
      ]);

      console.log(' Database seeding completed successfully!');
    } catch (error) {
      console.error(' Database seeding failed:', error);
      throw error;
    }
  }
}

================
File: src/database/seeders/seeder.ts.meta
================
fileFormatVersion: 2
guid: 0c5e1ac9e4a9340ac9d862030200dcaf
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/user-mission-progress.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { UserMissionProgress, UserMissionProgressDocument } from '../../daily-missions/schemas/user-mission-progress.schema';
import { DailyMission, DailyMissionDocument } from '../../daily-missions/schemas/daily-mission.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class UserMissionProgressSeeder {
  constructor(
    @InjectModel(UserMissionProgress.name)
    private readonly userMissionProgressModel: Model<UserMissionProgressDocument>,
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
  ) {}

  async seed(users: UserDocument[]): Promise<UserMissionProgressDocument[]> {
    // Clear existing progress
    await this.userMissionProgressModel.deleteMany({});

    // Get all active missions
    const missions = await this.dailyMissionModel.find({ isActive: true });
    if (!missions.length) {
      console.log('No active missions found to create progress for');
      return [];
    }

    const progressRecords: Partial<UserMissionProgress>[] = [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Create progress records for each user
    for (const user of users) {
      // Randomly select 1-3 missions for each user
      const userMissions = faker.helpers.arrayElements(
        missions,
        faker.number.int({ min: 1, max: 3 })
      );

      for (const mission of userMissions) {
        const progress = faker.number.int({ min: 0, max: mission.target });
        const isCompleted = progress >= mission.target;

        progressRecords.push({
          userId: user._id,
          missionId: mission._id,
          progress,
          matchProgresses: mission.matchesRequired 
            ? Array.from({ length: faker.number.int({ min: 0, max: mission.matchesRequired }) }, 
                () => faker.number.int({ min: 0, max: mission.target }))
            : [],
          date: today,
          gameId: GameType.NAIRA_RAID,
          isCompleted,
          rewardClaimed: isCompleted && faker.datatype.boolean(),
        });
      }
    }

    return this.userMissionProgressModel.insertMany(progressRecords) as Promise<UserMissionProgressDocument[]>;
  }
}

================
File: src/database/seeders/user-mission-progress.seeder.ts.meta
================
fileFormatVersion: 2
guid: c1c4643a6b3a944caa02e988482cfc30
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/user.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';
import { User, UserDocument } from '../../user/schemas/user.schema';

@Injectable()
export class UserSeeder {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  async seed(count = 20): Promise<UserDocument[]> {
    // Define the type with required fields
    type CreateUserData = Required<Pick<User, 'firstName' | 'username' | 'email' | 'password'>> &
      Partial<Omit<User, 'firstName' | 'username' | 'email' | 'password' | '_id'>>;

    const users: CreateUserData[] = [];
    const hashedPassword = await bcrypt.hash('password123', 10);

    // Create one admin user with known credentials
    users.push({
      firstName: 'Admin',
      lastName: 'User',
      username: 'admin',
      email: 'admin@nairaraid.com',
      password: hashedPassword,
      isEmailVerified: true,
      points: 1000,
    });

    // Generate random users
    for (let i = 0; i < count - 1; i++) {
      const firstName = faker.person.firstName();
      const lastName = faker.person.lastName();
      
      users.push({
        firstName,
        lastName,
        username: faker.internet.username({ firstName, lastName }).toLowerCase(),
        email: faker.internet.email({ firstName, lastName }).toLowerCase(),
        password: hashedPassword,
        phoneNumber: faker.phone.number(),
        isEmailVerified: faker.datatype.boolean(),
        instagram: faker.internet.username(),
        tiktok: faker.internet.username(),
        points: faker.number.int({ min: 0, max: 10000 }),
      });
    }

    // Clear existing users
    await this.userModel.deleteMany({});

    // Insert new users
    return this.userModel.insertMany(users) as Promise<UserDocument[]>;
  }
}

================
File: src/database/seeders/user.seeder.ts.meta
================
fileFormatVersion: 2
guid: b35da8d99930a472495a02a93558c7cf
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/database.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UserSeeder } from './seeders/user.seeder';
import { LeaderboardSeeder } from './seeders/leaderboard.seeder';
import { DailyMissionsSeeder } from './seeders/daily-missions.seeder';
import { User, UserSchema } from '../user/schemas/user.schema';
import { Leaderboard, LeaderboardSchema } from '../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from '../leaderboard/schemas/game-session.schema';
import { MissionDefinition, MissionDefinitionSchema } from '../daily-missions/schemas/mission-definition.schema';
import { MissionProgress, MissionProgressSchema } from '../daily-missions/schemas/mission-progress.schema';
import { MissionPoints, MissionPointsSchema } from '../daily-missions/schemas/mission-points.schema';
import { EnemyColor, EnemyColorSchema } from '../daily-missions/schemas/enemy-color.schema';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
      { name: MissionDefinition.name, schema: MissionDefinitionSchema },
      { name: MissionProgress.name, schema: MissionProgressSchema },
      { name: MissionPoints.name, schema: MissionPointsSchema },
      { name: EnemyColor.name, schema: EnemyColorSchema },
    ]),
  ],
  providers: [
    UserSeeder,
    LeaderboardSeeder,
    {
      provide: DailyMissionsSeeder,
      useClass: DailyMissionsSeeder,
    },
  ],
  exports: [UserSeeder, LeaderboardSeeder, DailyMissionsSeeder],
})
export class DatabaseModule {}

================
File: src/database/seed.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from '../app.module';
import { DatabaseModule } from './database.module';
import { UserSeeder } from './seeders/user.seeder';
import { LeaderboardSeeder } from './seeders/leaderboard.seeder';
import { DailyMissionsSeeder } from './seeders/daily-missions.seeder';

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule);

  try {
    console.log(' Starting database seeding...');

    // Get all seeders
    const userSeeder = app.get(UserSeeder);
    const dailyMissionsSeeder = app.get(DailyMissionsSeeder);
    const leaderboardSeeder = app.get(LeaderboardSeeder);

    // Seed users first
    console.log('\n Seeding users...');
    const users = await userSeeder.seed();
    console.log(' Users seeded successfully');

    // Seed daily missions before leaderboard
    console.log('\n Seeding daily missions...');
    try {
      const dailyMissionsResult = await dailyMissionsSeeder.seed();
      if (dailyMissionsResult) {
        const { colors, missions } = dailyMissionsResult;
        console.log('\nColors created:', colors.map(c => ({ name: c.name, id: c._id.toString() })));
        console.log('\nMissions created:', missions.map(m => ({ title: m.title, id: m._id.toString() })));
        console.log(' Daily missions seeded successfully');
      } else {
        console.error(' Daily missions seeding failed - no result returned');
      }
    } catch (error) {
      console.error(' Error seeding daily missions:', error);
      throw error;
    }

    // Seed leaderboard data
    console.log('\n Seeding leaderboards...');
    try {
      const leaderboardResult = await leaderboardSeeder.seed(users);
      console.log('Leaderboard created:', JSON.stringify(leaderboardResult, null, 2));
      console.log(' Leaderboards seeded successfully');
    } catch (error) {
      console.error(' Error seeding leaderboards:', error);
      throw error;
    }

    // Verify the seeded data
    console.log('\n Verifying seeded data...');
    try {
      const verifyResult = await dailyMissionsSeeder.seed();
      console.log('Verification complete:', {
        colorsCount: verifyResult.colors.length,
        missionsCount: verifyResult.missions.length
      });
    } catch (error) {
      console.error(' Error verifying seeded data:', error);
      throw error;
    }

    console.log('\n Database seeding completed successfully!');
  } catch (error) {
    console.error('\n Database seeding failed:', error);
    throw error;
  } finally {
    await app.close();
  }
}

bootstrap();

================
File: src/database/seeders.meta
================
fileFormatVersion: 2
guid: 2b76374ec380e40628f6000ff6d0e785
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/interfaces/email-metrics.interface.ts
================
export interface EmailMetrics {
  totalSent: number;
  totalFailed: number;
  averageDeliveryTime: number;
  queueLength?: number;
  lastError?: {
    timestamp: Date;
    error: string;
  };
}

export interface QueueMetrics {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
  processingTime: {
    avg: number;
    min: number;
    max: number;
  };
}

export interface EmailHealthStatus {
  status: 'up' | 'down';
  details: {
    mailer: boolean;
    queue?: boolean;
    lastCheck: Date;
    error?: string;
  };
}

================
File: src/email/interfaces/email-metrics.interface.ts.meta
================
fileFormatVersion: 2
guid: f317e86f37c964dd88a336d9d64b8830
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/achievement-unlocked.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Achievement Unlocked! </title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .achievement {
            background-color: #ffd700;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        .achievement-icon {
            font-size: 48px;
            margin: 10px 0;
        }
        .reward {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Congratulations, {{name}}! </h2>
    
    <div class="achievement">
        <div class="achievement-icon"></div>
        <h3>{{achievementName}}</h3>
        <p>{{achievementDescription}}</p>
    </div>
    
    <div class="reward">
        <h4>Your Rewards:</h4>
        <p>{{rewardDescription}}</p>
        <p>Points Earned: {{points}}</p>
    </div>
    
    <p>Keep up the great work! Want to see your other achievements?</p>
    <a href="{{profileUrl}}" class="button">View Your Profile</a>
    
    <p>Share your achievement:</p>
    <p>
        <a href="{{shareTwitterUrl}}">Twitter</a> |
        <a href="{{shareFacebookUrl}}">Facebook</a> |
        <a href="{{shareInstagramUrl}}">Instagram</a>
    </p>
    
    <div class="footer">
        <p>You received this email because you achieved something awesome in Naira Raid!</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/achievement-unlocked.hbs.meta
================
fileFormatVersion: 2
guid: b16b26dd2181d437dbfeb0f64e27e26f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/reset-password.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Reset Your Password</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #f44336;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Password Reset Request</h2>
    <p>Hello {{name}},</p>
    <p>We received a request to reset your password. Click the button below to create a new password:</p>
    
    <a href="{{resetUrl}}" class="button">Reset Password</a>
    
    <p>Or copy and paste this link in your browser:</p>
    <p>{{resetUrl}}</p>
    
    <p>This password reset link will expire in 1 hour.</p>
    
    <p>If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
    
    <div class="footer">
        <p>This is an automated email, please do not reply.</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/reset-password.hbs.meta
================
fileFormatVersion: 2
guid: 6ff0e0f05a14242319b2570160ee4706
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/verify-email.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Verify Your Email</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Welcome to Naira Raid!</h2>
    <p>Hello {{name}},</p>
    <p>Thank you for registering with Naira Raid. Please verify your email address by clicking the button below:</p>
    
    <a href="{{verificationUrl}}" class="button">Verify Email</a>
    
    <p>Or copy and paste this link in your browser:</p>
    <p>{{verificationUrl}}</p>
    
    <p>This verification link will expire in 24 hours.</p>
    
    <p>If you didn't create an account with Naira Raid, please ignore this email.</p>
    
    <div class="footer">
        <p>This is an automated email, please do not reply.</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/verify-email.hbs.meta
================
fileFormatVersion: 2
guid: e51343393e8c4414380f0880822b7725
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/welcome.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Welcome to Naira Raid!</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .features {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .feature-item {
            margin: 10px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Welcome to Naira Raid! </h2>
    <p>Hello {{name}},</p>
    <p>Thank you for verifying your email! We're excited to have you join our gaming community.</p>
    
    <div class="features">
        <h3>Here's what you can do now:</h3>
        <div class="feature-item"> Complete daily missions to earn rewards</div>
        <div class="feature-item"> Compete in leaderboards</div>
        <div class="feature-item"> Collect and use power-ups</div>
        <div class="feature-item"> Track your progress and achievements</div>
    </div>
    
    <p>Ready to start playing?</p>
    <a href="{{gameUrl}}" class="button">Start Playing Now</a>
    
    <p>Need help getting started? Check out our:</p>
    <ul>
        <li><a href="{{tutorialUrl}}">Game Tutorial</a></li>
        <li><a href="{{faqUrl}}">Frequently Asked Questions</a></li>
        <li><a href="{{supportUrl}}">Support Center</a></li>
    </ul>
    
    <div class="footer">
        <p>Follow us on social media:</p>
        <p>
            <a href="{{instagramUrl}}">Instagram</a> |
            <a href="{{tiktokUrl}}">TikTok</a>
        </p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/welcome.hbs.meta
================
fileFormatVersion: 2
guid: ae0be8f49b4d34a239925c094a5db1da
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.controller.ts
================
import { Controller, Get, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { EmailService } from './email.service';
import { EmailHealthIndicator } from './email.health';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { EmailMetrics, QueueMetrics, EmailHealthStatus } from './interfaces/email-metrics.interface';

@ApiTags('email-monitoring')
@Controller('email/monitoring')
@UseGuards(JwtAuthGuard)
export class EmailMonitoringController {
  constructor(
    private readonly emailService: EmailService,
    private readonly healthIndicator: EmailHealthIndicator,
  ) {}

  @Get('metrics')
  @ApiOperation({ summary: 'Get email metrics' })
  @ApiResponse({
    status: 200,
    description: 'Returns email sending metrics',
    type: 'object',
  })
  async getMetrics(): Promise<EmailMetrics> {
    return this.emailService.getMetrics();
  }

  @Get('queue')
  @ApiOperation({ summary: 'Get queue metrics' })
  @ApiResponse({
    status: 200,
    description: 'Returns queue metrics if queue is enabled, null otherwise',
    type: 'object',
  })
  async getQueueMetrics(): Promise<QueueMetrics | null> {
    return this.emailService.getQueueMetrics();
  }

  @Get('health')
  @ApiOperation({ summary: 'Get email service health status' })
  @ApiResponse({
    status: 200,
    description: 'Returns health status of email service components',
    type: 'object',
  })
  async getHealth(): Promise<EmailHealthStatus> {
    return this.healthIndicator.check();
  }
}

================
File: src/email/email.controller.ts.meta
================
fileFormatVersion: 2
guid: 6bc095fc54c4a4f39b89c7554f88fc94
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.health.ts
================
import { Injectable } from '@nestjs/common';
import { EmailService } from './email.service';
import { EmailHealthStatus } from './interfaces/email-metrics.interface';

@Injectable()
export class EmailHealthIndicator {
  private lastStatus: EmailHealthStatus = {
    status: 'up',
    details: {
      mailer: true,
      lastCheck: new Date(),
    },
  };

  constructor(private readonly emailService: EmailService) {}

  async check(): Promise<EmailHealthStatus> {
    try {
      const health = await this.emailService.checkHealth();
      this.lastStatus = {
        status: health.mailer ? 'up' : 'down',
        details: {
          ...health,
          lastCheck: new Date(),
        },
      };
    } catch (error) {
      this.lastStatus = {
        status: 'down',
        details: {
          mailer: false,
          lastCheck: new Date(),
          error: error.message,
        },
      };
    }

    return this.lastStatus;
  }

  getLastStatus(): EmailHealthStatus {
    return this.lastStatus;
  }
}

================
File: src/email/email.health.ts.meta
================
fileFormatVersion: 2
guid: 2a4b8b19bb9c34fce8a9473a0ad7555f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.module.ts
================
import { Module, DynamicModule } from '@nestjs/common';
import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { BullModule } from '@nestjs/bull';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { join } from 'path';
import { EmailService } from './email.service';
import { EmailProcessor } from './email.processor';
import { EmailHealthIndicator } from './email.health';
import { EmailMonitoringController } from './email.controller';

@Module({})
export class EmailModule {
  static register(): DynamicModule {
    return {
      module: EmailModule,
      imports: [
        ConfigModule,
        MailerModule.forRootAsync({
          imports: [ConfigModule],
          useFactory: async (configService: ConfigService) => ({
            transport: {
              host: configService.get('SMTP_HOST'),
              port: configService.get('SMTP_PORT'),
              secure: configService.get('SMTP_SECURE', false),
              auth: {
                user: configService.get('SMTP_USER'),
                pass: configService.get('SMTP_PASSWORD'),
              },
            },
            defaults: {
              from: `"Naira Raid" <${configService.get('SMTP_FROM')}>`,
            },
            template: {
              dir: join(__dirname, 'templates'),
              adapter: new HandlebarsAdapter(),
              options: {
                strict: true,
              },
            },
          }),
          inject: [ConfigService],
        }),
        ...this.getQueueImports(),
      ],
      providers: [
        EmailService,
        EmailHealthIndicator,
        ...(process.env.USE_EMAIL_QUEUE === 'true' ? [EmailProcessor] : []),
      ],
      controllers: [EmailMonitoringController],
      exports: [EmailService, EmailHealthIndicator],
    };
  }

  private static getQueueImports(): DynamicModule[] {
    if (process.env.USE_EMAIL_QUEUE !== 'true') {
      return [];
    }

    return [
      BullModule.forRootAsync({
        imports: [ConfigModule],
        useFactory: async (configService: ConfigService) => ({
          redis: {
            host: configService.get('REDIS_HOST', 'localhost'),
            port: configService.get('REDIS_PORT', 6379),
            password: configService.get('REDIS_PASSWORD'),
          },
        }),
        inject: [ConfigService],
      }),
      BullModule.registerQueue({
        name: 'email',
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 1000,
          },
          removeOnComplete: true,
        },
      }),
    ];
  }
}

================
File: src/email/email.module.ts.meta
================
fileFormatVersion: 2
guid: 0daa6cd946141461bbffe1b0f107151c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.processor.ts
================
import { Process, Processor } from '@nestjs/bull';
import { Logger } from '@nestjs/common';
import { Job } from 'bull';
import { MailerService } from '@nestjs-modules/mailer';

interface EmailJob {
  to: string;
  subject: string;
  template: string;
  context: Record<string, any>;
}

@Processor('email')
export class EmailProcessor {
  private readonly logger = new Logger(EmailProcessor.name);

  constructor(private readonly mailerService: MailerService) {}

  @Process('send')
  async handleSendEmail(job: Job<EmailJob>) {
    this.logger.debug(`Processing email job ${job.id}`);
    const { to, subject, template, context } = job.data;

    try {
      await this.mailerService.sendMail({
        to,
        subject,
        template,
        context: {
          ...context,
          year: new Date().getFullYear(),
        },
      });
      this.logger.debug(`Email job ${job.id} completed successfully`);
    } catch (error) {
      this.logger.error(`Failed to process email job ${job.id}`, error.stack);
      throw error;
    }
  }
}

================
File: src/email/email.processor.ts.meta
================
fileFormatVersion: 2
guid: 24e56fe08da2b491080c082b96fde3f3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.service.ts
================
import { Injectable, Logger, OnModuleInit, Optional } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { MailerService } from '@nestjs-modules/mailer';
import { UserDocument } from '../user/schemas/user.schema';
import { EmailMetrics, QueueMetrics } from './interfaces/email-metrics.interface';

@Injectable()
export class EmailService implements OnModuleInit {
  private readonly logger = new Logger(EmailService.name);
  private useQueue: boolean;
  private queueAvailable: boolean = false;
  private metrics: EmailMetrics = {
    totalSent: 0,
    totalFailed: 0,
    averageDeliveryTime: 0,
  };
  private deliveryTimes: number[] = [];

  constructor(
    @Optional() @InjectQueue('email') private readonly emailQueue: Queue,
    private readonly mailerService: MailerService,
    private readonly configService: ConfigService,
  ) {
    this.useQueue = this.configService.get<boolean>('USE_EMAIL_QUEUE', false);
  }

  async onModuleInit() {
    await this.validateConfiguration();
    if (this.useQueue) {
      await this.checkQueueAvailability();
    }
  }

  private async validateConfiguration() {
    const requiredConfigs = [
      'SMTP_HOST',
      'SMTP_PORT',
      'SMTP_USER',
      'SMTP_PASSWORD',
      'SMTP_FROM',
      'BASE_URL',
    ];

    const missingConfigs = requiredConfigs.filter(
      config => !this.configService.get(config),
    );

    if (missingConfigs.length > 0) {
      throw new Error(
        `Missing required email configurations: ${missingConfigs.join(', ')}`,
      );
    }

    if (this.useQueue) {
      const requiredRedisConfigs = ['REDIS_HOST', 'REDIS_PORT'];
      const missingRedisConfigs = requiredRedisConfigs.filter(
        config => !this.configService.get(config),
      );

      if (missingRedisConfigs.length > 0) {
        throw new Error(
          `Queue is enabled but missing Redis configurations: ${missingRedisConfigs.join(
            ', ',
          )}`,
        );
      }
    }
  }

  private async checkQueueAvailability() {
    try {
      await this.emailQueue.isReady();
      this.queueAvailable = true;
      this.logger.log('Email queue is available and connected');
    } catch (error) {
      this.queueAvailable = false;
      this.logger.warn(
        'Email queue is not available, falling back to direct email sending',
        error.stack,
      );
    }
  }

  private getBaseUrl(): string {
    return this.configService.get<string>('BASE_URL') || 'http://localhost:3000';
  }

  private getSocialUrls() {
    const baseUrl = this.getBaseUrl();
    return {
      instagramUrl: this.configService.get<string>('INSTAGRAM_URL') || 'https://instagram.com/nairaraid',
      tiktokUrl: this.configService.get<string>('TIKTOK_URL') || 'https://tiktok.com/@nairaraid',
      tutorialUrl: `${baseUrl}/tutorial`,
      faqUrl: `${baseUrl}/faq`,
      supportUrl: `${baseUrl}/support`,
      gameUrl: `${baseUrl}/play`,
    };
  }

  async getMetrics(): Promise<EmailMetrics> {
    const metrics = { ...this.metrics };
    if (this.useQueue && this.queueAvailable) {
      metrics.queueLength = await this.emailQueue.count();
    }
    return metrics;
  }

  async getQueueMetrics(): Promise<QueueMetrics | null> {
    if (!this.useQueue || !this.queueAvailable) {
      return null;
    }

    const [waiting, active, completed, failed, delayed] = await Promise.all([
      this.emailQueue.getWaitingCount(),
      this.emailQueue.getActiveCount(),
      this.emailQueue.getCompletedCount(),
      this.emailQueue.getFailedCount(),
      this.emailQueue.getDelayedCount(),
    ]);

    const jobs = await this.emailQueue.getJobs(['completed']);
    const processingTimes = jobs.map(job => job.processedOn! - job.timestamp);

    return {
      waiting,
      active,
      completed,
      failed,
      delayed,
      processingTime: {
        avg: this.calculateAverage(processingTimes),
        min: Math.min(...processingTimes),
        max: Math.max(...processingTimes),
      },
    };
  }

  async checkHealth(): Promise<{ mailer: boolean; queue?: boolean }> {
    const health = {
      mailer: await this.checkMailerHealth(),
    };

    if (this.useQueue) {
      health['queue'] = await this.checkQueueHealth();
    }

    return health;
  }

  private async checkMailerHealth(): Promise<boolean> {
    try {
      // Check if required SMTP configuration is available
      const requiredConfigs = [
        'SMTP_HOST',
        'SMTP_PORT',
        'SMTP_USER',
        'SMTP_PASSWORD',
        'SMTP_FROM'
      ];

      const missingConfigs = requiredConfigs.filter(
        config => !this.configService.get(config),
      );

      if (missingConfigs.length > 0) {
        throw new Error(`Missing SMTP configurations: ${missingConfigs.join(', ')}`);
      }

      return true;
    } catch (error) {
      this.logger.error('Mailer health check failed', error.stack);
      return false;
    }
  }

  private async checkQueueHealth(): Promise<boolean> {
    try {
      await this.emailQueue.isReady();
      return true;
    } catch (error) {
      this.logger.error('Queue health check failed', error.stack);
      return false;
    }
  }

  private calculateAverage(numbers: number[]): number {
    if (numbers.length === 0) return 0;
    return numbers.reduce((a, b) => a + b, 0) / numbers.length;
  }

  private async updateMetrics(startTime: number, success: boolean): Promise<void> {
    if (success) {
      this.metrics.totalSent++;
      const deliveryTime = Date.now() - startTime;
      this.deliveryTimes.push(deliveryTime);
      
      // Keep only last 100 delivery times for average calculation
      if (this.deliveryTimes.length > 100) {
        this.deliveryTimes.shift();
      }
      
      this.metrics.averageDeliveryTime = this.calculateAverage(this.deliveryTimes);
    } else {
      this.metrics.totalFailed++;
    }
  }

  private async sendEmail(options: {
    to: string;
    subject: string;
    template: string;
    context: Record<string, any>;
  }): Promise<void> {
    const startTime = Date.now();
    const emailData = {
      ...options,
      context: {
        ...options.context,
        year: new Date().getFullYear(),
      },
    };

    try {
      if (this.useQueue && this.queueAvailable) {
        await this.emailQueue.add('send', emailData);
        this.logger.debug(`Email queued successfully to: ${options.to}`);
      } else {
        await this.mailerService.sendMail(emailData);
        this.logger.debug(`Email sent directly to: ${options.to}`);
      }
      await this.updateMetrics(startTime, true);
    } catch (error) {
      await this.updateMetrics(startTime, false);
      this.metrics.lastError = {
        timestamp: new Date(),
        error: error.message,
      };
      this.logger.error(
        `Failed to send email to ${options.to}`,
        error.stack,
      );
      throw error;
    }
  }

  async sendVerificationEmail(user: UserDocument, token: string): Promise<void> {
    const verificationUrl = `${this.getBaseUrl()}/auth/verify-email?token=${token}`;

    await this.sendEmail({
      to: user.email,
      subject: 'Verify your email address',
      template: 'verify-email',
      context: {
        name: user.firstName,
        verificationUrl,
      },
    });
  }

  async sendPasswordResetEmail(user: UserDocument, token: string): Promise<void> {
    const resetUrl = `${this.getBaseUrl()}/auth/reset-password?token=${token}`;

    await this.sendEmail({
      to: user.email,
      subject: 'Reset your password',
      template: 'reset-password',
      context: {
        name: user.firstName,
        resetUrl,
      },
    });
  }

  async sendWelcomeEmail(user: UserDocument): Promise<void> {
    await this.sendEmail({
      to: user.email,
      subject: 'Welcome to Naira Raid! ',
      template: 'welcome',
      context: {
        name: user.firstName,
        ...this.getSocialUrls(),
      },
    });
  }

  async sendAchievementEmail(
    user: UserDocument,
    achievement: {
      name: string;
      description: string;
      reward: string;
      points: number;
    },
  ): Promise<void> {
    const baseUrl = this.getBaseUrl();
    const profileUrl = `${baseUrl}/profile/${user._id}`;
    const achievementId = achievement.name.toLowerCase().replace(/\s+/g, '-');

    await this.sendEmail({
      to: user.email,
      subject: `Achievement Unlocked: ${achievement.name} `,
      template: 'achievement-unlocked',
      context: {
        name: user.firstName,
        achievementName: achievement.name,
        achievementDescription: achievement.description,
        rewardDescription: achievement.reward,
        points: achievement.points,
        profileUrl,
        shareTwitterUrl: `https://twitter.com/intent/tweet?text=I just unlocked ${achievement.name} in Naira Raid!&url=${baseUrl}/achievements/${achievementId}`,
        shareFacebookUrl: `https://www.facebook.com/sharer/sharer.php?u=${baseUrl}/achievements/${achievementId}`,
        shareInstagramUrl: `${baseUrl}/achievements/${achievementId}`,
      },
    });
  }
}

================
File: src/email/email.service.ts.meta
================
fileFormatVersion: 2
guid: f6576934b8d3640cdacd5bd2388d038c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/interfaces.meta
================
fileFormatVersion: 2
guid: dc5cb58df8d79476da4d2604d51eb7ff
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates.meta
================
fileFormatVersion: 2
guid: 2127ee099514a41ed967b5574c169df3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto/create-inventory-item.dto.ts
================
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { GameType } from '../../common/types/game.types';

export class CreateInventoryItemDto {
  @IsString()
    name: string;

  @IsString()
    description: string;

  @IsEnum(GameType)
    gameId: string;

  @IsString()
    type: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
    duration?: number;

  @IsOptional()
  @IsNumber()
  @Min(0)
    power?: number;
}

================
File: src/inventory/dto/create-inventory-item.dto.ts.meta
================
fileFormatVersion: 2
guid: f071d2ac4da734bd9b3d37c1fd97d3ab
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto/create-user-inventory.dto.ts
================
import {
  IsDate,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

export class CreateUserInventoryDto {
  @IsString()
    itemId: string;

  @IsNumber()
  @Min(1)
    quantity: number;

  @IsEnum(GameType)
    gameId: string;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
    expiresAt?: Date;
}

================
File: src/inventory/dto/create-user-inventory.dto.ts.meta
================
fileFormatVersion: 2
guid: 02d492e08e9064aedbafaf4986870cd0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas/inventory-item.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type InventoryItemDocument = InventoryItem & Document;

@Schema({ timestamps: true })
export class InventoryItem {
  _id: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true })
  type: string; // e.g., 'power-up', 'weapon', 'currency'

  @Prop()
  duration?: number; // Duration in seconds if applicable

  @Prop()
  power?: number; // Power/strength if applicable

  @Prop({ default: true })
  isActive: boolean;
}

export const InventoryItemSchema = SchemaFactory.createForClass(InventoryItem);

================
File: src/inventory/schemas/inventory-item.schema.ts.meta
================
fileFormatVersion: 2
guid: 087731dc9cb234966b5da59ab45a4834
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas/user-inventory.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';
import { InventoryItem } from './inventory-item.schema';

export type UserInventoryDocument = UserInventory & Document;

@Schema({ timestamps: true })
export class UserInventory {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: InventoryItem.name, required: true })
  itemId: Types.ObjectId | InventoryItem;

  @Prop({ required: true })
  quantity: number;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop()
  expiresAt?: Date;
}

export const UserInventorySchema = SchemaFactory.createForClass(UserInventory);

// Create compound index for unique item per user per game
UserInventorySchema.index({ userId: 1, itemId: 1, gameId: 1 }, { unique: true });

================
File: src/inventory/schemas/user-inventory.schema.ts.meta
================
fileFormatVersion: 2
guid: 118b6c43b9bc64463ae25c383e6c0ada
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto.meta
================
fileFormatVersion: 2
guid: 2c1597886a9f44d26b604ca185b19d98
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryController } from './inventory.controller';

describe('InventoryController', () => {
  let controller: InventoryController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InventoryController],
    }).compile();

    controller = module.get<InventoryController>(InventoryController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/inventory/inventory.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 7d16e9fc98f0441c091b992e274805d4
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { CreateInventoryItemDto } from './dto/create-inventory-item.dto';
import { CreateUserInventoryDto } from './dto/create-user-inventory.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @UseGuards(JwtAuthGuard)
  @Post('items')
  createItem(@Body() createInventoryItemDto: CreateInventoryItemDto) {
    return this.inventoryService.createItem(createInventoryItemDto);
  }

  @Get('items/:gameId')
  findAllItems(
    @Param('gameId') gameId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.inventoryService.findAllItems(gameId, paginationDto);
  }

  @Get('items/detail/:id')
  findItemById(@Param('id') id: string) {
    return this.inventoryService.findItemById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('items/:id')
  updateItem(
    @Param('id') id: string,
    @Body() updateData: Partial<CreateInventoryItemDto>,
  ) {
    return this.inventoryService.updateItem(id, updateData);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('items/:id')
  deleteItem(@Param('id') id: string) {
    return this.inventoryService.deleteItem(id);
  }

  @UseGuards(JwtAuthGuard)
  @Post('user')
  addToUserInventory(
    @Request() req,
    @Body() createUserInventoryDto: CreateUserInventoryDto,
  ) {
    return this.inventoryService.addToUserInventory(
      req.user.userId,
      createUserInventoryDto,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Get('user/:gameId')
  getUserInventory(
    @Request() req,
    @Param('gameId') gameId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.inventoryService.getUserInventory(
      req.user.userId,
      gameId,
      paginationDto,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Post('user/use/:itemId')
  useInventoryItem(
    @Request() req,
    @Param('itemId') itemId: string,
    @Body('quantity') quantity?: number,
  ) {
    return this.inventoryService.useInventoryItem(
      req.user.userId,
      itemId,
      quantity,
    );
  }
}

================
File: src/inventory/inventory.controller.ts.meta
================
fileFormatVersion: 2
guid: 9cefe20e4ef624e95b1984d96efdbfaa
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { InventoryService } from './inventory.service';
import { InventoryController } from './inventory.controller';
import {
  InventoryItem,
  InventoryItemSchema,
} from './schemas/inventory-item.schema';
import {
  UserInventory,
  UserInventorySchema,
} from './schemas/user-inventory.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: InventoryItem.name, schema: InventoryItemSchema },
      { name: UserInventory.name, schema: UserInventorySchema },
    ]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService],
  exports: [InventoryService],
})
export class InventoryModule {}

================
File: src/inventory/inventory.module.ts.meta
================
fileFormatVersion: 2
guid: 0ffdf00569f104ed2b5a8346cec75875
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryService } from './inventory.service';

describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [InventoryService],
    }).compile();

    service = module.get<InventoryService>(InventoryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/inventory/inventory.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 154b3c8280fd542168ed9468980422ab
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.service.ts
================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  InventoryItem,
  InventoryItemDocument,
} from './schemas/inventory-item.schema';
import {
  UserInventory,
  UserInventoryDocument,
} from './schemas/user-inventory.schema';
import { CreateInventoryItemDto } from './dto/create-inventory-item.dto';
import { CreateUserInventoryDto } from './dto/create-user-inventory.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class InventoryService {
  constructor(
    @InjectModel(InventoryItem.name)
    private readonly inventoryItemModel: Model<InventoryItemDocument>,
    @InjectModel(UserInventory.name)
    private readonly userInventoryModel: Model<UserInventoryDocument>,
  ) {}

  async createItem(
    createInventoryItemDto: CreateInventoryItemDto,
  ): Promise<InventoryItemDocument> {
    const item = new this.inventoryItemModel(createInventoryItemDto);
    return item.save();
  }

  async findAllItems(gameId: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      this.inventoryItemModel
        .find({ gameId, isActive: true })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.inventoryItemModel.countDocuments({ gameId, isActive: true }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findItemById(id: string): Promise<InventoryItemDocument> {
    const item = await this.inventoryItemModel.findById(id);
    if (!item) {
      throw new NotFoundException('Inventory item not found');
    }
    return item;
  }

  async updateItem(
    id: string,
    updateData: Partial<CreateInventoryItemDto>,
  ): Promise<InventoryItemDocument> {
    const item = await this.inventoryItemModel.findByIdAndUpdate(
      id,
      updateData,
      {
        new: true,
      },
    );
    if (!item) {
      throw new NotFoundException('Inventory item not found');
    }
    return item;
  }

  async deleteItem(id: string): Promise<void> {
    const result = await this.inventoryItemModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Inventory item not found');
    }
  }

  async addToUserInventory(
    userId: string,
    createUserInventoryDto: CreateUserInventoryDto,
  ): Promise<UserInventoryDocument> {
    const item = await this.findItemById(createUserInventoryDto.itemId);
    if (!item.isActive) {
      throw new BadRequestException('This item is no longer available');
    }

    const existingInventory = await this.userInventoryModel.findOne({
      userId,
      itemId: createUserInventoryDto.itemId,
      gameId: createUserInventoryDto.gameId,
    });

    if (existingInventory) {
      existingInventory.quantity += createUserInventoryDto.quantity;
      if (createUserInventoryDto.expiresAt) {
        existingInventory.expiresAt = createUserInventoryDto.expiresAt;
      }
      return existingInventory.save();
    }

    const userInventory = new this.userInventoryModel({
      userId,
      ...createUserInventoryDto,
    });
    return userInventory.save();
  }

  async getUserInventory(
    userId: string,
    gameId: string,
    paginationDto: PaginationDto,
  ) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      this.userInventoryModel
        .find({
          userId,
          gameId,
          $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
        })
        .populate('itemId')
        .skip(skip)
        .limit(limit)
        .exec(),
      this.userInventoryModel.countDocuments({
        userId,
        gameId,
        $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
      }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async useInventoryItem(
    userId: string,
    itemId: string,
    quantity = 1,
  ): Promise<UserInventoryDocument> {
    const userInventory = await this.userInventoryModel
      .findOne({
        userId,
        itemId,
        $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
      })
      .populate('itemId');

    if (!userInventory) {
      throw new NotFoundException('Item not found in user inventory');
    }

    if (userInventory.quantity < quantity) {
      throw new BadRequestException('Insufficient quantity');
    }

    userInventory.quantity -= quantity;

    if (userInventory.quantity === 0) {
      await userInventory.deleteOne();
      return null;
    }

    return userInventory.save();
  }
}

================
File: src/inventory/inventory.service.ts.meta
================
fileFormatVersion: 2
guid: 92a13350b6dc642d9acaa63c523747c5
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas.meta
================
fileFormatVersion: 2
guid: 54ff6e3c374dc42e9ae096ae4cd35abf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-game-session.dto.ts
================
import { IsEnum, IsNumber, IsObject, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

// Record of colorId -> number of kills
class ColorKillsDto {
  [key: string]: number;
}

class GameStatsDto {
  @IsNumber()
  @Min(0)
  totalKills: number;

  @IsNumber()
  @Min(0)
  cashCollected: number;

  @IsObject()
  colorKills: ColorKillsDto;
}

export class CreateGameSessionDto {
  @IsEnum(GameType)
  gameId: string;

  @IsNumber()
  @Min(0)
  score: number;

  @ValidateNested()
  @Type(() => GameStatsDto)
  @IsObject()
  gameStats: GameStatsDto;
}

================
File: src/leaderboard/dto/create-game-session.dto.ts.meta
================
fileFormatVersion: 2
guid: 98170b60634254913a765deffc4d1d65
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-leaderboard-entry.dto.ts
================
import { IsEnum, IsNumber, IsObject, IsOptional, Min } from 'class-validator';
import { GameType } from '../../common/types/game.types';

export class CreateLeaderboardEntryDto {
  @IsNumber()
  @Min(0)
  score: number;

  @IsNumber()
  @Min(0)
  @IsOptional()
  extraPoints?: number;

  @IsNumber()
  @Min(1)
  seasonNumber: number;

  @IsEnum(GameType)
  gameId: string;

  @IsObject()
  gameStats: {
    totalKills?: number;
    cashCollected?: number;
  };
}

================
File: src/leaderboard/dto/create-leaderboard-entry.dto.ts.meta
================
fileFormatVersion: 2
guid: 64d427310842741789c7a4b7f14ee156
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-leaderboard.dto.ts
================
import { IsDate, IsEnum, IsNumber, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

export class CreateLeaderboardDto {
  @IsNumber()
  @Min(1)
  seasonNumber: number;

  @Type(() => Date)
  @IsDate()
  seasonStart: Date;

  @Type(() => Date)
  @IsDate()
  seasonEnd: Date;

  @IsEnum(GameType)
  gameId: string;
}

================
File: src/leaderboard/dto/create-leaderboard.dto.ts.meta
================
fileFormatVersion: 2
guid: a5d83126aa4f2421da954f1eb466236c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/game-session.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

export type GameSessionDocument = GameSession & Document;

@Schema({ timestamps: true })
export class GameSession {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true })
  score: number;

  @Prop({ type: Object, required: true })
  gameStats: {
    totalKills: number;
    cashCollected: number;
    colorKills: { [colorId: string]: number };
  };

  @Prop({ default: true })
  isCompleted: boolean;
}

export const GameSessionSchema = SchemaFactory.createForClass(GameSession);

================
File: src/leaderboard/schemas/game-session.schema.ts.meta
================
fileFormatVersion: 2
guid: d9fa05f7d6123475aaede0092bc342cb
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/leaderboard-entry.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { Leaderboard } from './leaderboard.schema';
import { GameType } from '../../common/types/game.types';

export type LeaderboardEntryDocument = LeaderboardEntry & Document;

@Schema({ timestamps: true })
export class LeaderboardEntry {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'Leaderboard', required: true })
  leaderboardId: Leaderboard;

  @Prop({ required: true })
  score: number;

  @Prop({ default: 0 })
  extraPoints: number;

  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ type: Object })
  gameStats: {
    totalKills?: number;
    cashCollected?: number;
  };
}

export const LeaderboardEntrySchema = SchemaFactory.createForClass(LeaderboardEntry);

// Create compound index for unique entries per user per leaderboard
LeaderboardEntrySchema.index({ userId: 1, leaderboardId: 1 }, { unique: true });

================
File: src/leaderboard/schemas/leaderboard-entry.schema.ts.meta
================
fileFormatVersion: 2
guid: acc6dfe0b86444395afe196db610b623
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/leaderboard.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type LeaderboardDocument = Leaderboard & Document;

@Schema({ timestamps: true })
export class Leaderboard {
  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true })
  seasonStart: Date;

  @Prop({ required: true })
  seasonEnd: Date;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ default: true })
  isActive: boolean;
}

export const LeaderboardSchema = SchemaFactory.createForClass(Leaderboard);

================
File: src/leaderboard/schemas/leaderboard.schema.ts.meta
================
fileFormatVersion: 2
guid: bfb39edd798e2422790f667ce6052c5b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto.meta
================
fileFormatVersion: 2
guid: a3881637009d84c91ab8ae08f04e49a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { LeaderboardController } from './leaderboard.controller';

describe('LeaderboardController', () => {
  let controller: LeaderboardController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [LeaderboardController],
    }).compile();

    controller = module.get<LeaderboardController>(LeaderboardController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/leaderboard/leaderboard.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 0bfc5ba95cad94c4f8389299e410ce1c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  DefaultValuePipe,
  ParseIntPipe,
  BadRequestException,
} from '@nestjs/common';
import { LeaderboardService } from './leaderboard.service';
import { CreateLeaderboardDto } from './dto/create-leaderboard.dto';
import { CreateGameSessionDto } from './dto/create-game-session.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiOperation, ApiQuery, ApiResponse, ApiTags } from '@nestjs/swagger';

@ApiTags('leaderboard')
@Controller('leaderboard')
export class LeaderboardController {
  constructor(private readonly leaderboardService: LeaderboardService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  createLeaderboard(@Body() createLeaderboardDto: CreateLeaderboardDto) {
    return this.leaderboardService.createLeaderboard(createLeaderboardDto);
  }

  @Get('current/:gameId')
  getCurrentLeaderboard(@Param('gameId') gameId: string) {
    return this.leaderboardService.getCurrentLeaderboard(gameId);
  }

  @Get('top')
  @ApiOperation({ summary: 'Get top players from the current leaderboard' })
  @ApiQuery({ name: 'gameId', required: true, description: 'Game identifier' })
  @ApiQuery({ name: 'limit', required: false, description: 'Number of players to return (default: 10)' })
  @ApiResponse({
    status: 200,
    description: 'Returns the top players with their position, username, and score',
  })
  getTopPlayers(
    @Query('gameId') gameId: string,
    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number,
  ) {
    if (!gameId) {
      throw new BadRequestException('gameId is required');
    }
    
    return this.leaderboardService.getTopPlayers(gameId, limit);
  }

  @Get(':leaderboardId/entries')
  getLeaderboardEntries(
    @Param('leaderboardId') leaderboardId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.leaderboardService.getLeaderboardEntries(leaderboardId, paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Post('game-session')
  createGameSession(
    @Request() req,
    @Body() createGameSessionDto: CreateGameSessionDto,
  ) {
    return this.leaderboardService.createGameSession(req.user.userId, createGameSessionDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('player-stats/:gameId')
  getPlayerStats(@Request() req, @Param('gameId') gameId: string) {
    return this.leaderboardService.getPlayerStats(req.user.userId, gameId);
  }
}

================
File: src/leaderboard/leaderboard.controller.ts.meta
================
fileFormatVersion: 2
guid: e90109f122656465aa99ae8d480db37a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.module.ts
================
import { Module, forwardRef } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { LeaderboardService } from './leaderboard.service';
import { LeaderboardController } from './leaderboard.controller';
import { Leaderboard, LeaderboardSchema } from './schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from './schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from './schemas/game-session.schema';
import { DailyMissionsModule } from '../daily-missions/daily-missions.module';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => DailyMissionsModule),
    MongooseModule.forFeature([
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
    ]),
  ],
  controllers: [LeaderboardController],
  providers: [LeaderboardService],
  exports: [LeaderboardService],
})
export class LeaderboardModule {}

================
File: src/leaderboard/leaderboard.module.ts.meta
================
fileFormatVersion: 2
guid: 73b9be81a58b84d818dcbcb327b80ebe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { LeaderboardService } from './leaderboard.service';

describe('LeaderboardService', () => {
  let service: LeaderboardService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [LeaderboardService],
    }).compile();

    service = module.get<LeaderboardService>(LeaderboardService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/leaderboard/leaderboard.service.spec.ts.meta
================
fileFormatVersion: 2
guid: e569a7696b4a54ee688f60363d4ab54d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.service.ts
================
/* eslint-disable max-len */
import { Injectable, NotFoundException, BadRequestException, Inject, forwardRef } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Leaderboard, LeaderboardDocument } from './schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntryDocument } from './schemas/leaderboard-entry.schema';
import { GameSession, GameSessionDocument } from './schemas/game-session.schema';
import { CreateLeaderboardDto } from './dto/create-leaderboard.dto';
import { CreateLeaderboardEntryDto } from './dto/create-leaderboard-entry.dto';
import { CreateGameSessionDto } from './dto/create-game-session.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { DailyMissionsService } from '../daily-missions/services/daily-missions.service';

@Injectable()
export class LeaderboardService {
  constructor(
    @InjectModel(Leaderboard.name)
    private readonly leaderboardModel: Model<LeaderboardDocument>,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
    @InjectModel(GameSession.name)
    private readonly gameSessionModel: Model<GameSessionDocument>,
    @Inject(forwardRef(() => DailyMissionsService))
    private readonly dailyMissionsService: DailyMissionsService,
  ) {}

  async createLeaderboard(createLeaderboardDto: CreateLeaderboardDto): Promise<LeaderboardDocument> {
    const leaderboard = new this.leaderboardModel(createLeaderboardDto);
    return leaderboard.save();
  }

  async getCurrentLeaderboard(gameId: string): Promise<LeaderboardDocument> {
    const leaderboard = await this.leaderboardModel.findOne({
      gameId,
      isActive: true,
      seasonStart: { $lte: new Date() },
      seasonEnd: { $gte: new Date() },
    });

    if (!leaderboard) {
      throw new NotFoundException('No active leaderboard found for this game');
    }

    return leaderboard;
  }

  async getLeaderboardEntries(
    leaderboardId: string,
    paginationDto: PaginationDto,
  ) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    // First aggregate to calculate total scores
    const entries = await this.leaderboardEntryModel
      .aggregate([
        { 
          $match: { 
            leaderboardId: Types.ObjectId.createFromHexString(leaderboardId) 
          } 
        },
        {
          $addFields: {
            totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
          }
        },
        { $sort: { totalScore: -1 } },
        { $skip: skip },
        { $limit: limit },
        {
          $lookup: {
            from: 'users',
            localField: 'userId',
            foreignField: '_id',
            as: 'user'
          }
        },
        { $unwind: '$user' },
        {
          $project: {
            'user.password': 0
          }
        }
      ]);

    const total = await this.leaderboardEntryModel.countDocuments({ leaderboardId });

    return {
      entries,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async createGameSession(userId: string, createGameSessionDto: CreateGameSessionDto): Promise<{
    session: GameSessionDocument;
    position: number;
  }> {
    // Create a new game session
    const session = new this.gameSessionModel({
      userId,
      ...createGameSessionDto,
      isCompleted: true,
    });
    await session.save();

    // Get current leaderboard
    const currentLeaderboard = await this.getCurrentLeaderboard(String(session.gameId));
    
    // Update leaderboard entry if score is higher
    const updatedEntry = await this.updateLeaderboardEntry(String(session.userId), currentLeaderboard._id.toString(), {
      score: session.score,
      gameId: String(session.gameId), 
      seasonNumber: currentLeaderboard.seasonNumber,
      gameStats: session.gameStats,
    });

    // Calculate position using aggregation
    const higherScores = await this.leaderboardEntryModel
      .aggregate([
        {
          $match: {
            leaderboardId: Types.ObjectId.createFromHexString(currentLeaderboard._id.toString())
          }
        },
        {
          $addFields: {
            totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
          }
        },
        {
          $match: {
            totalScore: { $gt: updatedEntry.score + (updatedEntry.extraPoints || 0) }
          }
        },
        {
          $count: 'count'
        }
      ])
      .then(result => (result[0]?.count || 0));

    // Update mission progress
    await this.dailyMissionsService.updateMissionProgress(
      userId,
      String(session.gameId),
      session._id.toString(),
      {
        kills: session.gameStats.totalKills,
        colorKills: session.gameStats.colorKills || {},
      }
    );

    return {
      session,
      position: higherScores + 1
    };
  }

  private async updateLeaderboardEntry(
    userId: string,
    leaderboardId: string | Types.ObjectId,
    data: CreateLeaderboardEntryDto,
  ): Promise<LeaderboardEntryDocument> {
    const existingEntry = await this.leaderboardEntryModel.findOne({
      userId,
      leaderboardId,
    });

    if (!existingEntry) {
      const entry = new this.leaderboardEntryModel({
        userId,
        leaderboardId,
        ...data,
      });
      return entry.save();
    }

    // Only update if new score is higher
    if (data.score > existingEntry.score) {
      existingEntry.score = data.score;
      existingEntry.gameStats = data.gameStats;
      return existingEntry.save();
    }

    return existingEntry;
  }

  /**
   * calculateTotalKills
   * ------------------
   * Calculate total kills across all game sessions for a player
   */
  async calculateTotalKills(userId, gameId) {
    const result = await this.gameSessionModel.aggregate([
      { $match: { userId, gameId, isCompleted: true } },
      { $group: { _id: null, total: { $sum: '$gameStats.totalKills' } } },
    ]);
    return result.length > 0 ? result[0].total : 0;
  }

  /**
   * calculateTotalCash
   * -----------------
   * Calculate total cash collected across all game sessions
   */
  async calculateTotalCash(userId, gameId) {
    const result = await this.gameSessionModel.aggregate([
      { $match: { userId, gameId, isCompleted: true } },
      { $group: { _id: null, total: { $sum: '$gameStats.cashCollected' } } },
    ]);
    return result.length > 0 ? result[0].total : 0;
  }

  /**
   * calculateXP
   * -----------
   * Calculate player's total XP based on lifetime kills
   * XP formula: kills * 10
   */
  private calculateXP(totalKills: number): number {
    return totalKills * 10; // Each kill gives 10 XP
  }

  /**
   * calculateLevel
   * -------------
   * Calculate player's current season level based on kills
   * Level formula: 1 + floor(kills / 100)
   * Every 100 kills = 1 level up, starting from level 1
   */
  private calculateLevel(seasonKills: number): number {
    return 1 + Math.floor(seasonKills / 100); // Every 100 kills = 1 level
  }

  /**
   * getSeasonKills
   * -------------
   * Get total kills for a player in the current season
   */
  private async getSeasonKills(userId: string, leaderboardId: string | Types.ObjectId): Promise<number> {
    const entry = await this.leaderboardEntryModel.findOne({
      userId: new Types.ObjectId(userId),
      leaderboardId: typeof leaderboardId === 'string' ? new Types.ObjectId(leaderboardId) : leaderboardId,
    });

    return entry?.gameStats?.totalKills || 0;
  }

  /**
   * Get player stats for an event
   */
  async getPlayerStats(userId: string, gameId: string) {
    const currentLeaderboard = await this.getCurrentLeaderboard(gameId);
    const entry = await this.leaderboardEntryModel
      .findOne({
        userId,
        leaderboardId: currentLeaderboard._id,
      })
      .populate('userId', '-password');

    // Calculate player rank using aggregation
    const rankResult = await this.leaderboardEntryModel
      .aggregate([
        {
          $match: {
            leaderboardId: Types.ObjectId.createFromHexString(currentLeaderboard._id.toString())
          }
        },
        {
          $addFields: {
            totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
          }
        },
        {
          $sort: { totalScore: -1 }
        },
        {
          $group: {
            _id: null,
            entries: {
              $push: {
                userId: '$userId',
                totalScore: '$totalScore'
              }
            }
          }
        },
        {
          $project: {
            rank: {
              $add: [
                {
                  $indexOfArray: [
                    '$entries.userId',
                    Types.ObjectId.createFromHexString(userId)
                  ]
                },
                1
              ]
            }
          }
        }
      ]);

    const playerRank = rankResult[0]?.rank || 0;

    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);

    const todayEnd = new Date();
    todayEnd.setHours(23, 59, 59, 999);

    const todayGames = await this.gameSessionModel
      .find({
        userId,
        gameId,
        createdAt: { $gte: todayStart, $lte: todayEnd },
        isCompleted: true,
      })
      .sort({ score: -1 });

    // Calculate stats
    const totalKills = await this.calculateTotalKills(userId, gameId);
    const seasonKills = await this.getSeasonKills(
      userId, 
      currentLeaderboard._id.toString()
    );

    const xp = this.calculateXP(totalKills);
    const level = this.calculateLevel(seasonKills);

    return {
      currentSeasonBest: {
        ...entry?.toObject(),
        totalScore: entry ? entry.score + (entry.extraPoints || 0) : 0
      },
      allTimeHighScore: entry ? entry.score + (entry.extraPoints || 0) : 0,
      playerRank,
      todayGames,
      todayBestScore: todayGames[0]?.score || 0,
      gamesPlayedToday: todayGames.length,
      totalGamesPlayed: await this.gameSessionModel.countDocuments({ userId, gameId, isCompleted: true }),
      totalKills,
      totalCashCollected: await this.calculateTotalCash(userId, gameId),
      progression: {
        xp,
        level,
        seasonKills,
        lifetimeKills: totalKills,
        killsToNextLevel: 100 - (seasonKills % 100),
      }
    };
  }

  async getTopPlayers(gameId: string, limit: number = 10) {
    try {
      const currentLeaderboard = await this.getCurrentLeaderboard(gameId);
      
      // Use aggregation to get top players with total score
      const topEntries = await this.leaderboardEntryModel
        .aggregate([
          {
            $match: {
              leaderboardId: Types.ObjectId.createFromHexString(currentLeaderboard._id.toString())
            }
          },
          {
            $addFields: {
              totalScore: { $add: ['$score', { $ifNull: ['$extraPoints', 0] }] }
            }
          },
          {
            $sort: { totalScore: -1 }
          },
          {
            $limit: limit
          },
          {
            $lookup: {
              from: 'users',
              localField: 'userId',
              foreignField: '_id',
              as: 'user'
            }
          },
          {
            $unwind: '$user'
          },
          {
            $project: {
              _id: 1,
              totalScore: 1,
              'user.username': 1
            }
          }
        ]);
      
      if (!topEntries || topEntries.length === 0) {
        return {
          gameId,
          leaderboardId: currentLeaderboard._id,
          seasonNumber: currentLeaderboard.seasonNumber,
          entries: [],
        };
      }
      
      const formattedEntries = topEntries.map((entry, index) => ({
        position: index + 1,
        username: entry.user.username || 'Unknown Player',
        score: entry.totalScore,
      }));
      
      return {
        gameId,
        leaderboardId: currentLeaderboard._id,
        seasonNumber: currentLeaderboard.seasonNumber,
        entries: formattedEntries,
      };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      
      console.error('Error fetching top players:', error);
      throw new BadRequestException('Could not retrieve leaderboard data');
    }
  }
}

================
File: src/leaderboard/leaderboard.service.ts.meta
================
fileFormatVersion: 2
guid: d86e1616d2db5491eb48f2477a276c87
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas.meta
================
fileFormatVersion: 2
guid: 0ae86c7a9db0a4d988fbb67e0df585a0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto/create-player-progress.dto.ts
================
import { IsEnum, IsMongoId, IsNotEmpty, IsNumber, Min } from 'class-validator';
import { GameType } from '../../common/types/game.types';
import { Types } from 'mongoose';

export class CreatePlayerProgressDto {
  @IsNotEmpty()
  @IsMongoId()
  userId: Types.ObjectId;

  @IsNotEmpty()
  @IsEnum(GameType)
  gameId: string;

  @IsNotEmpty()
  @IsNumber()
  @Min(1)
  level: number = 1;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  experience: number = 0;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  experienceToNextLevel: number = 1000; // Default value for level 1

  rank: {
    current: string;
    history: { rank: string; achievedAt: Date }[];
  } = {
    current: 'Rookie',
    history: [{ rank: 'Rookie', achievedAt: new Date() }],
  };

  unlocks: {
    items: Types.ObjectId[];
    achievements: Types.ObjectId[];
    powerUps: Types.ObjectId[];
  } = {
    items: [],
    achievements: [],
    powerUps: [],
  };
}

================
File: src/player-progress/dto/create-player-progress.dto.ts.meta
================
fileFormatVersion: 2
guid: bf77b53ce5cff4915be5aa00ecc6424b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto/update-player-progress.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Types } from 'mongoose';

export class UpdatePlayerProgressDto {
  @IsOptional()
  @IsNumber()
  @Min(0)
  experienceGained?: number;

  @IsOptional()
  unlockedItems?: Types.ObjectId[];

  @IsOptional()
  unlockedAchievements?: Types.ObjectId[];

  @IsOptional()
  unlockedPowerUps?: Types.ObjectId[];
}

================
File: src/player-progress/dto/update-player-progress.dto.ts.meta
================
fileFormatVersion: 2
guid: 91caae7e94a6e4040834d67e2aeadaef
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/schemas/player-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type PlayerProgressDocument = PlayerProgress & Document;

@Schema()
class RankHistory {
  @Prop({ required: true })
  rank: string;

  @Prop({ required: true })
  achievedAt: Date;
}

@Schema()
class Unlocks {
  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  items: Types.ObjectId[];

  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  achievements: Types.ObjectId[];

  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  powerUps: Types.ObjectId[];
}

@Schema({ timestamps: true })
export class PlayerProgress {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true, min: 1 })
  level: number;

  @Prop({ required: true, min: 0 })
  experience: number;

  @Prop({ required: true })
  experienceToNextLevel: number;

  @Prop({
    type: {
      current: { type: String, required: true },
      history: { type: [{ rank: String, achievedAt: Date }], default: [] }
    },
    required: true,
  })
  rank: {
    current: string;
    history: RankHistory[];
  };

  @Prop({ type: () => Unlocks, default: {} })
  unlocks: Unlocks;
}

export const PlayerProgressSchema = SchemaFactory.createForClass(PlayerProgress);

// Create compound index for unique progress per user per game
PlayerProgressSchema.index({ userId: 1, gameId: 1 }, { unique: true });

================
File: src/player-progress/schemas/player-progress.schema.ts.meta
================
fileFormatVersion: 2
guid: d9249f3c5cc1a458bb41b9a14054e829
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto.meta
================
fileFormatVersion: 2
guid: 99be4c58e909e4f988bb205fe09ff327
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Put,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam } from '@nestjs/swagger';
import { Types } from 'mongoose';
import { PlayerProgressService } from './player-progress.service';
import { CreatePlayerProgressDto } from './dto/create-player-progress.dto';
import { UpdatePlayerProgressDto } from './dto/update-player-progress.dto';
import { PlayerProgress } from './schemas/player-progress.schema';

@ApiTags('player-progress')
@Controller('player-progress')
export class PlayerProgressController {
  constructor(private readonly playerProgressService: PlayerProgressService) {}

  @Post()
  @ApiOperation({ summary: 'Create new player progress' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'The player progress has been successfully created.',
    type: PlayerProgress,
  })
  create(@Body() createPlayerProgressDto: CreatePlayerProgressDto) {
    return this.playerProgressService.create(createPlayerProgressDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all player progress records' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns all player progress records',
    type: [PlayerProgress],
  })
  findAll() {
    return this.playerProgressService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get player progress by ID' })
  @ApiParam({ name: 'id', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns the player progress record',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  findOne(@Param('id') id: string) {
    return this.playerProgressService.findOne(new Types.ObjectId(id));
  }

  @Get('user/:userId/game/:gameId')
  @ApiOperation({ summary: 'Get player progress by user ID and game ID' })
  @ApiParam({ name: 'userId', type: String })
  @ApiParam({ name: 'gameId', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns the player progress record',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  findByUserAndGame(
    @Param('userId') userId: string,
    @Param('gameId') gameId: string,
  ) {
    return this.playerProgressService.findByUserAndGame(
      new Types.ObjectId(userId),
      gameId,
    );
  }

  @Put('user/:userId/game/:gameId')
  @ApiOperation({ summary: 'Update player progress' })
  @ApiParam({ name: 'userId', type: String })
  @ApiParam({ name: 'gameId', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The player progress has been successfully updated.',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  update(
    @Param('userId') userId: string,
    @Param('gameId') gameId: string,
    @Body() updatePlayerProgressDto: UpdatePlayerProgressDto,
  ) {
    return this.playerProgressService.updateProgress(
      new Types.ObjectId(userId),
      gameId,
      updatePlayerProgressDto,
    );
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete player progress' })
  @ApiParam({ name: 'id', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The player progress has been successfully deleted.',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  remove(@Param('id') id: string) {
    return this.playerProgressService.remove(new Types.ObjectId(id));
  }
}

================
File: src/player-progress/player-progress.controller.ts.meta
================
fileFormatVersion: 2
guid: bdbe8223e034647129f39e24b12576c0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { PlayerProgressService } from './player-progress.service';
import { PlayerProgressController } from './player-progress.controller';
import { PlayerProgress, PlayerProgressSchema } from './schemas/player-progress.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: PlayerProgress.name, schema: PlayerProgressSchema },
    ]),
  ],
  controllers: [PlayerProgressController],
  providers: [PlayerProgressService],
  exports: [PlayerProgressService],
})
export class PlayerProgressModule {}

================
File: src/player-progress/player-progress.module.ts.meta
================
fileFormatVersion: 2
guid: 321afff1fbbb049a59a59c53373d0ae6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { PlayerProgress, PlayerProgressDocument } from './schemas/player-progress.schema';
import { CreatePlayerProgressDto } from './dto/create-player-progress.dto';
import { UpdatePlayerProgressDto } from './dto/update-player-progress.dto';

@Injectable()
export class PlayerProgressService {
  constructor(
    @InjectModel(PlayerProgress.name)
    private readonly playerProgressModel: Model<PlayerProgressDocument>,
  ) {}

  async create(createPlayerProgressDto: CreatePlayerProgressDto): Promise<PlayerProgress> {
    const createdProgress = new this.playerProgressModel(createPlayerProgressDto);
    return createdProgress.save();
  }

  async findAll(): Promise<PlayerProgress[]> {
    return this.playerProgressModel.find().exec();
  }

  async findOne(id: Types.ObjectId): Promise<PlayerProgress> {
    const progress = await this.playerProgressModel.findById(id).exec();
    if (!progress) {
      throw new NotFoundException(`Player progress with ID ${id} not found`);
    }
    return progress;
  }

  async findByUserAndGame(userId: Types.ObjectId, gameId: string): Promise<PlayerProgress> {
    const progress = await this.playerProgressModel
      .findOne({ userId, gameId })
      .exec();
    if (!progress) {
      throw new NotFoundException(`Progress not found for user ${userId} in game ${gameId}`);
    }
    return progress;
  }

  private calculateExperienceForNextLevel(currentLevel: number): number {
    // Experience required for next level increases by 20% each level
    return Math.floor(1000 * Math.pow(1.2, currentLevel - 1));
  }

  private determineRank(level: number): string {
    if (level >= 50) return 'Legend';
    if (level >= 40) return 'Master';
    if (level >= 30) return 'Expert';
    if (level >= 20) return 'Veteran';
    if (level >= 10) return 'Advanced';
    if (level >= 5) return 'Intermediate';
    return 'Rookie';
  }

  async updateProgress(
    userId: Types.ObjectId,
    gameId: string,
    updateDto: UpdatePlayerProgressDto,
  ): Promise<PlayerProgress> {
    const progress = await this.findByUserAndGame(userId, gameId) as PlayerProgressDocument;
    
    if (updateDto.experienceGained) {
      progress.experience += updateDto.experienceGained;
      
      // Level up logic
      while (progress.experience >= progress.experienceToNextLevel) {
        progress.experience -= progress.experienceToNextLevel;
        progress.level += 1;
        progress.experienceToNextLevel = this.calculateExperienceForNextLevel(progress.level);
        
        // Check for rank change
        const newRank = this.determineRank(progress.level);
        if (newRank !== progress.rank.current) {
          progress.rank.current = newRank;
          progress.rank.history.push({
            rank: newRank,
            achievedAt: new Date(),
          });
        }
      }
    }

    // Update unlocks
    if (updateDto.unlockedItems) {
      progress.unlocks.items.push(...updateDto.unlockedItems);
    }
    if (updateDto.unlockedAchievements) {
      progress.unlocks.achievements.push(...updateDto.unlockedAchievements);
    }
    if (updateDto.unlockedPowerUps) {
      progress.unlocks.powerUps.push(...updateDto.unlockedPowerUps);
    }

    return progress.save();
  }

  async remove(id: Types.ObjectId): Promise<PlayerProgress> {
    const deletedProgress = await this.playerProgressModel
      .findByIdAndDelete(id)
      .exec();
    if (!deletedProgress) {
      throw new NotFoundException(`Player progress with ID ${id} not found`);
    }
    return deletedProgress;
  }
}

================
File: src/player-progress/player-progress.service.ts.meta
================
fileFormatVersion: 2
guid: 41839e7aa62054091ad9108d81a822c9
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/schemas.meta
================
fileFormatVersion: 2
guid: 8809ae8696655420eaa1ac9235cf5d5c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto/create-user.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString, MinLength, IsOptional, IsBoolean } from 'class-validator';

export class CreateUserDto {
  @ApiProperty({
    description: 'User\'s first name',
    example: 'John',
  })
  @IsNotEmpty()
  @IsString()
  firstName: string;

  @ApiProperty({
    description: 'User\'s last name',
    example: 'Doe',
    required: false,
  })
  @IsOptional()
  @IsString()
  lastName?: string;

  @ApiProperty({
    description: 'User\'s unique username',
    example: 'johndoe123',
  })
  @IsNotEmpty()
  @IsString()
  username: string;

  @ApiProperty({
    description: 'User\'s email address',
    example: 'john.doe@example.com',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @ApiProperty({
    description: 'User\'s phone number',
    example: '+1234567890',
    required: false,
  })
  @IsOptional()
  @IsString()
  phoneNumber?: string;

  @ApiProperty({
    description: 'User\'s password (minimum 8 characters)',
    example: 'securePassword123',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  password: string;

  @ApiProperty({
    description: 'Whether the user\'s email is verified',
    example: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isEmailVerified?: boolean = false;

  @ApiProperty({
    description: 'User\'s Instagram handle',
    example: '@johndoe',
    required: false,
  })
  @IsOptional()
  @IsString()
  instagram?: string;

  @ApiProperty({
    description: 'User\'s TikTok handle',
    example: '@johndoe',
    required: false,
  })
  @IsOptional()
  @IsString()
  tiktok?: string;
}

================
File: src/user/dto/create-user.dto.ts.meta
================
fileFormatVersion: 2
guid: e669338af4d1c4bce9e240b78553f869
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto/update-user.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString, MinLength } from 'class-validator';

export class UpdateUserDto {
  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  username?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  @MinLength(8)
  password?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  isEmailVerified?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  instagram?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  tiktok?: string;
}

================
File: src/user/dto/update-user.dto.ts.meta
================
fileFormatVersion: 2
guid: 476c5e65ed366404a8660f052105bd26
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/schemas/user.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type UserDocument = User & Document;

@Schema({ timestamps: true })
export class User {
  _id: Types.ObjectId;

  @Prop({ required: true })
  firstName: string;

  @Prop()
  lastName?: string;

  @Prop({ required: true, unique: true })
  username: string;

  @Prop({ required: true, unique: true })
  email: string;

  @Prop()
  phoneNumber?: string;

  @Prop({ required: true })
  password: string;

  @Prop({ default: false })
  isEmailVerified: boolean;

  @Prop({ unique: true, sparse: true })
  instagram?: string;

  @Prop({ unique: true, sparse: true })
  tiktok?: string;

  @Prop({ default: 0 })
  points: number;
}

export const UserSchema = SchemaFactory.createForClass(User);

================
File: src/user/schemas/user.schema.ts.meta
================
fileFormatVersion: 2
guid: 58b754f15916447e6bf6bc76a3f15b6a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto.meta
================
fileFormatVersion: 2
guid: 2020fc2e5f507496a8ead989b0e59a2b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/schemas.meta
================
fileFormatVersion: 2
guid: 83ef1d1717731417085620f5eb75f6b6
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/user/user.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 18d3a0fcc5015424ab06c3c2330f7f25
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  findAll(@Query() paginationDto: PaginationDto) {
    return this.userService.findAll(paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-email/:email')
  findByEmail(@Param('email') email: string) {
    return this.userService.findByEmail(email);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-username/:username')
  findByUsername(@Param('username') username: string) {
    return this.userService.findByUsername(username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-instagram/:instagram')
  findByInstagram(@Param('instagram') instagram: string) {
    return this.userService.findByInstagram(instagram);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-tiktok/:tiktok')
  findByTiktok(@Param('tiktok') tiktok: string) {
    return this.userService.findByTiktok(tiktok);
  }

  @UseGuards(JwtAuthGuard)
  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(id, updateUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }
}

================
File: src/user/user.controller.ts.meta
================
fileFormatVersion: 2
guid: ffa964cf89c784330a74a957fe915852
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { UserService } from './user.service';
import { UserController } from './user.controller';
import { User, UserSchema } from './schemas/user.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}

================
File: src/user/user.module.ts.meta
================
fileFormatVersion: 2
guid: b8fbb0eb536164ea5a6808afd81e9057
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserService],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/user/user.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 2c0c31d2dfba34f0cb4ecb86b14e8990
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.service.ts
================
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<UserDocument> {
    try {
      const user = new this.userModel(createUserDto);
      return await user.save();
    } catch (error) {
      if (error.code === 11000) {
        throw new ConflictException('User with this email or username already exists');
      }
      throw error;
    }
  }

  async findAll(paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      this.userModel
        .find()
        .select('-password')
        .skip(skip)
        .limit(limit)
        .exec(),
      this.userModel.countDocuments(),
    ]);

    return {
      users,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<UserDocument> {
    const user = await this.userModel.findById(id).select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async findByEmail(email: string): Promise<UserDocument> {
    return this.userModel.findOne({ email });
  }

  async findByUsername(username: string): Promise<UserDocument> {
    return this.userModel.findOne({ username });
  }

  async findByInstagram(instagram: string): Promise<UserDocument> {
    return this.userModel.findOne({ instagram });
  }

  async findByTiktok(tiktok: string): Promise<UserDocument> {
    return this.userModel.findOne({ tiktok });
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<UserDocument> {
    try {
      const user = await this.userModel
        .findByIdAndUpdate(id, updateUserDto, { new: true })
        .select('-password');

      if (!user) {
        throw new NotFoundException('User not found');
      }

      return user;
    } catch (error) {
      if (error.code === 11000) {
        throw new ConflictException('Username or email already exists');
      }
      throw error;
    }
  }

  async remove(id: string): Promise<void> {
    const result = await this.userModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('User not found');
    }
  }
}

================
File: src/user/user.service.ts.meta
================
fileFormatVersion: 2
guid: 7a3443df197db49c6bb9d1455b3d03fe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 50dffc16c43354434b04108d669faf54
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.controller.ts.meta
================
fileFormatVersion: 2
guid: a5e13fdbc6f8f482b90cfd96b1b1cea6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './user/user.module';
import { AuthModule } from './auth/auth.module';
import { LeaderboardModule } from './leaderboard/leaderboard.module';
import { InventoryModule } from './inventory/inventory.module';
import { DailyMissionsModule } from './daily-missions/daily-missions.module';
import { PlayerProgressModule } from './player-progress/player-progress.module';
import { EmailModule } from './email/email.module';
import { BattleRoyaleModule } from './battle-royale/battle-royale.module';
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
      cache: true,
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => {
        const uri = configService.get<string>('MONGODB_URI');
        return {
          uri: uri + '/test',
          useNewUrlParser: true,
          useUnifiedTopology: true,
        };
      },
      inject: [ConfigService],
    }),
    DatabaseModule,
    UserModule,
    AuthModule,
    LeaderboardModule,
    InventoryModule,
    DailyMissionsModule,
    PlayerProgressModule,
    EmailModule.register(),
    BattleRoyaleModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

================
File: src/app.module.ts.meta
================
fileFormatVersion: 2
guid: 74f84fd8938da4c88badc0d9fa3701cd
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/app.service.ts.meta
================
fileFormatVersion: 2
guid: 301ba0b2266b943f9b82fb1e2dd7e3ff
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth.meta
================
fileFormatVersion: 2
guid: f9355d8391d934dcb9e2de2ada98fc92
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common.meta
================
fileFormatVersion: 2
guid: ce0ed22922c66488887da0301cb4302a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/config.meta
================
fileFormatVersion: 2
guid: c549089747ad04b37a4bf6987e5f4ce2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions.meta
================
fileFormatVersion: 2
guid: 1d8c3c567bbe141eb861e37f8a19dd92
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database.meta
================
fileFormatVersion: 2
guid: b248e256102b94680b30b4f70c3260f2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email.meta
================
fileFormatVersion: 2
guid: dc732dcbc628c46da86279de13f68a7b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory.meta
================
fileFormatVersion: 2
guid: 273db835828334faaa8c70ce586c1496
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard.meta
================
fileFormatVersion: 2
guid: 53800c276ea8644e8a5d8133c0174aa3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable validation pipe
  app.useGlobalPipes(new ValidationPipe());

  // Configure Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('Naira Raid API')
    .setDescription('The Naira Raid game API documentation')
    .setVersion('1.0')
    .addTag('player-progress', 'Player progression system')
    .addTag('inventory', 'Inventory management')
    .addTag('daily-missions', 'Daily missions system')
    .addTag('battle-royale', 'Battle Royale mode and multiplayer')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
}
bootstrap();

================
File: src/main.ts.meta
================
fileFormatVersion: 2
guid: d931ecf329c0241c1840581715c5a6e7
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress.meta
================
fileFormatVersion: 2
guid: 9f309d0061bb746da9a752db63683d4e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user.meta
================
fileFormatVersion: 2
guid: 89e8b7fe76d97476eba25ad56612d8e2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/app.e2e-spec.ts.meta
================
fileFormatVersion: 2
guid: 781a12ab5dbd94a46b97d6b4d556848f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: test/jest-e2e.json.meta
================
fileFormatVersion: 2
guid: 0902dd474475e45bf95b9675d8c5b034
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],
    'max-len': ['warn', { code: 100, ignoreStrings: true, ignoreTemplateLiterals: true }],
    'comma-dangle': ['warn', 'always-multiline'],
    'semi': ['warn', 'always'],
    'quotes': ['warn', 'single', { avoidEscape: true }],
    'indent': 'off',
    '@typescript-eslint/indent': 'off',
    'object-curly-spacing': ['warn', 'always'],
    'array-bracket-spacing': ['warn', 'never'],
    'no-multiple-empty-lines': ['warn', { max: 1, maxEOF: 0 }],
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: dist.meta
================
fileFormatVersion: 2
guid: be60e5e6c9a9d4a0da6af1701355393c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: nest-cli.json.meta
================
fileFormatVersion: 2
guid: 4da96a5088a29438fafdbfa83456ab84
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: node_modules.meta
================
fileFormatVersion: 2
guid: 627e38dd8c1984de19677e71ef1897de
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: package-lock.json.meta
================
fileFormatVersion: 2
guid: 5d125b82120ab4128a8b8332a08c6308
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: package.json
================
{
  "name": "naira-raid-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "seed": "ts-node src/database/seeders/seed.ts"
  },
  "dependencies": {
    "@nestjs-modules/mailer": "^2.0.2",
    "@nestjs/bull": "^11.0.2",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/mongoose": "^11.0.1",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "7.1.17",
    "@types/bcrypt": "^5.0.2",
    "@types/bull": "^4.10.4",
    "@types/nodemailer": "^6.4.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/uuid": "^10.0.0",
    "bcrypt": "^5.1.1",
    "bull": "^4.16.5",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "handlebars": "^4.7.8",
    "mongoose": "^8.9.6",
    "nodemailer": "^6.10.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@faker-js/faker": "^9.5.0",
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: package.json.meta
================
fileFormatVersion: 2
guid: e735a2ce24b034aaaa02a914f74d7bbf
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).

================
File: README.md.meta
================
fileFormatVersion: 2
guid: be72004457e5f4d078e12f314b60c914
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src.meta
================
fileFormatVersion: 2
guid: 1c2930681749b4f92b249774b21a6060
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test.meta
================
fileFormatVersion: 2
guid: 5ef0b1c08c4ae4ad99bf790e65d3f998
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.build.json.meta
================
fileFormatVersion: 2
guid: b1ea20d3cc1424b65b795f4a996d8f28
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}

================
File: tsconfig.json.meta
================
fileFormatVersion: 2
guid: 68379272c5fa54e3199241a76503df97
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: dist.meta
================
fileFormatVersion: 2
guid: be60e5e6c9a9d4a0da6af1701355393c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: nest-cli.json.meta
================
fileFormatVersion: 2
guid: 4da96a5088a29438fafdbfa83456ab84
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: node_modules.meta
================
fileFormatVersion: 2
guid: 627e38dd8c1984de19677e71ef1897de
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: package-lock.json.meta
================
fileFormatVersion: 2
guid: 5d125b82120ab4128a8b8332a08c6308
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: package.json
================
{
  "name": "naira-raid-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "seed": "ts-node src/database/seeders/seed.ts"
  },
  "dependencies": {
    "@nestjs-modules/mailer": "^2.0.2",
    "@nestjs/bull": "^11.0.2",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/mongoose": "^11.0.1",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "7.1.17",
    "@types/bcrypt": "^5.0.2",
    "@types/bull": "^4.10.4",
    "@types/nodemailer": "^6.4.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/uuid": "^10.0.0",
    "bcrypt": "^5.1.1",
    "bull": "^4.16.5",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "handlebars": "^4.7.8",
    "mongoose": "^8.9.6",
    "nodemailer": "^6.10.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@faker-js/faker": "^9.5.0",
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: package.json.meta
================
fileFormatVersion: 2
guid: e735a2ce24b034aaaa02a914f74d7bbf
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).

================
File: README.md.meta
================
fileFormatVersion: 2
guid: be72004457e5f4d078e12f314b60c914
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src.meta
================
fileFormatVersion: 2
guid: 1c2930681749b4f92b249774b21a6060
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test.meta
================
fileFormatVersion: 2
guid: 5ef0b1c08c4ae4ad99bf790e65d3f998
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.build.json.meta
================
fileFormatVersion: 2
guid: b1ea20d3cc1424b65b795f4a996d8f28
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}

================
File: tsconfig.json.meta
================
fileFormatVersion: 2
guid: 68379272c5fa54e3199241a76503df97
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
