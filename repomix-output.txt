This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-16T21:18:09.260Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  auth/
    dto/
      login.dto.ts
      login.dto.ts.meta
      refresh-token.dto.ts
      refresh-token.dto.ts.meta
      request-password-reset.dto.ts
      request-password-reset.dto.ts.meta
      reset-password.dto.ts
      reset-password.dto.ts.meta
      verify-email.dto.ts
      verify-email.dto.ts.meta
    guards/
      jwt-auth.guard.ts
      jwt-auth.guard.ts.meta
      local-auth.guard.ts
      local-auth.guard.ts.meta
    strategies/
      jwt.strategy.ts
      jwt.strategy.ts.meta
      local.strategy.ts
      local.strategy.ts.meta
    auth.controller.spec.ts
    auth.controller.spec.ts.meta
    auth.controller.ts
    auth.controller.ts.meta
    auth.module.ts
    auth.module.ts.meta
    auth.service.spec.ts
    auth.service.spec.ts.meta
    auth.service.ts
    auth.service.ts.meta
    dto.meta
    guards.meta
    strategies.meta
  battle-royale/
    dto/
      create-event.dto.ts
      register-player.dto.ts
      update-player.dto.ts
    schemas/
      battle-royale-event.schema.ts
      battle-royale-player.schema.ts
    services/
      battle-royale.service.ts
      udp-server.service.ts
    battle-royale.controller.ts
    battle-royale.module.ts
  common/
    dto/
      pagination.dto.ts
      pagination.dto.ts.meta
    types/
      game.types.ts
      game.types.ts.meta
    dto.meta
    types.meta
  config/
    configuration.ts
    configuration.ts.meta
  daily-missions/
    dto/
      create-daily-mission.dto.ts
      create-daily-mission.dto.ts.meta
    schemas/
      daily-mission.schema.ts
      daily-mission.schema.ts.meta
      user-mission-progress.schema.ts
      user-mission-progress.schema.ts.meta
    daily-missions.controller.spec.ts
    daily-missions.controller.spec.ts.meta
    daily-missions.controller.ts
    daily-missions.controller.ts.meta
    daily-missions.module.ts
    daily-missions.module.ts.meta
    daily-missions.service.spec.ts
    daily-missions.service.spec.ts.meta
    daily-missions.service.ts
    daily-missions.service.ts.meta
    dto.meta
    schemas.meta
  database/
    seeders/
      daily-mission.seeder.ts
      daily-mission.seeder.ts.meta
      inventory.seeder.ts
      inventory.seeder.ts.meta
      leaderboard.seeder.ts
      leaderboard.seeder.ts.meta
      player-progress.seeder.ts
      player-progress.seeder.ts.meta
      seed.ts
      seed.ts.meta
      seeder.ts
      seeder.ts.meta
      user-mission-progress.seeder.ts
      user-mission-progress.seeder.ts.meta
      user.seeder.ts
      user.seeder.ts.meta
    seeders.meta
  email/
    interfaces/
      email-metrics.interface.ts
      email-metrics.interface.ts.meta
    templates/
      achievement-unlocked.hbs
      achievement-unlocked.hbs.meta
      reset-password.hbs
      reset-password.hbs.meta
      verify-email.hbs
      verify-email.hbs.meta
      welcome.hbs
      welcome.hbs.meta
    email.controller.ts
    email.controller.ts.meta
    email.health.ts
    email.health.ts.meta
    email.module.ts
    email.module.ts.meta
    email.processor.ts
    email.processor.ts.meta
    email.service.ts
    email.service.ts.meta
    interfaces.meta
    templates.meta
  inventory/
    dto/
      create-inventory-item.dto.ts
      create-inventory-item.dto.ts.meta
      create-user-inventory.dto.ts
      create-user-inventory.dto.ts.meta
    schemas/
      inventory-item.schema.ts
      inventory-item.schema.ts.meta
      user-inventory.schema.ts
      user-inventory.schema.ts.meta
    dto.meta
    inventory.controller.spec.ts
    inventory.controller.spec.ts.meta
    inventory.controller.ts
    inventory.controller.ts.meta
    inventory.module.ts
    inventory.module.ts.meta
    inventory.service.spec.ts
    inventory.service.spec.ts.meta
    inventory.service.ts
    inventory.service.ts.meta
    schemas.meta
  leaderboard/
    dto/
      create-game-session.dto.ts
      create-game-session.dto.ts.meta
      create-leaderboard-entry.dto.ts
      create-leaderboard-entry.dto.ts.meta
      create-leaderboard.dto.ts
      create-leaderboard.dto.ts.meta
    schemas/
      game-session.schema.ts
      game-session.schema.ts.meta
      leaderboard-entry.schema.ts
      leaderboard-entry.schema.ts.meta
      leaderboard.schema.ts
      leaderboard.schema.ts.meta
    dto.meta
    leaderboard.controller.spec.ts
    leaderboard.controller.spec.ts.meta
    leaderboard.controller.ts
    leaderboard.controller.ts.meta
    leaderboard.module.ts
    leaderboard.module.ts.meta
    leaderboard.service.spec.ts
    leaderboard.service.spec.ts.meta
    leaderboard.service.ts
    leaderboard.service.ts.meta
    schemas.meta
  player-progress/
    dto/
      create-player-progress.dto.ts
      create-player-progress.dto.ts.meta
      update-player-progress.dto.ts
      update-player-progress.dto.ts.meta
    schemas/
      player-progress.schema.ts
      player-progress.schema.ts.meta
    dto.meta
    player-progress.controller.ts
    player-progress.controller.ts.meta
    player-progress.module.ts
    player-progress.module.ts.meta
    player-progress.service.ts
    player-progress.service.ts.meta
    schemas.meta
  user/
    dto/
      create-user.dto.ts
      create-user.dto.ts.meta
      update-user.dto.ts
      update-user.dto.ts.meta
    schemas/
      user.schema.ts
      user.schema.ts.meta
    dto.meta
    schemas.meta
    user.controller.spec.ts
    user.controller.spec.ts.meta
    user.controller.ts
    user.controller.ts.meta
    user.module.ts
    user.module.ts.meta
    user.service.spec.ts
    user.service.spec.ts.meta
    user.service.ts
    user.service.ts.meta
  app.controller.spec.ts
  app.controller.spec.ts.meta
  app.controller.ts
  app.controller.ts.meta
  app.module.ts
  app.module.ts.meta
  app.service.ts
  app.service.ts.meta
  auth.meta
  common.meta
  config.meta
  daily-missions.meta
  database.meta
  email.meta
  inventory.meta
  leaderboard.meta
  main.ts
  main.ts.meta
  player-progress.meta
  user.meta
test/
  app.e2e-spec.ts
  app.e2e-spec.ts.meta
  jest-e2e.json
  jest-e2e.json.meta
.eslintrc.js
.gitignore
.prettierrc
dist.meta
nest-cli.json
nest-cli.json.meta
node_modules.meta
package-lock.json.meta
package.json
package.json.meta
README.md
README.md.meta
src.meta
test.meta
tsconfig.build.json
tsconfig.build.json.meta
tsconfig.json
tsconfig.json.meta

================================================================
Files
================================================================

================
File: src/auth/dto/login.dto.ts
================
import { IsString, IsOptional } from 'class-validator';

export class LoginDto {
  @IsOptional()
  @IsString()
  email?: string;

  @IsOptional()
  @IsString()
  username?: string;

  @IsString()
  password: string;
}

================
File: src/auth/dto/login.dto.ts.meta
================
fileFormatVersion: 2
guid: f8dd0d6823a914dc9a6012109f71b648
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/refresh-token.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class RefreshTokenDto {
  @ApiProperty({
    description: 'Refresh token received during login',
    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  })
  @IsNotEmpty()
  @IsString()
  refreshToken: string;
}

================
File: src/auth/dto/refresh-token.dto.ts.meta
================
fileFormatVersion: 2
guid: 2a912ad6a0f73433d9ff1abf4e72812e
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/request-password-reset.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty } from 'class-validator';

export class RequestPasswordResetDto {
  @ApiProperty({
    description: 'Email address of the user requesting password reset',
    example: 'user@example.com',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;
}

================
File: src/auth/dto/request-password-reset.dto.ts.meta
================
fileFormatVersion: 2
guid: 575958243c9074e3abe37b5c5d033572
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/reset-password.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'Reset token received via email',
    example: 'abc123def456...',
  })
  @IsNotEmpty()
  @IsString()
  token: string;

  @ApiProperty({
    description: 'New password (minimum 8 characters)',
    example: 'newSecurePassword123',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  newPassword: string;
}

================
File: src/auth/dto/reset-password.dto.ts.meta
================
fileFormatVersion: 2
guid: 3322b2f4f9c104104b2fc37197c20b30
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto/verify-email.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class VerifyEmailDto {
  @ApiProperty({
    description: 'Email verification token received via email',
    example: 'abc123def456...',
  })
  @IsNotEmpty()
  @IsString()
  token: string;
}

================
File: src/auth/dto/verify-email.dto.ts.meta
================
fileFormatVersion: 2
guid: 91d03aa6745fe448e9a95d58af2b2314
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards/jwt-auth.guard.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

// Define interfaces for the JWT error types
interface TokenExpiredError extends Error {
  name: string;
  message: string;
  expiredAt: Date;
}

interface JsonWebTokenError extends Error {
  name: string;
  message: string;
}

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  handleRequest(err, user, info) {
    // If there's an error or no user
    if (err || !user) {
      // TokenExpiredError is a specific error from jsonwebtoken package
      if (info instanceof Error && info.name === 'TokenExpiredError') {
        const tokenError = info as TokenExpiredError;
        throw new UnauthorizedException({
          statusCode: 401,
          message: 'Token expired',
          error: 'Unauthorized',
          expiredAt: tokenError.expiredAt,
        });
      }
      
      // JsonWebTokenError is the general JWT error class
      if (info instanceof Error && info.name === 'JsonWebTokenError') {
        throw new UnauthorizedException({
          statusCode: 401,
          message: 'Invalid token',
          error: 'Unauthorized',
        });
      }
      
      // For any other authentication error
      throw err || new UnauthorizedException({
        statusCode: 401,
        message: info?.message || 'Unauthorized access',
        error: 'Unauthorized',
      });
    }
    
    // If all is good, return the user
    return user;
  }
}

================
File: src/auth/guards/jwt-auth.guard.ts.meta
================
fileFormatVersion: 2
guid: 81dc6a6f6458948fb8091c0acd25e17b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards/local-auth.guard.ts
================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}

================
File: src/auth/guards/local-auth.guard.ts.meta
================
fileFormatVersion: 2
guid: 162b22f8578d3485daa6a5f74fd77531
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies/jwt.strategy.ts
================
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined in environment variables');
    }

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}

================
File: src/auth/strategies/jwt.strategy.ts.meta
================
fileFormatVersion: 2
guid: 62fb4f63a197b44e89e5312217b30c8b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies/local.strategy.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      usernameField: 'email',
      passwordField: 'password',
    });
  }

  async validate(email: string, password: string): Promise<any> {
    const user = await this.authService.validateUser({ email, password });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    return user;
  }
}

================
File: src/auth/strategies/local.strategy.ts.meta
================
fileFormatVersion: 2
guid: 98e48d19453e14d72b3033bf0148708f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';

describe('AuthController', () => {
  let controller: AuthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
    }).compile();

    controller = module.get<AuthController>(AuthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/auth/auth.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: ca762a559fbb54c378b73f0e6a0fb828
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.controller.ts
================
import { Controller, Post, Body, UseGuards, Request, HttpStatus } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBody } from '@nestjs/swagger';
import { AuthService } from './auth.service';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { CreateUserDto } from '../user/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { RequestPasswordResetDto } from './dto/request-password-reset.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { VerifyEmailDto } from './dto/verify-email.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';

@ApiTags('auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiBody({ type: CreateUserDto })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'User has been successfully registered.',
  })
  @ApiResponse({
    status: HttpStatus.CONFLICT,
    description: 'User with this email or username already exists.',
  })
  async register(@Body() createUserDto: CreateUserDto) {
    return this.authService.register(createUserDto);
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  @ApiOperation({ summary: 'Login with email/username and password' })
  @ApiBody({ type: LoginDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'User has been successfully logged in.',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Invalid credentials.',
  })
  async login(@Request() req, @Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('request-password-reset')
  @ApiOperation({ summary: 'Request a password reset' })
  @ApiBody({ type: RequestPasswordResetDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Password reset instructions sent to email.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'No user found with this email.',
  })
  async requestPasswordReset(@Body() requestPasswordResetDto: RequestPasswordResetDto) {
    return this.authService.requestPasswordReset(requestPasswordResetDto);
  }

  @Post('reset-password')
  @ApiOperation({ summary: 'Reset password using token' })
  @ApiBody({ type: ResetPasswordDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Password has been successfully reset.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid or expired reset token.',
  })
  async resetPassword(@Body() resetPasswordDto: ResetPasswordDto) {
    return this.authService.resetPassword(resetPasswordDto);
  }

  @Post('verify-email')
  @ApiOperation({ summary: 'Verify email using token' })
  @ApiBody({ type: VerifyEmailDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Email has been successfully verified.',
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: 'Invalid or expired verification token.',
  })
  async verifyEmail(@Body() verifyEmailDto: VerifyEmailDto) {
    return this.authService.verifyEmail(verifyEmailDto);
  }

  @Post('refresh-token')
  @ApiOperation({ summary: 'Get new access token using refresh token' })
  @ApiBody({ type: RefreshTokenDto })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'New access token generated successfully.',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'Invalid or expired refresh token.',
  })
  async refreshToken(@Body() refreshTokenDto: RefreshTokenDto) {
    return this.authService.refreshToken(refreshTokenDto);
  }
}

================
File: src/auth/auth.controller.ts.meta
================
fileFormatVersion: 2
guid: 43582518f5add403ab176a997d7543cd
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UserModule } from '../user/user.module';
import { EmailModule } from '../email/email.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';

@Module({
  imports: [
    UserModule,
    EmailModule.register(),
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN', '1h'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}

================
File: src/auth/auth.module.ts.meta
================
fileFormatVersion: 2
guid: ff0ba45392cfa41d597745905b234ccc
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AuthService],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/auth/auth.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 8f635c6d709d74d2cbdf3354820df03b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/auth.service.ts
================
import { Injectable, UnauthorizedException, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';
import { EmailService } from '../email/email.service';
import { CreateUserDto } from '../user/dto/create-user.dto';
import { LoginDto } from './dto/login.dto';
import { RequestPasswordResetDto } from './dto/request-password-reset.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { VerifyEmailDto } from './dto/verify-email.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';
import * as bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AuthService {
  private readonly resetTokens: Map<string, { email: string; expires: Date }> = new Map();
  private readonly verificationTokens: Map<string, { email: string; expires: Date }> = new Map();
  private readonly refreshTokens: Map<string, { userId: string; expires: Date }> = new Map();

  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly emailService: EmailService,
  ) {}

  async validateUser({ email, password }: { email: string; password: string }) {
    const user = await this.userService.findByEmail(email);
    if (user && await bcrypt.compare(password, user.password)) {
      const { password: _, ...result } = user.toObject();
      return result;
    }
    return null;
  }

  async register(createUserDto: CreateUserDto) {
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    const user = await this.userService.create({
      ...createUserDto,
      password: hashedPassword,
      isEmailVerified: false,
    });

    // Generate email verification token
    const verificationToken = uuidv4();
    this.verificationTokens.set(verificationToken, {
      email: user.email,
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
    });

    // Send verification email
    await this.emailService.sendVerificationEmail(user, verificationToken);

    const { password: _, ...result } = user.toObject();
    return result;
  }

  async login(loginDto: LoginDto) {
    let user;
    if (loginDto.email) {
      user = await this.validateUser({
        email: loginDto.email,
        password: loginDto.password,
      });
    } else if (loginDto.username) {
      const userByUsername = await this.userService.findByUsername(loginDto.username);
      if (userByUsername) {
        user = await this.validateUser({
          email: userByUsername.email,
          password: loginDto.password,
        });
      }
    }

    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { email: user.email, sub: user._id };
    const accessToken = this.jwtService.sign(payload);
    const refreshToken = uuidv4();

    // Store refresh token
    this.refreshTokens.set(refreshToken, {
      userId: user._id.toString(),
      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    });

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      user,
    };
  }

  async requestPasswordReset(requestPasswordResetDto: RequestPasswordResetDto) {
    const user = await this.userService.findByEmail(requestPasswordResetDto.email);
    if (!user) {
      throw new BadRequestException('No user found with this email');
    }

    const resetToken = uuidv4();
    this.resetTokens.set(resetToken, {
      email: user.email,
      expires: new Date(Date.now() + 1 * 60 * 60 * 1000), // 1 hour
    });

    // Send password reset email
    await this.emailService.sendPasswordResetEmail(user, resetToken);

    return { message: 'Password reset instructions sent to your email' };
  }

  async resetPassword(resetPasswordDto: ResetPasswordDto) {
    const tokenData = this.resetTokens.get(resetPasswordDto.token);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new BadRequestException('Invalid or expired reset token');
    }

    const user = await this.userService.findByEmail(tokenData.email);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    const hashedPassword = await bcrypt.hash(resetPasswordDto.newPassword, 10);
    await this.userService.update(user._id.toString(), { password: hashedPassword });

    // Remove used token
    this.resetTokens.delete(resetPasswordDto.token);

    return { message: 'Password successfully reset' };
  }

  async verifyEmail(verifyEmailDto: VerifyEmailDto) {
    const tokenData = this.verificationTokens.get(verifyEmailDto.token);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new BadRequestException('Invalid or expired verification token');
    }

    const user = await this.userService.findByEmail(tokenData.email);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    await this.userService.update(user._id.toString(), { isEmailVerified: true });

    // Remove used token
    this.verificationTokens.delete(verifyEmailDto.token);

    return { message: 'Email successfully verified' };
  }

  async refreshToken(refreshTokenDto: RefreshTokenDto) {
    const tokenData = this.refreshTokens.get(refreshTokenDto.refreshToken);
    if (!tokenData || tokenData.expires < new Date()) {
      throw new UnauthorizedException('Invalid or expired refresh token');
    }

    const user = await this.userService.findById(tokenData.userId);
    if (!user) {
      throw new BadRequestException('User not found');
    }

    const payload = { email: user.email, sub: user._id };
    const accessToken = this.jwtService.sign(payload);
    const newRefreshToken = uuidv4();

    // Store new refresh token and remove old one
    this.refreshTokens.delete(refreshTokenDto.refreshToken);
    this.refreshTokens.set(newRefreshToken, {
      userId: user._id.toString(),
      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    });

    return {
      access_token: accessToken,
      refresh_token: newRefreshToken,
    };
  }
}

================
File: src/auth/auth.service.ts.meta
================
fileFormatVersion: 2
guid: aad8b72a81a814fbfb10554dc4346eef
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/dto.meta
================
fileFormatVersion: 2
guid: 3a6a1fa07a8004cb09bb44aba5484724
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/guards.meta
================
fileFormatVersion: 2
guid: 9f435a64ad8fe429d952f5f5b922a20d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth/strategies.meta
================
fileFormatVersion: 2
guid: 3b24cd2fbd2d949fab03ebad1fabc794
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/battle-royale/dto/create-event.dto.ts
================
import { IsArray, IsBoolean, IsDate, IsNotEmpty, IsNumber, IsOptional, IsPositive, IsString, Max, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class CreateEventDto {
  @IsNotEmpty()
  @IsString()
  title: string;

  @IsNotEmpty()
  @IsString()
  description: string;

  @IsNotEmpty()
  @Type(() => Date)
  @IsDate()
  eventDate: Date;

  @IsNotEmpty()
  @IsString()
  startTime: string; // Format: "HH:MM" (24-hour format)

  @IsNumber()
  @Min(0)
  @IsOptional()
  entryFee: number = 0;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsPositive({ each: true })
  prizePools: number[];

  @IsBoolean()
  @IsOptional()
  isActive: boolean = false;

  @IsNumber()
  @Min(10)
  @Max(1000)
  @IsOptional()
  maxPlayers: number = 100;
}

================
File: src/battle-royale/dto/register-player.dto.ts
================
import { IsMongoId, IsNotEmpty } from 'class-validator';
import { Types } from 'mongoose';

export class RegisterPlayerDto {
  @IsNotEmpty()
  @IsMongoId()
  eventId: Types.ObjectId;
}

================
File: src/battle-royale/dto/update-player.dto.ts
================
import { IsBoolean, IsIn, IsMongoId, IsNotEmpty, IsNumber, IsObject, IsOptional, IsString, Min } from 'class-validator';
import { Types } from 'mongoose';

export class UpdatePlayerDto {
  @IsNotEmpty()
  @IsMongoId()
  eventId: Types.ObjectId;

  @IsOptional()
  @IsString()
  roomId?: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
  position?: number;

  @IsOptional()
  @IsBoolean()
  entryFeePaid?: boolean;

  @IsOptional()
  @IsIn(['registered', 'active', 'eliminated', 'winner'])
  status?: string;

  @IsOptional()
  @IsObject()
  lastPosition?: {
    x: number;
    y: number;
    z: number;
  };

  @IsOptional()
  @IsObject()
  flip?: {
    x: number;
    y: number;
    z: number;
  };

  @IsOptional()
  @IsNumber()
  rotation?: number;

  @IsOptional()
  @IsBoolean()
  isAlive?: boolean;
}

================
File: src/battle-royale/schemas/battle-royale-event.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BattleRoyaleEventDocument = BattleRoyaleEvent & Document;

@Schema({ timestamps: true })
export class BattleRoyaleEvent {
  _id: Types.ObjectId;

  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true })
  eventDate: Date;

  @Prop({ required: true })
  startTime: string; // Format: "HH:MM" in 24-hour format

  @Prop({ default: 0 })
  entryFee: number;

  @Prop({ required: true })
  prizePools: number[];

  @Prop({ default: false })
  isActive: boolean;

  @Prop({ default: 'upcoming' })
  status: string; // 'upcoming', 'active', 'completed'

  @Prop({ default: 100 })
  maxPlayers: number;

  @Prop({ default: [] })
  rooms: string[]; // List of active room IDs for this event
}

export const BattleRoyaleEventSchema = SchemaFactory.createForClass(BattleRoyaleEvent);

================
File: src/battle-royale/schemas/battle-royale-player.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type BattleRoyalePlayerDocument = BattleRoyalePlayer & Document;

@Schema({ timestamps: true })
export class BattleRoyalePlayer {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true })
  username: string;

  @Prop({ type: Types.ObjectId, ref: 'BattleRoyaleEvent', required: true })
  eventId: Types.ObjectId;

  @Prop({ default: null })
  roomId: string;

  @Prop({ default: 0 })
  position: number; // 0 means still alive, 1 is winner, 2 is second place, etc.

  @Prop({ default: false })
  entryFeePaid: boolean;

  @Prop({ default: 'registered' })
  status: string; // 'registered', 'active', 'eliminated', 'winner'

  @Prop({ type: Object, default: { x: 0, y: 0, z: 0 } })
  lastPosition: {
    x: number;
    y: number;
    z: number;
  };

  @Prop({ type: Object, default: { x: 1, y: 1, z: 1 } })
  flip: {
    x: number;
    y: number;
    z: number;
  };

  @Prop({ default: 0 })
  rotation: number;

  @Prop({ default: true })
  isAlive: boolean;
}

export const BattleRoyalePlayerSchema = SchemaFactory.createForClass(BattleRoyalePlayer);

================
File: src/battle-royale/services/battle-royale.service.ts
================
/* eslint-disable max-len */
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { BattleRoyaleEvent, BattleRoyaleEventDocument } from '../schemas/battle-royale-event.schema';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';
import { CreateEventDto } from '../dto/create-event.dto';
import { RegisterPlayerDto } from '../dto/register-player.dto';
import { UpdatePlayerDto } from '../dto/update-player.dto';
import { UserService } from '../../user/user.service';

@Injectable()
export class BattleRoyaleService {
  constructor(
    @InjectModel(BattleRoyaleEvent.name)
    private readonly eventModel: Model<BattleRoyaleEventDocument>,
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
    private readonly userService: UserService,
  ) {}

  /**
   * Create a new Battle Royale event
   */
  async createEvent(createEventDto: CreateEventDto): Promise<BattleRoyaleEventDocument> {
    const event = new this.eventModel(createEventDto);
    return event.save();
  }

  /**
   * Get all events with optional filtering
   */
  async getEvents(status?: string) {
    const query: any = {};
    
    if (status) {
      query.status = status;
    }
    
    return this.eventModel.find(query).sort({ eventDate: 1, startTime: 1 }).exec();
  }

  /**
   * Get the latest upcoming event
   */
  async getLatestUpcomingEvent() {
    const now = new Date();
    
    // Find the next event that's scheduled after now
    const upcomingEvents = await this.eventModel.find({
      eventDate: { $gte: now },
      status: 'upcoming'
    })
    .sort({ eventDate: 1, startTime: 1 })
    .limit(1)
    .exec();
    
    if (upcomingEvents.length === 0) {
      throw new NotFoundException('No upcoming events found');
    }
    
    return upcomingEvents[0];
  }

  /**
   * Get a specific event by ID
   */
  async getEventById(eventId: string): Promise<BattleRoyaleEventDocument> {
    const event = await this.eventModel.findById(eventId).exec();
    
    if (!event) {
      throw new NotFoundException(`Event with ID ${eventId} not found`);
    }
    
    return event;
  }

  /**
   * Register a player for an event
   */
  async registerPlayer(userId: string, registerPlayerDto: RegisterPlayerDto): Promise<BattleRoyalePlayerDocument> {
    const event = await this.getEventById(registerPlayerDto.eventId.toString());
    
    // Check if event is still open for registration
    if (event.status !== 'upcoming') {
      throw new BadRequestException('Registration for this event is closed');
    }
    
    // Convert IDs to strings for consistent comparison
    const userIdString = userId.toString();
    const eventIdString = registerPlayerDto.eventId.toString();
    
    // Check if user is already registered
    const existingRegistration = await this.playerModel.findOne({
      userId: new Types.ObjectId(userIdString),
      eventId: new Types.ObjectId(eventIdString)
    });
    
    if (existingRegistration) {
      throw new BadRequestException('You are already registered for this event');
    }
    
    // Get user details
    const user = await this.userService.findById(userId);
    
    // Create player registration
    const playerData = {
      userId: new Types.ObjectId(userIdString),
      username: user.username,
      eventId: new Types.ObjectId(eventIdString),
      // If there's no entry fee, automatically set as paid
      entryFeePaid: event.entryFee === 0
    };
    
    const player = new this.playerModel(playerData);
    return player.save();
  }

  /**
   * Update player information
   */
  async updatePlayer(userId: string, updatePlayerDto: UpdatePlayerDto): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(updatePlayerDto.eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    if (!player) {
      throw new NotFoundException('Player registration not found');
    }
    
    // Update player fields
    Object.keys(updatePlayerDto).forEach(key => {
      if (key !== 'eventId' && updatePlayerDto[key] !== undefined) {
        player[key] = updatePlayerDto[key];
      }
    });
    
    return player.save();
  }

  /**
   * Get player status for an event
   */
  async getPlayerStatus(userId: string, eventId: string): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    // For debugging - log the query params
    console.log('Looking for player with userId:', userIdObj, 'eventId:', eventIdObj);
    
    if (!player) {
      // Check if there are any registrations for this user to help diagnose
      const allUserRegistrations = await this.playerModel.find({ userId: userIdObj });
      console.log('Found registrations for user:', allUserRegistrations.length);
      
      throw new NotFoundException('Player registration not found');
    }
    
    return player;
  }

  /**
   * Mark player's entry fee as paid
   */
  async markEntryFeePaid(userId: string, eventId: string): Promise<BattleRoyalePlayerDocument> {
    // Convert IDs to ObjectId for MongoDB queries
    const userIdObj = new Types.ObjectId(userId.toString());
    const eventIdObj = new Types.ObjectId(eventId.toString());
    
    const player = await this.playerModel.findOne({
      userId: userIdObj,
      eventId: eventIdObj
    });
    
    if (!player) {
      throw new NotFoundException('Player registration not found');
    }
    
    player.entryFeePaid = true;
    return player.save();
  }

  /**
   * Get all players registered for an event
   */
  async getEventPlayers(eventId: string) {
    return this.playerModel.find({ eventId }).exec();
  }

  /**
   * Get leaderboard for an event (players ordered by position)
   */
  async getEventLeaderboard(eventId: string) {
    const players = await this.playerModel.find({
      eventId,
      status: { $in: ['eliminated', 'winner'] },
      position: { $gt: 0 }
    })
    .sort({ position: 1 })
    .exec();
    
    // Players are sorted by position (1 is winner, 2 is second place, etc.)
    return players;
  }
}

================
File: src/battle-royale/services/udp-server.service.ts
================
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import * as dgram from 'dgram';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BattleRoyalePlayer, BattleRoyalePlayerDocument } from '../schemas/battle-royale-player.schema';

@Injectable()
export class UdpServerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(UdpServerService.name);
  private server: dgram.Socket;
  private players: Record<string, any> = {};
  private readonly UDP_PORT = 41234;

  constructor(
    @InjectModel(BattleRoyalePlayer.name)
    private readonly playerModel: Model<BattleRoyalePlayerDocument>,
  ) {}

  onModuleInit() {
    this.startServer();
  }

  onModuleDestroy() {
    if (this.server) {
      this.server.close();
    }
  }

  private startServer() {
    // Create a UDP socket (IPv4)
    this.server = dgram.createSocket('udp4');

    // When we receive a message (datagram):
    this.server.on('message', (msg, rinfo) => {
      try {
        const data = JSON.parse(msg.toString());
        

        switch (data.type) {
          case 'connect':
            this.handleConnect(data, rinfo);
            break;
          case 'move':
            this.handleMove(data, rinfo);
            break;
          case 'flip':
            this.handleFlip(data, rinfo);
            break;
          case 'rotate':
            this.handleRotate(data, rinfo);
            break;
          case 'attack':
            this.handleAttack(data, rinfo);
            break;
          case 'death':
            this.handleDeath(data, rinfo);
            break;
          default:
            this.logger.warn('Unknown message type:', data.type);
            break;
        }
      } catch (err) {
        this.logger.error('Failed to parse incoming message:', err);
      }
    });

    // Basic error handling
    this.server.on('error', (err) => {
      this.logger.error(`Server error: ${err.stack}`);
      this.server.close();
    });

    // 'listening' event
    this.server.on('listening', () => {
      const address = this.server.address();
      this.logger.log(`UDP Server listening at ${address.address}:${address.port}`);
    });

    // Start listening on UDP port
    this.server.bind(this.UDP_PORT);
  }

  /**
   * Handle a new player connecting.
   */
  private handleConnect(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const roomId = data.roomId || null;
    const eventId = data.eventId || null;

    // If we already know this player, skip re-adding them
    if (!this.players[playerId]) {
      this.players[playerId] = {
        address: rinfo.address,
        port: rinfo.port,
        roomId,
        eventId,
        position: { x: 0, y: 0, z: 0 },
        flip: { x: 1, y: 1, z: 1 },
        rotation: 0,
        isAlive: true
      };
      this.logger.log(`Player connected: ${playerId} from ${rinfo.address}:${rinfo.port}`);

      // Update the player's roomId and status in the database if eventId is provided
      if (eventId && roomId) {
        this.updatePlayerInDatabase(playerId, eventId, roomId);
      }
    }

    // A) Send a "connect_ack" back to this newly connected client
    // including a list of existing players so they can spawn them locally.
    const existingPlayersList = Object.entries(this.players)
      .filter(([pid, info]) => info.roomId === roomId) // Only players in the same room
      .map(([pid, info]: [string, any]) => ({
        playerId: pid,
        position: info.position,
        flip: info.flip,
        rotation: info.rotation,
        isAlive: info.isAlive,
      }));

    this.sendMessage({
      type: 'connect_ack',
      message: 'Welcome to the server!',
      existingPlayers: existingPlayersList,
    }, rinfo.address, rinfo.port);

    console.log('broadcast spawn');

    // B) Broadcast a "spawn" event to all OTHER players that a new player has joined
    this.broadcastExcept({
      type: 'spawn',
      playerId: playerId,
      position: { x: 0, y: 0, z: 0 },
      flip: { x: 1, y: 1, z: 1 },
      rotation: 0,
      isAlive: true
    }, playerId, roomId);
  }

  /**
   * Handle a player's movement update.
   */
  private handleMove(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return; // ignore if not found or dead

    player.position = data.position;

    // Broadcast this movement to all other players in the same room
    this.broadcastExcept({
      type: 'move',
      playerId: playerId,
      position: data.position
    }, playerId, player.roomId);
  }

  /**
   * Handle flipping (scaling) data.
   */
  private handleFlip(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.flip = data.localScale;

    this.broadcastExcept({
      type: 'flip',
      playerId: playerId,
      flip: data.localScale,
    }, playerId, player.roomId);
  }

  /**
   * Handle rotation data.
   */
  private handleRotate(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    player.rotation = data.rotation;

    this.broadcastExcept({
      type: 'rotate',
      playerId: playerId,
      rotation: data.rotation,
    }, playerId, player.roomId);
  }

  /**
   * Handle an attack event.
   */
  private handleAttack(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player || !player.isAlive) return;

    // Broadcast to everyone except the attacker in the same room
    this.broadcastExcept({
      type: 'attack',
      playerId: playerId,
      shootPoint: data.shootPoint || { x: 0, y: 0, z: 0 },
      shootDirection: data.shootDirection || { x: 0, y: 0 }
    }, playerId, player.roomId);
  }

  /**
   * Handle a death event.
   */
  private handleDeath(data: any, rinfo: dgram.RemoteInfo) {
    const playerId = data.playerId;
    const player = this.players[playerId];
    if (!player) return;

    player.isAlive = false;

    // Update player position in database
    if (player.eventId) {
      this.updatePlayerDeathInDatabase(playerId, player.eventId, data.position || 0);
    }

    // Broadcast to everyone except the dead player in the same room
    this.broadcastExcept({
      type: 'death',
      playerId: playerId
    }, playerId, player.roomId);
  }

  /**
   * Broadcast a message to all players in a specific room except the specified playerId.
   */
  private broadcastExcept(msgObj: any, exceptPlayerId: string, roomId: string | null = null) {
    for (const [pid, info] of Object.entries(this.players)) {
      // Skip if it's the excluded player or not in the same room
      if (pid === exceptPlayerId) continue;
      if (roomId && info.roomId !== roomId) continue;

      this.sendMessage(msgObj, info.address, info.port);
    }
  }

  /**
   * Helper function to send a JSON message via UDP.
   */
  private sendMessage(dataObj: any, address: string, port: number) {
    const message = Buffer.from(JSON.stringify(dataObj));
    this.server.send(message, port, address, (err) => {
      if (err) {
        this.logger.error('Failed to send message:', err);
      }
    });
  }

  /**
   * Update player information in the database
   */
  private async updatePlayerInDatabase(playerId: string, eventId: string, roomId: string) {
    try {
      // Find the player by user ID and event ID and update the room ID
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        { 
          roomId, 
          status: 'active',
          isAlive: true,
          position: 0
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} in database:`, error);
    }
  }

  /**
   * Update player death information in the database
   */
  private async updatePlayerDeathInDatabase(playerId: string, eventId: string, position: number) {
    try {
      // Find the player by user ID and event ID and update status and position
      await this.playerModel.findOneAndUpdate(
        { userId: playerId, eventId },
        { 
          status: position === 1 ? 'winner' : 'eliminated',
          isAlive: false,
          position: position,
        }
      );
    } catch (error) {
      this.logger.error(`Failed to update player ${playerId} death in database:`, error);
    }
  }
}

================
File: src/battle-royale/battle-royale.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  Patch,
} from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { BattleRoyaleService } from './services/battle-royale.service';
import { CreateEventDto } from './dto/create-event.dto';
import { RegisterPlayerDto } from './dto/register-player.dto';
import { UpdatePlayerDto } from './dto/update-player.dto';
import { ApiTags, ApiOperation, ApiParam, ApiQuery } from '@nestjs/swagger';

@ApiTags('battle-royale')
@Controller('battle-royale')
export class BattleRoyaleController {
  constructor(private readonly battleRoyaleService: BattleRoyaleService) {}

  @UseGuards(JwtAuthGuard)
  @Post('events')
  @ApiOperation({ summary: 'Create a new Battle Royale event' })
  createEvent(@Body() createEventDto: CreateEventDto) {
    return this.battleRoyaleService.createEvent(createEventDto);
  }

  @Get('events')
  @ApiOperation({ summary: 'Get all Battle Royale events' })
  @ApiQuery({ name: 'status', required: false, description: 'Filter by event status' })
  getEvents(@Query('status') status?: string) {
    return this.battleRoyaleService.getEvents(status);
  }

  @Get('events/upcoming')
  @ApiOperation({ summary: 'Get the latest upcoming Battle Royale event' })
  getLatestUpcomingEvent() {
    return this.battleRoyaleService.getLatestUpcomingEvent();
  }

  @Get('events/:id')
  @ApiOperation({ summary: 'Get a specific Battle Royale event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventById(@Param('id') id: string) {
    return this.battleRoyaleService.getEventById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Post('register')
  @ApiOperation({ summary: 'Register for a Battle Royale event' })
  registerPlayer(@Request() req, @Body() registerPlayerDto: RegisterPlayerDto) {
    return this.battleRoyaleService.registerPlayer(req.user.userId, registerPlayerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('players')
  @ApiOperation({ summary: 'Update player information' })
  updatePlayer(@Request() req, @Body() updatePlayerDto: UpdatePlayerDto) {
    return this.battleRoyaleService.updatePlayer(req.user.userId, updatePlayerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('players/status/:eventId')
  @ApiOperation({ summary: 'Get player status for an event' })
  @ApiParam({ name: 'eventId', description: 'Event ID' })
  getPlayerStatus(@Request() req, @Param('eventId') eventId: string) {
    return this.battleRoyaleService.getPlayerStatus(req.user.userId, eventId);
  }

  @UseGuards(JwtAuthGuard)
  @Post('players/pay-entry-fee/:eventId')
  @ApiOperation({ summary: 'Mark entry fee as paid' })
  @ApiParam({ name: 'eventId', description: 'Event ID' })
  markEntryFeePaid(@Request() req, @Param('eventId') eventId: string) {
    return this.battleRoyaleService.markEntryFeePaid(req.user.userId, eventId);
  }

  @Get('events/:id/players')
  @ApiOperation({ summary: 'Get all players registered for an event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventPlayers(@Param('id') id: string) {
    return this.battleRoyaleService.getEventPlayers(id);
  }

  @Get('events/:id/leaderboard')
  @ApiOperation({ summary: 'Get leaderboard for an event' })
  @ApiParam({ name: 'id', description: 'Event ID' })
  getEventLeaderboard(@Param('id') id: string) {
    return this.battleRoyaleService.getEventLeaderboard(id);
  }
}

================
File: src/battle-royale/battle-royale.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { BattleRoyaleController } from './battle-royale.controller';
import { BattleRoyaleService } from './services/battle-royale.service';
import { UdpServerService } from './services/udp-server.service';
import { BattleRoyaleEvent, BattleRoyaleEventSchema } from './schemas/battle-royale-event.schema';
import { BattleRoyalePlayer, BattleRoyalePlayerSchema } from './schemas/battle-royale-player.schema';
import { UserModule } from '../user/user.module';

@Module({
  imports: [
    ConfigModule,
    UserModule,
    MongooseModule.forFeature([
      { name: BattleRoyaleEvent.name, schema: BattleRoyaleEventSchema },
      { name: BattleRoyalePlayer.name, schema: BattleRoyalePlayerSchema },
    ]),
  ],
  controllers: [BattleRoyaleController],
  providers: [BattleRoyaleService, UdpServerService],
  exports: [BattleRoyaleService],
})
export class BattleRoyaleModule {}

================
File: src/common/dto/pagination.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit?: number = 10;
}

================
File: src/common/dto/pagination.dto.ts.meta
================
fileFormatVersion: 2
guid: 0f585f3fec3db452eb852187c2de10a0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/types/game.types.ts
================
export enum GameType {
  NAIRA_RAID = 'naira-raid',
  // Add other games here as needed
}

export interface GameStats {
  totalKills?: number;
  cashCollected?: number;
  // Add other game-specific stats as needed
}

================
File: src/common/types/game.types.ts.meta
================
fileFormatVersion: 2
guid: 7044129c945044bc1ae79cc6a609f850
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/dto.meta
================
fileFormatVersion: 2
guid: 853f3c6dd8c3d47e9b92cc0463762d89
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common/types.meta
================
fileFormatVersion: 2
guid: aaf2d9b6ba30c4479b3d74cf75894188
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/config/configuration.ts
================


================
File: src/config/configuration.ts.meta
================
fileFormatVersion: 2
guid: c34c915382c4e4ccc8ead4ff1838f2a3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/dto/create-daily-mission.dto.ts
================
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { GameType } from '../../common/types/game.types';
import { MissionType } from '../schemas/daily-mission.schema';

export class CreateDailyMissionDto {
  @IsString()
  name: string;

  @IsString()
  description: string;

  @IsEnum(GameType)
  gameId: string;

  @IsEnum(MissionType)
  type: MissionType;

  @IsNumber()
  @Min(1)
  target: number;

  @IsOptional()
  @IsNumber()
  @Min(1)
  matchesRequired?: number;

  @IsNumber()
  @Min(0)
  rewardPoints: number;
}

================
File: src/daily-missions/dto/create-daily-mission.dto.ts.meta
================
fileFormatVersion: 2
guid: a0e63346d703c470fbc4b0b15cc3a24d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas/daily-mission.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export enum MissionType {
  TOTAL_KILLS = 'total_kills',
  SINGLE_MATCH_KILLS = 'single_match_kills',
  KILLS_IN_MATCHES = 'kills_in_matches'
}

export type DailyMissionDocument = DailyMission & Document;

@Schema({ timestamps: true })
export class DailyMission {
  _id: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true, enum: MissionType })
  type: MissionType;

  @Prop({ required: true })
  target: number;

  @Prop({ required: function(this: DailyMission) {
    return this.type === MissionType.KILLS_IN_MATCHES;
  } })
  matchesRequired?: number;

  @Prop({ required: true })
  rewardPoints: number;

  @Prop({ default: true })
  isActive: boolean;
}

export const DailyMissionSchema = SchemaFactory.createForClass(DailyMission);

================
File: src/daily-missions/schemas/daily-mission.schema.ts.meta
================
fileFormatVersion: 2
guid: e000e147e649a431d8c018afc8ba071a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas/user-mission-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';
import { DailyMission } from './daily-mission.schema';

export type UserMissionProgressDocument = UserMissionProgress & Document;

@Schema({ timestamps: true })
export class UserMissionProgress {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: DailyMission.name, required: true })
  missionId: Types.ObjectId | DailyMission;

  @Prop({ required: true })
  progress: number;

  @Prop({ type: [Number], default: [] })
  matchProgresses: number[]; // For tracking progress in individual matches

  @Prop({ required: true })
  date: Date;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ default: false })
  isCompleted: boolean;

  @Prop({ default: false })
  rewardClaimed: boolean;
}

export const UserMissionProgressSchema = SchemaFactory.createForClass(UserMissionProgress);

// Create compound index for unique mission progress per user per day
UserMissionProgressSchema.index(
  { userId: 1, missionId: 1, date: 1 },
  { unique: true }
);

================
File: src/daily-missions/schemas/user-mission-progress.schema.ts.meta
================
fileFormatVersion: 2
guid: 5fbeeeae2eb9d437eaa357c86f73f04b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { DailyMissionsController } from './daily-missions.controller';

describe('DailyMissionsController', () => {
  let controller: DailyMissionsController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DailyMissionsController],
    }).compile();

    controller = module.get<DailyMissionsController>(DailyMissionsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/daily-missions/daily-missions.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 4eba985d7059f46fa8053dad2f6f3883
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.controller.ts
================
import { Controller } from '@nestjs/common';

@Controller('daily-missions')
export class DailyMissionsController {}

================
File: src/daily-missions/daily-missions.controller.ts.meta
================
fileFormatVersion: 2
guid: 43b666801c3fe4c7b9783f9d8d0a38e3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { DailyMissionsService } from './daily-missions.service';
import { DailyMissionsController } from './daily-missions.controller';
import {
  DailyMission,
  DailyMissionSchema,
} from './schemas/daily-mission.schema';
import {
  UserMissionProgress,
  UserMissionProgressSchema,
} from './schemas/user-mission-progress.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: DailyMission.name, schema: DailyMissionSchema },
      { name: UserMissionProgress.name, schema: UserMissionProgressSchema },
    ]),
  ],
  controllers: [DailyMissionsController],
  providers: [DailyMissionsService],
  exports: [DailyMissionsService],
})
export class DailyMissionsModule {}

================
File: src/daily-missions/daily-missions.module.ts.meta
================
fileFormatVersion: 2
guid: 0c81bdf25d3b54d0b8fe83f8f5dc127b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { DailyMissionsService } from './daily-missions.service';

describe('DailyMissionsService', () => {
  let service: DailyMissionsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DailyMissionsService],
    }).compile();

    service = module.get<DailyMissionsService>(DailyMissionsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/daily-missions/daily-missions.service.spec.ts.meta
================
fileFormatVersion: 2
guid: f0e5d4d2ac74f4900a25d0ec1de78830
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/daily-missions.service.ts
================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  DailyMission,
  DailyMissionDocument,
} from './schemas/daily-mission.schema';
import {
  UserMissionProgress,
  UserMissionProgressDocument,
} from './schemas/user-mission-progress.schema';
import { CreateDailyMissionDto } from './dto/create-daily-mission.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { MissionType } from './schemas/daily-mission.schema';

@Injectable()
export class DailyMissionsService {
  constructor(
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
    @InjectModel(UserMissionProgress.name)
    private readonly userMissionProgressModel: Model<UserMissionProgressDocument>,
  ) {}

  async createMission(
    createDailyMissionDto: CreateDailyMissionDto,
  ): Promise<DailyMissionDocument> {
    const mission = new this.dailyMissionModel(createDailyMissionDto);
    return mission.save();
  }

  async findAllMissions(gameId: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [missions, total] = await Promise.all([
      this.dailyMissionModel
        .find({ gameId, isActive: true })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.dailyMissionModel.countDocuments({ gameId, isActive: true }),
    ]);

    return {
      missions,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getUserMissionProgress(userId: string, gameId: string) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const activeMissions = await this.dailyMissionModel.find({
      gameId,
      isActive: true,
    });

    const userProgress = await this.userMissionProgressModel
      .find({
        userId,
        missionId: { $in: activeMissions.map((m) => m._id) },
        date: {
          $gte: today,
          $lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
        },
      })
      .populate('missionId');

    // Create progress entries for missions that don't have them yet
    const existingMissionIds = userProgress.map((p) => 
      p.missionId._id.toString(),
    );
    const missionsWithoutProgress = activeMissions.filter(
      (m) => !existingMissionIds.includes(m._id.toString()),
    );

    if (missionsWithoutProgress.length > 0) {
      const newProgressEntries = await this.userMissionProgressModel.insertMany(
        missionsWithoutProgress.map((mission) => ({
          userId,
          missionId: mission._id,
          gameId,
          progress: 0,
          matchProgresses: [],
          date: today,
        })),
      );

      userProgress.push(
        ...(await this.userMissionProgressModel
          .find({ _id: { $in: newProgressEntries.map((p) => p._id) } })
          .populate('missionId')),
      );
    }

    return userProgress;
  }

  async updateMissionProgress(
    userId: string,
    gameId: string,
    gameStats: { totalKills: number },
    matchNumber: number,
  ) {
    const userProgress = await this.getUserMissionProgress(userId, gameId);

    const updates = userProgress.map(async (progress) => {
      const mission = progress.missionId as DailyMissionDocument;
      let shouldUpdate = false;
      let newProgress = progress.progress;

      switch (mission.type) {
        case MissionType.TOTAL_KILLS:
          newProgress = progress.progress + gameStats.totalKills;
          shouldUpdate = true;
          break;

        case MissionType.SINGLE_MATCH_KILLS:
          if (gameStats.totalKills > progress.progress) {
            newProgress = gameStats.totalKills;
            shouldUpdate = true;
          }
          break;

        case MissionType.KILLS_IN_MATCHES:
          progress.matchProgresses[matchNumber - 1] = gameStats.totalKills;
          const validMatches = progress.matchProgresses
            .filter((kills) => kills >= mission.target)
            .length;
          newProgress = validMatches;
          shouldUpdate = true;
          break;
      }

      if (shouldUpdate) {
        progress.progress = newProgress;
        progress.isCompleted = newProgress >= mission.target;
        return progress.save();
      }

      return progress;
    });

    return Promise.all(updates);
  }

  async claimReward(userId: string, missionId: string): Promise<number> {
    const progress = await this.userMissionProgressModel
      .findOne({ userId, missionId })
      .populate('missionId');

    if (!progress) {
      throw new NotFoundException('Mission progress not found');
    }

    if (!progress.isCompleted) {
      throw new BadRequestException('Mission not completed');
    }

    if (progress.rewardClaimed) {
      throw new BadRequestException('Reward already claimed');
    }

    progress.rewardClaimed = true;
    await progress.save();

    const mission = progress.missionId as DailyMissionDocument;
    return mission.rewardPoints;
  }
}

================
File: src/daily-missions/daily-missions.service.ts.meta
================
fileFormatVersion: 2
guid: 444557d4d19d645f39aca27235d05cd6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/dto.meta
================
fileFormatVersion: 2
guid: 4e10823e1a09540308108911ed5db7a4
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions/schemas.meta
================
fileFormatVersion: 2
guid: 26b82d9e3a5734c9b8982f2e7fc79e6b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/daily-mission.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { DailyMission, DailyMissionDocument, MissionType } from '../../daily-missions/schemas/daily-mission.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class DailyMissionSeeder {
  constructor(
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
  ) {}

  async seed(): Promise<DailyMissionDocument[]> {
    // Clear existing missions
    await this.dailyMissionModel.deleteMany({});

    const missions: Partial<DailyMission>[] = [];

    // Create missions for each type
    Object.values(MissionType).forEach((type) => {
      const count = faker.number.int({ min: 2, max: 4 }); // 2-4 missions per type
      
      for (let i = 0; i < count; i++) {
        const target = faker.number.int({ min: 5, max: 50 });
        const missionData: Partial<DailyMission> = {
          name: this.generateMissionName(type, target),
          description: this.generateMissionDescription(type, target),
          gameId: GameType.NAIRA_RAID,
          type,
          target,
          rewardPoints: faker.number.int({ min: 100, max: 1000 }),
          isActive: true,
        };

        // Only add matchesRequired for KILLS_IN_MATCHES type
        if (type === MissionType.KILLS_IN_MATCHES) {
          missionData.matchesRequired = faker.number.int({ min: 3, max: 5 });
        }

        missions.push(missionData);
      }
    });

    return this.dailyMissionModel.insertMany(missions) as Promise<DailyMissionDocument[]>;
  }

  private generateMissionName(type: MissionType, target: number): string {
    switch (type) {
      case MissionType.TOTAL_KILLS:
        return `Eliminate ${target} Enemies`;
      case MissionType.SINGLE_MATCH_KILLS:
        return `Get ${target} Kills in One Match`;
      case MissionType.KILLS_IN_MATCHES:
        return `Get ${target} Kills in Multiple Matches`;
      default:
        return `Complete ${target} Objectives`;
    }
  }

  private generateMissionDescription(type: MissionType, target: number): string {
    switch (type) {
      case MissionType.TOTAL_KILLS:
        return `Eliminate a total of ${target} enemies in any number of matches.`;
      case MissionType.SINGLE_MATCH_KILLS:
        return `Eliminate ${target} enemies in a single match.`;
      case MissionType.KILLS_IN_MATCHES:
        return `Get ${target} kills in each of several matches.`;
      default:
        return `Complete ${target} mission objectives.`;
    }
  }
}

================
File: src/database/seeders/daily-mission.seeder.ts.meta
================
fileFormatVersion: 2
guid: 7f76c1a7e7c1047fca7f2ca5303a1eda
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/inventory.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { InventoryItem, InventoryItemDocument } from '../../inventory/schemas/inventory-item.schema';
import { UserInventory, UserInventoryDocument } from '../../inventory/schemas/user-inventory.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class InventorySeeder {
  constructor(
    @InjectModel(InventoryItem.name)
    private readonly inventoryItemModel: Model<InventoryItemDocument>,
    @InjectModel(UserInventory.name)
    private readonly userInventoryModel: Model<UserInventoryDocument>,
  ) {}

  async seed(users: UserDocument[]) {
    // Clear existing data
    await Promise.all([
      this.inventoryItemModel.deleteMany({}),
      this.userInventoryModel.deleteMany({}),
    ]);

    // Create inventory items
    const items = await this.createInventoryItems();

    // Create user inventories
    const userInventories = await this.createUserInventories(users, items);

    return {
      items,
      userInventories,
    };
  }

  private async createInventoryItems(): Promise<InventoryItemDocument[]> {
    const itemTypes = ['power-up', 'weapon', 'currency', 'boost'];
    const items: Partial<InventoryItem>[] = [];

    // Create 20 random items
    for (let i = 0; i < 20; i++) {
      const type = faker.helpers.arrayElement(itemTypes);
      items.push({
        name: faker.commerce.productName(),
        description: faker.commerce.productDescription(),
        gameId: GameType.NAIRA_RAID,
        type,
        duration: type === 'power-up' ? faker.number.int({ min: 30, max: 300 }) : undefined,
        power: type === 'weapon' ? faker.number.int({ min: 1, max: 100 }) : undefined,
        isActive: true,
      });
    }

    return this.inventoryItemModel.insertMany(items) as Promise<InventoryItemDocument[]>;
  }

  private async createUserInventories(
    users: UserDocument[],
    items: InventoryItemDocument[],
  ): Promise<UserInventoryDocument[]> {
    const userInventories: Partial<UserInventory>[] = [];

    for (const user of users) {
      // Give each user 1-5 random items
      const itemCount = faker.number.int({ min: 1, max: 5 });
      const selectedItems = faker.helpers.arrayElements(items, itemCount);

      for (const item of selectedItems) {
        userInventories.push({
          userId: user._id,
          itemId: item._id,
          quantity: faker.number.int({ min: 1, max: 10 }),
          gameId: GameType.NAIRA_RAID,
          expiresAt: faker.helpers.arrayElement([
            undefined,
            faker.date.future(),
          ]),
        });
      }
    }

    return this.userInventoryModel.insertMany(userInventories) as Promise<UserInventoryDocument[]>;
  }
}

================
File: src/database/seeders/inventory.seeder.ts.meta
================
fileFormatVersion: 2
guid: 84afe2f1dc24f42959c73c6424cc8e8a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/leaderboard.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { Leaderboard, LeaderboardDocument } from '../../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntryDocument } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionDocument } from '../../leaderboard/schemas/game-session.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class LeaderboardSeeder {
  constructor(
    @InjectModel(Leaderboard.name)
    private readonly leaderboardModel: Model<LeaderboardDocument>,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
    @InjectModel(GameSession.name)
    private readonly gameSessionModel: Model<GameSessionDocument>,
  ) {}

  async seed(users: UserDocument[]) {
    // Clear existing data
    await Promise.all([
      this.leaderboardModel.deleteMany({}),
      this.leaderboardEntryModel.deleteMany({}),
      this.gameSessionModel.deleteMany({}),
    ]);

    // Create current season leaderboard
    const currentLeaderboard = await this.leaderboardModel.create({
      seasonNumber: 1,
      seasonStart: new Date(),
      seasonEnd: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days from now
      gameId: GameType.NAIRA_RAID,
      isActive: true,
    });

    // Create leaderboard entries and game sessions for each user
    const leaderboardEntries = [];
    const gameSessions = [];

    for (const user of users) {
      // Create 1-5 game sessions per user
      const sessionCount = faker.number.int({ min: 1, max: 5 });
      for (let i = 0; i < sessionCount; i++) {
        const score = faker.number.int({ min: 100, max: 10000 });
        const totalKills = faker.number.int({ min: 5, max: 50 });
        const cashCollected = faker.number.int({ min: 1000, max: 100000 });

        gameSessions.push({
          userId: user._id,
          gameId: GameType.NAIRA_RAID,
          score,
          gameStats: {
            totalKills,
            cashCollected,
          },
          isCompleted: true,
        });
      }

      // Create leaderboard entry with highest score
      const highestScore = Math.max(...gameSessions
        .filter(session => session.userId.toString() === user._id.toString())
        .map(session => session.score));

      leaderboardEntries.push({
        userId: user._id,
        leaderboardId: currentLeaderboard._id,
        score: highestScore,
        extraPoints: faker.number.int({ min: 0, max: 1000 }),
        seasonNumber: currentLeaderboard.seasonNumber,
        gameId: GameType.NAIRA_RAID,
        gameStats: {
          totalKills: faker.number.int({ min: 50, max: 500 }),
          cashCollected: faker.number.int({ min: 10000, max: 1000000 }),
        },
      });
    }

    await Promise.all([
      this.leaderboardEntryModel.insertMany(leaderboardEntries),
      this.gameSessionModel.insertMany(gameSessions),
    ]);

    return {
      leaderboard: currentLeaderboard,
      entries: leaderboardEntries,
      sessions: gameSessions,
    };
  }
}

================
File: src/database/seeders/leaderboard.seeder.ts.meta
================
fileFormatVersion: 2
guid: b12afed1b0e954a1fbe141f9e8af4f8d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/player-progress.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { PlayerProgress, PlayerProgressDocument } from '../../player-progress/schemas/player-progress.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class PlayerProgressSeeder {
  constructor(
    @InjectModel(PlayerProgress.name)
    private readonly playerProgressModel: Model<PlayerProgressDocument>,
  ) {}

  async seed(users: UserDocument[]): Promise<PlayerProgressDocument[]> {
    // Clear existing progress
    await this.playerProgressModel.deleteMany({});

    const progressRecords: Partial<PlayerProgress>[] = [];

    // Create progress for each user
    for (const user of users) {
      const level = faker.number.int({ min: 1, max: 50 });
      const ranks = ['Rookie', 'Intermediate', 'Advanced', 'Veteran', 'Expert', 'Master', 'Legend'];
      const currentRankIndex = Math.min(Math.floor(level / 7), ranks.length - 1);
      
      // Generate rank history
      const rankHistory = [];
      for (let i = 0; i <= currentRankIndex; i++) {
        rankHistory.push({
          rank: ranks[i],
          achievedAt: faker.date.past(),
        });
      }

      progressRecords.push({
        userId: user._id,
        gameId: GameType.NAIRA_RAID,
        level,
        experience: faker.number.int({ min: 0, max: 999 }),
        experienceToNextLevel: 1000 * Math.pow(1.2, level - 1),
        rank: {
          current: ranks[currentRankIndex],
          history: rankHistory.sort((a, b) => a.achievedAt.getTime() - b.achievedAt.getTime()),
        },
        unlocks: {
          items: [],
          achievements: [],
          powerUps: [],
        },
      });
    }

    return this.playerProgressModel.insertMany(progressRecords) as Promise<PlayerProgressDocument[]>;
  }
}

================
File: src/database/seeders/player-progress.seeder.ts.meta
================
fileFormatVersion: 2
guid: ac50ea2ecb69f49e18d65f5b9c8d0964
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/seed.ts
================
import { NestFactory } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { Module } from '@nestjs/common';
import { User, UserSchema } from '../../user/schemas/user.schema';
import { Leaderboard, LeaderboardSchema } from '../../leaderboard/schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from '../../leaderboard/schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from '../../leaderboard/schemas/game-session.schema';
import { InventoryItem, InventoryItemSchema } from '../../inventory/schemas/inventory-item.schema';
import { UserInventory, UserInventorySchema } from '../../inventory/schemas/user-inventory.schema';
import { DailyMission, DailyMissionSchema } from '../../daily-missions/schemas/daily-mission.schema';
import { PlayerProgress, PlayerProgressSchema } from '../../player-progress/schemas/player-progress.schema';
import { UserSeeder } from './user.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { InventorySeeder } from './inventory.seeder';
import { DailyMissionSeeder } from './daily-mission.seeder';
import { PlayerProgressSeeder } from './player-progress.seeder';

@Module({
  imports: [
    ConfigModule.forRoot(),
    MongooseModule.forRoot(process.env.MONGODB_URI),
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
      { name: InventoryItem.name, schema: InventoryItemSchema },
      { name: UserInventory.name, schema: UserInventorySchema },
      { name: DailyMission.name, schema: DailyMissionSchema },
      { name: PlayerProgress.name, schema: PlayerProgressSchema },
    ]),
  ],
  providers: [
    UserSeeder,
    LeaderboardSeeder,
    InventorySeeder,
    DailyMissionSeeder,
    PlayerProgressSeeder,
  ],
})
class SeedModule {}

async function bootstrap() {
  const app = await NestFactory.create(SeedModule);

  const userSeeder = app.get(UserSeeder);
  const leaderboardSeeder = app.get(LeaderboardSeeder);
  const inventorySeeder = app.get(InventorySeeder);
  const dailyMissionSeeder = app.get(DailyMissionSeeder);
  const playerProgressSeeder = app.get(PlayerProgressSeeder);

  try {
    console.log('🌱 Starting database seeding...');

    // Create users first as other entities depend on them
    console.log('Seeding users...');
    const users = await userSeeder.seed();
    console.log('✅ Users seeded successfully');

    // Create missions before mission progress
    console.log('Seeding daily missions...');
    const missions = await dailyMissionSeeder.seed();
    console.log('✅ Daily missions seeded successfully');

    // Seed other collections in parallel
    await Promise.all([
      (async () => {
        console.log('Seeding leaderboards...');
        await leaderboardSeeder.seed(users);
        console.log('✅ Leaderboards seeded successfully');
      })(),
      (async () => {
        console.log('Seeding inventory items...');
        await inventorySeeder.seed(users);
        console.log('✅ Inventory seeded successfully');
      })(),
      (async () => {
        console.log('Seeding player progress...');
        await playerProgressSeeder.seed(users);
        console.log('✅ Player progress seeded successfully');
      })(),
    ]);

    console.log('✨ Database seeding completed successfully!');
  } catch (error) {
    console.error('❌ Database seeding failed:', error);
    throw error;
  } finally {
    await app.close();
  }
}

bootstrap();

================
File: src/database/seeders/seed.ts.meta
================
fileFormatVersion: 2
guid: 16f147d4af8eb4cdc96c8a905675af14
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/seeder.ts
================
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { Test } from '@nestjs/testing';
import { UserSeeder } from './user.seeder';
import { LeaderboardSeeder } from './leaderboard.seeder';
import { InventorySeeder } from './inventory.seeder';
import { DailyMissionSeeder } from './daily-mission.seeder';
import { PlayerProgressSeeder } from './player-progress.seeder';

@Injectable()
export class Seeder {
  constructor(private readonly configService: ConfigService) {}

  async seed() {
    const moduleRef = await Test.createTestingModule({
      imports: [
        MongooseModule.forRootAsync({
          useFactory: () => ({
            uri: this.configService.get<string>('MONGODB_URI'),
          }),
          inject: [ConfigService],
        }),
      ],
      providers: [
        UserSeeder,
        LeaderboardSeeder,
        InventorySeeder,
        DailyMissionSeeder,
        PlayerProgressSeeder,
      ],
    }).compile();

    const userSeeder = moduleRef.get(UserSeeder);
    const leaderboardSeeder = moduleRef.get(LeaderboardSeeder);
    const inventorySeeder = moduleRef.get(InventorySeeder);
    const dailyMissionSeeder = moduleRef.get(DailyMissionSeeder);
    const playerProgressSeeder = moduleRef.get(PlayerProgressSeeder);

    try {
      console.log('🌱 Starting database seeding...');

      // Create users first as other entities depend on them
      console.log('Seeding users...');
      const users = await userSeeder.seed();
      console.log('✅ Users seeded successfully');

      // Seed other collections in parallel
      await Promise.all([
        (async () => {
          console.log('Seeding leaderboards...');
          await leaderboardSeeder.seed(users);
          console.log('✅ Leaderboards seeded successfully');
        })(),
        (async () => {
          console.log('Seeding inventory items...');
          await inventorySeeder.seed(users);
          console.log('✅ Inventory seeded successfully');
        })(),
        (async () => {
          console.log('Seeding daily missions...');
          await dailyMissionSeeder.seed();
          console.log('✅ Daily missions seeded successfully');
        })(),
        (async () => {
          console.log('Seeding player progress...');
          await playerProgressSeeder.seed(users);
          console.log('✅ Player progress seeded successfully');
        })(),
      ]);

      console.log('✨ Database seeding completed successfully!');
    } catch (error) {
      console.error('❌ Database seeding failed:', error);
      throw error;
    }
  }
}

================
File: src/database/seeders/seeder.ts.meta
================
fileFormatVersion: 2
guid: 0c5e1ac9e4a9340ac9d862030200dcaf
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/user-mission-progress.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import { UserMissionProgress, UserMissionProgressDocument } from '../../daily-missions/schemas/user-mission-progress.schema';
import { DailyMission, DailyMissionDocument } from '../../daily-missions/schemas/daily-mission.schema';
import { UserDocument } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

@Injectable()
export class UserMissionProgressSeeder {
  constructor(
    @InjectModel(UserMissionProgress.name)
    private readonly userMissionProgressModel: Model<UserMissionProgressDocument>,
    @InjectModel(DailyMission.name)
    private readonly dailyMissionModel: Model<DailyMissionDocument>,
  ) {}

  async seed(users: UserDocument[]): Promise<UserMissionProgressDocument[]> {
    // Clear existing progress
    await this.userMissionProgressModel.deleteMany({});

    // Get all active missions
    const missions = await this.dailyMissionModel.find({ isActive: true });
    if (!missions.length) {
      console.log('No active missions found to create progress for');
      return [];
    }

    const progressRecords: Partial<UserMissionProgress>[] = [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Create progress records for each user
    for (const user of users) {
      // Randomly select 1-3 missions for each user
      const userMissions = faker.helpers.arrayElements(
        missions,
        faker.number.int({ min: 1, max: 3 })
      );

      for (const mission of userMissions) {
        const progress = faker.number.int({ min: 0, max: mission.target });
        const isCompleted = progress >= mission.target;

        progressRecords.push({
          userId: user._id,
          missionId: mission._id,
          progress,
          matchProgresses: mission.matchesRequired 
            ? Array.from({ length: faker.number.int({ min: 0, max: mission.matchesRequired }) }, 
                () => faker.number.int({ min: 0, max: mission.target }))
            : [],
          date: today,
          gameId: GameType.NAIRA_RAID,
          isCompleted,
          rewardClaimed: isCompleted && faker.datatype.boolean(),
        });
      }
    }

    return this.userMissionProgressModel.insertMany(progressRecords) as Promise<UserMissionProgressDocument[]>;
  }
}

================
File: src/database/seeders/user-mission-progress.seeder.ts.meta
================
fileFormatVersion: 2
guid: c1c4643a6b3a944caa02e988482cfc30
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders/user.seeder.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';
import { User, UserDocument } from '../../user/schemas/user.schema';

@Injectable()
export class UserSeeder {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  async seed(count = 20): Promise<UserDocument[]> {
    // Define the type with required fields
    type CreateUserData = Required<Pick<User, 'firstName' | 'username' | 'email' | 'password'>> &
      Partial<Omit<User, 'firstName' | 'username' | 'email' | 'password' | '_id'>>;

    const users: CreateUserData[] = [];
    const hashedPassword = await bcrypt.hash('password123', 10);

    // Create one admin user with known credentials
    users.push({
      firstName: 'Admin',
      lastName: 'User',
      username: 'admin',
      email: 'admin@nairaraid.com',
      password: hashedPassword,
      isEmailVerified: true,
      points: 1000,
    });

    // Generate random users
    for (let i = 0; i < count - 1; i++) {
      const firstName = faker.person.firstName();
      const lastName = faker.person.lastName();
      
      users.push({
        firstName,
        lastName,
        username: faker.internet.username({ firstName, lastName }).toLowerCase(),
        email: faker.internet.email({ firstName, lastName }).toLowerCase(),
        password: hashedPassword,
        phoneNumber: faker.phone.number(),
        isEmailVerified: faker.datatype.boolean(),
        instagram: faker.internet.username(),
        tiktok: faker.internet.username(),
        points: faker.number.int({ min: 0, max: 10000 }),
      });
    }

    // Clear existing users
    await this.userModel.deleteMany({});

    // Insert new users
    return this.userModel.insertMany(users) as Promise<UserDocument[]>;
  }
}

================
File: src/database/seeders/user.seeder.ts.meta
================
fileFormatVersion: 2
guid: b35da8d99930a472495a02a93558c7cf
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database/seeders.meta
================
fileFormatVersion: 2
guid: 2b76374ec380e40628f6000ff6d0e785
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/interfaces/email-metrics.interface.ts
================
export interface EmailMetrics {
  totalSent: number;
  totalFailed: number;
  averageDeliveryTime: number;
  queueLength?: number;
  lastError?: {
    timestamp: Date;
    error: string;
  };
}

export interface QueueMetrics {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
  processingTime: {
    avg: number;
    min: number;
    max: number;
  };
}

export interface EmailHealthStatus {
  status: 'up' | 'down';
  details: {
    mailer: boolean;
    queue?: boolean;
    lastCheck: Date;
    error?: string;
  };
}

================
File: src/email/interfaces/email-metrics.interface.ts.meta
================
fileFormatVersion: 2
guid: f317e86f37c964dd88a336d9d64b8830
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/achievement-unlocked.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Achievement Unlocked! 🏆</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .achievement {
            background-color: #ffd700;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        .achievement-icon {
            font-size: 48px;
            margin: 10px 0;
        }
        .reward {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Congratulations, {{name}}! 🎉</h2>
    
    <div class="achievement">
        <div class="achievement-icon">🏆</div>
        <h3>{{achievementName}}</h3>
        <p>{{achievementDescription}}</p>
    </div>
    
    <div class="reward">
        <h4>Your Rewards:</h4>
        <p>{{rewardDescription}}</p>
        <p>Points Earned: {{points}}</p>
    </div>
    
    <p>Keep up the great work! Want to see your other achievements?</p>
    <a href="{{profileUrl}}" class="button">View Your Profile</a>
    
    <p>Share your achievement:</p>
    <p>
        <a href="{{shareTwitterUrl}}">Twitter</a> |
        <a href="{{shareFacebookUrl}}">Facebook</a> |
        <a href="{{shareInstagramUrl}}">Instagram</a>
    </p>
    
    <div class="footer">
        <p>You received this email because you achieved something awesome in Naira Raid!</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/achievement-unlocked.hbs.meta
================
fileFormatVersion: 2
guid: b16b26dd2181d437dbfeb0f64e27e26f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/reset-password.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Reset Your Password</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #f44336;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Password Reset Request</h2>
    <p>Hello {{name}},</p>
    <p>We received a request to reset your password. Click the button below to create a new password:</p>
    
    <a href="{{resetUrl}}" class="button">Reset Password</a>
    
    <p>Or copy and paste this link in your browser:</p>
    <p>{{resetUrl}}</p>
    
    <p>This password reset link will expire in 1 hour.</p>
    
    <p>If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
    
    <div class="footer">
        <p>This is an automated email, please do not reply.</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/reset-password.hbs.meta
================
fileFormatVersion: 2
guid: 6ff0e0f05a14242319b2570160ee4706
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/verify-email.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Verify Your Email</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Welcome to Naira Raid!</h2>
    <p>Hello {{name}},</p>
    <p>Thank you for registering with Naira Raid. Please verify your email address by clicking the button below:</p>
    
    <a href="{{verificationUrl}}" class="button">Verify Email</a>
    
    <p>Or copy and paste this link in your browser:</p>
    <p>{{verificationUrl}}</p>
    
    <p>This verification link will expire in 24 hours.</p>
    
    <p>If you didn't create an account with Naira Raid, please ignore this email.</p>
    
    <div class="footer">
        <p>This is an automated email, please do not reply.</p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/verify-email.hbs.meta
================
fileFormatVersion: 2
guid: e51343393e8c4414380f0880822b7725
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates/welcome.hbs
================
<!DOCTYPE html>
<html>
<head>
    <title>Welcome to Naira Raid!</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .features {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .feature-item {
            margin: 10px 0;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <h2>Welcome to Naira Raid! 🎮</h2>
    <p>Hello {{name}},</p>
    <p>Thank you for verifying your email! We're excited to have you join our gaming community.</p>
    
    <div class="features">
        <h3>Here's what you can do now:</h3>
        <div class="feature-item">🎯 Complete daily missions to earn rewards</div>
        <div class="feature-item">🏆 Compete in leaderboards</div>
        <div class="feature-item">🎁 Collect and use power-ups</div>
        <div class="feature-item">🌟 Track your progress and achievements</div>
    </div>
    
    <p>Ready to start playing?</p>
    <a href="{{gameUrl}}" class="button">Start Playing Now</a>
    
    <p>Need help getting started? Check out our:</p>
    <ul>
        <li><a href="{{tutorialUrl}}">Game Tutorial</a></li>
        <li><a href="{{faqUrl}}">Frequently Asked Questions</a></li>
        <li><a href="{{supportUrl}}">Support Center</a></li>
    </ul>
    
    <div class="footer">
        <p>Follow us on social media:</p>
        <p>
            <a href="{{instagramUrl}}">Instagram</a> |
            <a href="{{tiktokUrl}}">TikTok</a>
        </p>
        <p>&copy; {{year}} Naira Raid. All rights reserved.</p>
    </div>
</body>
</html>

================
File: src/email/templates/welcome.hbs.meta
================
fileFormatVersion: 2
guid: ae0be8f49b4d34a239925c094a5db1da
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.controller.ts
================
import { Controller, Get, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { EmailService } from './email.service';
import { EmailHealthIndicator } from './email.health';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { EmailMetrics, QueueMetrics, EmailHealthStatus } from './interfaces/email-metrics.interface';

@ApiTags('email-monitoring')
@Controller('email/monitoring')
@UseGuards(JwtAuthGuard)
export class EmailMonitoringController {
  constructor(
    private readonly emailService: EmailService,
    private readonly healthIndicator: EmailHealthIndicator,
  ) {}

  @Get('metrics')
  @ApiOperation({ summary: 'Get email metrics' })
  @ApiResponse({
    status: 200,
    description: 'Returns email sending metrics',
    type: 'object',
  })
  async getMetrics(): Promise<EmailMetrics> {
    return this.emailService.getMetrics();
  }

  @Get('queue')
  @ApiOperation({ summary: 'Get queue metrics' })
  @ApiResponse({
    status: 200,
    description: 'Returns queue metrics if queue is enabled, null otherwise',
    type: 'object',
  })
  async getQueueMetrics(): Promise<QueueMetrics | null> {
    return this.emailService.getQueueMetrics();
  }

  @Get('health')
  @ApiOperation({ summary: 'Get email service health status' })
  @ApiResponse({
    status: 200,
    description: 'Returns health status of email service components',
    type: 'object',
  })
  async getHealth(): Promise<EmailHealthStatus> {
    return this.healthIndicator.check();
  }
}

================
File: src/email/email.controller.ts.meta
================
fileFormatVersion: 2
guid: 6bc095fc54c4a4f39b89c7554f88fc94
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.health.ts
================
import { Injectable } from '@nestjs/common';
import { EmailService } from './email.service';
import { EmailHealthStatus } from './interfaces/email-metrics.interface';

@Injectable()
export class EmailHealthIndicator {
  private lastStatus: EmailHealthStatus = {
    status: 'up',
    details: {
      mailer: true,
      lastCheck: new Date(),
    },
  };

  constructor(private readonly emailService: EmailService) {}

  async check(): Promise<EmailHealthStatus> {
    try {
      const health = await this.emailService.checkHealth();
      this.lastStatus = {
        status: health.mailer ? 'up' : 'down',
        details: {
          ...health,
          lastCheck: new Date(),
        },
      };
    } catch (error) {
      this.lastStatus = {
        status: 'down',
        details: {
          mailer: false,
          lastCheck: new Date(),
          error: error.message,
        },
      };
    }

    return this.lastStatus;
  }

  getLastStatus(): EmailHealthStatus {
    return this.lastStatus;
  }
}

================
File: src/email/email.health.ts.meta
================
fileFormatVersion: 2
guid: 2a4b8b19bb9c34fce8a9473a0ad7555f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.module.ts
================
import { Module, DynamicModule } from '@nestjs/common';
import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { BullModule } from '@nestjs/bull';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { join } from 'path';
import { EmailService } from './email.service';
import { EmailProcessor } from './email.processor';
import { EmailHealthIndicator } from './email.health';
import { EmailMonitoringController } from './email.controller';

@Module({})
export class EmailModule {
  static register(): DynamicModule {
    return {
      module: EmailModule,
      imports: [
        ConfigModule,
        MailerModule.forRootAsync({
          imports: [ConfigModule],
          useFactory: async (configService: ConfigService) => ({
            transport: {
              host: configService.get('SMTP_HOST'),
              port: configService.get('SMTP_PORT'),
              secure: configService.get('SMTP_SECURE', false),
              auth: {
                user: configService.get('SMTP_USER'),
                pass: configService.get('SMTP_PASSWORD'),
              },
            },
            defaults: {
              from: `"Naira Raid" <${configService.get('SMTP_FROM')}>`,
            },
            template: {
              dir: join(__dirname, 'templates'),
              adapter: new HandlebarsAdapter(),
              options: {
                strict: true,
              },
            },
          }),
          inject: [ConfigService],
        }),
        ...this.getQueueImports(),
      ],
      providers: [
        EmailService,
        EmailHealthIndicator,
        ...(process.env.USE_EMAIL_QUEUE === 'true' ? [EmailProcessor] : []),
      ],
      controllers: [EmailMonitoringController],
      exports: [EmailService, EmailHealthIndicator],
    };
  }

  private static getQueueImports(): DynamicModule[] {
    if (process.env.USE_EMAIL_QUEUE !== 'true') {
      return [];
    }

    return [
      BullModule.forRootAsync({
        imports: [ConfigModule],
        useFactory: async (configService: ConfigService) => ({
          redis: {
            host: configService.get('REDIS_HOST', 'localhost'),
            port: configService.get('REDIS_PORT', 6379),
            password: configService.get('REDIS_PASSWORD'),
          },
        }),
        inject: [ConfigService],
      }),
      BullModule.registerQueue({
        name: 'email',
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 1000,
          },
          removeOnComplete: true,
        },
      }),
    ];
  }
}

================
File: src/email/email.module.ts.meta
================
fileFormatVersion: 2
guid: 0daa6cd946141461bbffe1b0f107151c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.processor.ts
================
import { Process, Processor } from '@nestjs/bull';
import { Logger } from '@nestjs/common';
import { Job } from 'bull';
import { MailerService } from '@nestjs-modules/mailer';

interface EmailJob {
  to: string;
  subject: string;
  template: string;
  context: Record<string, any>;
}

@Processor('email')
export class EmailProcessor {
  private readonly logger = new Logger(EmailProcessor.name);

  constructor(private readonly mailerService: MailerService) {}

  @Process('send')
  async handleSendEmail(job: Job<EmailJob>) {
    this.logger.debug(`Processing email job ${job.id}`);
    const { to, subject, template, context } = job.data;

    try {
      await this.mailerService.sendMail({
        to,
        subject,
        template,
        context: {
          ...context,
          year: new Date().getFullYear(),
        },
      });
      this.logger.debug(`Email job ${job.id} completed successfully`);
    } catch (error) {
      this.logger.error(`Failed to process email job ${job.id}`, error.stack);
      throw error;
    }
  }
}

================
File: src/email/email.processor.ts.meta
================
fileFormatVersion: 2
guid: 24e56fe08da2b491080c082b96fde3f3
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/email.service.ts
================
import { Injectable, Logger, OnModuleInit, Optional } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { MailerService } from '@nestjs-modules/mailer';
import { UserDocument } from '../user/schemas/user.schema';
import { EmailMetrics, QueueMetrics } from './interfaces/email-metrics.interface';

@Injectable()
export class EmailService implements OnModuleInit {
  private readonly logger = new Logger(EmailService.name);
  private useQueue: boolean;
  private queueAvailable: boolean = false;
  private metrics: EmailMetrics = {
    totalSent: 0,
    totalFailed: 0,
    averageDeliveryTime: 0,
  };
  private deliveryTimes: number[] = [];

  constructor(
    @Optional() @InjectQueue('email') private readonly emailQueue: Queue,
    private readonly mailerService: MailerService,
    private readonly configService: ConfigService,
  ) {
    this.useQueue = this.configService.get<boolean>('USE_EMAIL_QUEUE', false);
  }

  async onModuleInit() {
    await this.validateConfiguration();
    if (this.useQueue) {
      await this.checkQueueAvailability();
    }
  }

  private async validateConfiguration() {
    const requiredConfigs = [
      'SMTP_HOST',
      'SMTP_PORT',
      'SMTP_USER',
      'SMTP_PASSWORD',
      'SMTP_FROM',
      'BASE_URL',
    ];

    const missingConfigs = requiredConfigs.filter(
      config => !this.configService.get(config),
    );

    if (missingConfigs.length > 0) {
      throw new Error(
        `Missing required email configurations: ${missingConfigs.join(', ')}`,
      );
    }

    if (this.useQueue) {
      const requiredRedisConfigs = ['REDIS_HOST', 'REDIS_PORT'];
      const missingRedisConfigs = requiredRedisConfigs.filter(
        config => !this.configService.get(config),
      );

      if (missingRedisConfigs.length > 0) {
        throw new Error(
          `Queue is enabled but missing Redis configurations: ${missingRedisConfigs.join(
            ', ',
          )}`,
        );
      }
    }
  }

  private async checkQueueAvailability() {
    try {
      await this.emailQueue.isReady();
      this.queueAvailable = true;
      this.logger.log('Email queue is available and connected');
    } catch (error) {
      this.queueAvailable = false;
      this.logger.warn(
        'Email queue is not available, falling back to direct email sending',
        error.stack,
      );
    }
  }

  private getBaseUrl(): string {
    return this.configService.get<string>('BASE_URL') || 'http://localhost:3000';
  }

  private getSocialUrls() {
    const baseUrl = this.getBaseUrl();
    return {
      instagramUrl: this.configService.get<string>('INSTAGRAM_URL') || 'https://instagram.com/nairaraid',
      tiktokUrl: this.configService.get<string>('TIKTOK_URL') || 'https://tiktok.com/@nairaraid',
      tutorialUrl: `${baseUrl}/tutorial`,
      faqUrl: `${baseUrl}/faq`,
      supportUrl: `${baseUrl}/support`,
      gameUrl: `${baseUrl}/play`,
    };
  }

  async getMetrics(): Promise<EmailMetrics> {
    const metrics = { ...this.metrics };
    if (this.useQueue && this.queueAvailable) {
      metrics.queueLength = await this.emailQueue.count();
    }
    return metrics;
  }

  async getQueueMetrics(): Promise<QueueMetrics | null> {
    if (!this.useQueue || !this.queueAvailable) {
      return null;
    }

    const [waiting, active, completed, failed, delayed] = await Promise.all([
      this.emailQueue.getWaitingCount(),
      this.emailQueue.getActiveCount(),
      this.emailQueue.getCompletedCount(),
      this.emailQueue.getFailedCount(),
      this.emailQueue.getDelayedCount(),
    ]);

    const jobs = await this.emailQueue.getJobs(['completed']);
    const processingTimes = jobs.map(job => job.processedOn! - job.timestamp);

    return {
      waiting,
      active,
      completed,
      failed,
      delayed,
      processingTime: {
        avg: this.calculateAverage(processingTimes),
        min: Math.min(...processingTimes),
        max: Math.max(...processingTimes),
      },
    };
  }

  async checkHealth(): Promise<{ mailer: boolean; queue?: boolean }> {
    const health = {
      mailer: await this.checkMailerHealth(),
    };

    if (this.useQueue) {
      health['queue'] = await this.checkQueueHealth();
    }

    return health;
  }

  private async checkMailerHealth(): Promise<boolean> {
    try {
      // Check if required SMTP configuration is available
      const requiredConfigs = [
        'SMTP_HOST',
        'SMTP_PORT',
        'SMTP_USER',
        'SMTP_PASSWORD',
        'SMTP_FROM'
      ];

      const missingConfigs = requiredConfigs.filter(
        config => !this.configService.get(config),
      );

      if (missingConfigs.length > 0) {
        throw new Error(`Missing SMTP configurations: ${missingConfigs.join(', ')}`);
      }

      return true;
    } catch (error) {
      this.logger.error('Mailer health check failed', error.stack);
      return false;
    }
  }

  private async checkQueueHealth(): Promise<boolean> {
    try {
      await this.emailQueue.isReady();
      return true;
    } catch (error) {
      this.logger.error('Queue health check failed', error.stack);
      return false;
    }
  }

  private calculateAverage(numbers: number[]): number {
    if (numbers.length === 0) return 0;
    return numbers.reduce((a, b) => a + b, 0) / numbers.length;
  }

  private async updateMetrics(startTime: number, success: boolean): Promise<void> {
    if (success) {
      this.metrics.totalSent++;
      const deliveryTime = Date.now() - startTime;
      this.deliveryTimes.push(deliveryTime);
      
      // Keep only last 100 delivery times for average calculation
      if (this.deliveryTimes.length > 100) {
        this.deliveryTimes.shift();
      }
      
      this.metrics.averageDeliveryTime = this.calculateAverage(this.deliveryTimes);
    } else {
      this.metrics.totalFailed++;
    }
  }

  private async sendEmail(options: {
    to: string;
    subject: string;
    template: string;
    context: Record<string, any>;
  }): Promise<void> {
    const startTime = Date.now();
    const emailData = {
      ...options,
      context: {
        ...options.context,
        year: new Date().getFullYear(),
      },
    };

    try {
      if (this.useQueue && this.queueAvailable) {
        await this.emailQueue.add('send', emailData);
        this.logger.debug(`Email queued successfully to: ${options.to}`);
      } else {
        await this.mailerService.sendMail(emailData);
        this.logger.debug(`Email sent directly to: ${options.to}`);
      }
      await this.updateMetrics(startTime, true);
    } catch (error) {
      await this.updateMetrics(startTime, false);
      this.metrics.lastError = {
        timestamp: new Date(),
        error: error.message,
      };
      this.logger.error(
        `Failed to send email to ${options.to}`,
        error.stack,
      );
      throw error;
    }
  }

  async sendVerificationEmail(user: UserDocument, token: string): Promise<void> {
    const verificationUrl = `${this.getBaseUrl()}/auth/verify-email?token=${token}`;

    await this.sendEmail({
      to: user.email,
      subject: 'Verify your email address',
      template: 'verify-email',
      context: {
        name: user.firstName,
        verificationUrl,
      },
    });
  }

  async sendPasswordResetEmail(user: UserDocument, token: string): Promise<void> {
    const resetUrl = `${this.getBaseUrl()}/auth/reset-password?token=${token}`;

    await this.sendEmail({
      to: user.email,
      subject: 'Reset your password',
      template: 'reset-password',
      context: {
        name: user.firstName,
        resetUrl,
      },
    });
  }

  async sendWelcomeEmail(user: UserDocument): Promise<void> {
    await this.sendEmail({
      to: user.email,
      subject: 'Welcome to Naira Raid! 🎮',
      template: 'welcome',
      context: {
        name: user.firstName,
        ...this.getSocialUrls(),
      },
    });
  }

  async sendAchievementEmail(
    user: UserDocument,
    achievement: {
      name: string;
      description: string;
      reward: string;
      points: number;
    },
  ): Promise<void> {
    const baseUrl = this.getBaseUrl();
    const profileUrl = `${baseUrl}/profile/${user._id}`;
    const achievementId = achievement.name.toLowerCase().replace(/\s+/g, '-');

    await this.sendEmail({
      to: user.email,
      subject: `Achievement Unlocked: ${achievement.name} 🏆`,
      template: 'achievement-unlocked',
      context: {
        name: user.firstName,
        achievementName: achievement.name,
        achievementDescription: achievement.description,
        rewardDescription: achievement.reward,
        points: achievement.points,
        profileUrl,
        shareTwitterUrl: `https://twitter.com/intent/tweet?text=I just unlocked ${achievement.name} in Naira Raid!&url=${baseUrl}/achievements/${achievementId}`,
        shareFacebookUrl: `https://www.facebook.com/sharer/sharer.php?u=${baseUrl}/achievements/${achievementId}`,
        shareInstagramUrl: `${baseUrl}/achievements/${achievementId}`,
      },
    });
  }
}

================
File: src/email/email.service.ts.meta
================
fileFormatVersion: 2
guid: f6576934b8d3640cdacd5bd2388d038c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/interfaces.meta
================
fileFormatVersion: 2
guid: dc5cb58df8d79476da4d2604d51eb7ff
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email/templates.meta
================
fileFormatVersion: 2
guid: 2127ee099514a41ed967b5574c169df3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto/create-inventory-item.dto.ts
================
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { GameType } from '../../common/types/game.types';

export class CreateInventoryItemDto {
  @IsString()
    name: string;

  @IsString()
    description: string;

  @IsEnum(GameType)
    gameId: string;

  @IsString()
    type: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
    duration?: number;

  @IsOptional()
  @IsNumber()
  @Min(0)
    power?: number;
}

================
File: src/inventory/dto/create-inventory-item.dto.ts.meta
================
fileFormatVersion: 2
guid: f071d2ac4da734bd9b3d37c1fd97d3ab
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto/create-user-inventory.dto.ts
================
import {
  IsDate,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

export class CreateUserInventoryDto {
  @IsString()
    itemId: string;

  @IsNumber()
  @Min(1)
    quantity: number;

  @IsEnum(GameType)
    gameId: string;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
    expiresAt?: Date;
}

================
File: src/inventory/dto/create-user-inventory.dto.ts.meta
================
fileFormatVersion: 2
guid: 02d492e08e9064aedbafaf4986870cd0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas/inventory-item.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type InventoryItemDocument = InventoryItem & Document;

@Schema({ timestamps: true })
export class InventoryItem {
  _id: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  description: string;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true })
  type: string; // e.g., 'power-up', 'weapon', 'currency'

  @Prop()
  duration?: number; // Duration in seconds if applicable

  @Prop()
  power?: number; // Power/strength if applicable

  @Prop({ default: true })
  isActive: boolean;
}

export const InventoryItemSchema = SchemaFactory.createForClass(InventoryItem);

================
File: src/inventory/schemas/inventory-item.schema.ts.meta
================
fileFormatVersion: 2
guid: 087731dc9cb234966b5da59ab45a4834
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas/user-inventory.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';
import { InventoryItem } from './inventory-item.schema';

export type UserInventoryDocument = UserInventory & Document;

@Schema({ timestamps: true })
export class UserInventory {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: InventoryItem.name, required: true })
  itemId: Types.ObjectId | InventoryItem;

  @Prop({ required: true })
  quantity: number;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop()
  expiresAt?: Date;
}

export const UserInventorySchema = SchemaFactory.createForClass(UserInventory);

// Create compound index for unique item per user per game
UserInventorySchema.index({ userId: 1, itemId: 1, gameId: 1 }, { unique: true });

================
File: src/inventory/schemas/user-inventory.schema.ts.meta
================
fileFormatVersion: 2
guid: 118b6c43b9bc64463ae25c383e6c0ada
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/dto.meta
================
fileFormatVersion: 2
guid: 2c1597886a9f44d26b604ca185b19d98
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryController } from './inventory.controller';

describe('InventoryController', () => {
  let controller: InventoryController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InventoryController],
    }).compile();

    controller = module.get<InventoryController>(InventoryController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/inventory/inventory.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 7d16e9fc98f0441c091b992e274805d4
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { InventoryService } from './inventory.service';
import { CreateInventoryItemDto } from './dto/create-inventory-item.dto';
import { CreateUserInventoryDto } from './dto/create-user-inventory.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('inventory')
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @UseGuards(JwtAuthGuard)
  @Post('items')
  createItem(@Body() createInventoryItemDto: CreateInventoryItemDto) {
    return this.inventoryService.createItem(createInventoryItemDto);
  }

  @Get('items/:gameId')
  findAllItems(
    @Param('gameId') gameId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.inventoryService.findAllItems(gameId, paginationDto);
  }

  @Get('items/detail/:id')
  findItemById(@Param('id') id: string) {
    return this.inventoryService.findItemById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Patch('items/:id')
  updateItem(
    @Param('id') id: string,
    @Body() updateData: Partial<CreateInventoryItemDto>,
  ) {
    return this.inventoryService.updateItem(id, updateData);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('items/:id')
  deleteItem(@Param('id') id: string) {
    return this.inventoryService.deleteItem(id);
  }

  @UseGuards(JwtAuthGuard)
  @Post('user')
  addToUserInventory(
    @Request() req,
    @Body() createUserInventoryDto: CreateUserInventoryDto,
  ) {
    return this.inventoryService.addToUserInventory(
      req.user.userId,
      createUserInventoryDto,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Get('user/:gameId')
  getUserInventory(
    @Request() req,
    @Param('gameId') gameId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.inventoryService.getUserInventory(
      req.user.userId,
      gameId,
      paginationDto,
    );
  }

  @UseGuards(JwtAuthGuard)
  @Post('user/use/:itemId')
  useInventoryItem(
    @Request() req,
    @Param('itemId') itemId: string,
    @Body('quantity') quantity?: number,
  ) {
    return this.inventoryService.useInventoryItem(
      req.user.userId,
      itemId,
      quantity,
    );
  }
}

================
File: src/inventory/inventory.controller.ts.meta
================
fileFormatVersion: 2
guid: 9cefe20e4ef624e95b1984d96efdbfaa
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { InventoryService } from './inventory.service';
import { InventoryController } from './inventory.controller';
import {
  InventoryItem,
  InventoryItemSchema,
} from './schemas/inventory-item.schema';
import {
  UserInventory,
  UserInventorySchema,
} from './schemas/user-inventory.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: InventoryItem.name, schema: InventoryItemSchema },
      { name: UserInventory.name, schema: UserInventorySchema },
    ]),
  ],
  controllers: [InventoryController],
  providers: [InventoryService],
  exports: [InventoryService],
})
export class InventoryModule {}

================
File: src/inventory/inventory.module.ts.meta
================
fileFormatVersion: 2
guid: 0ffdf00569f104ed2b5a8346cec75875
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { InventoryService } from './inventory.service';

describe('InventoryService', () => {
  let service: InventoryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [InventoryService],
    }).compile();

    service = module.get<InventoryService>(InventoryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/inventory/inventory.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 154b3c8280fd542168ed9468980422ab
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/inventory.service.ts
================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  InventoryItem,
  InventoryItemDocument,
} from './schemas/inventory-item.schema';
import {
  UserInventory,
  UserInventoryDocument,
} from './schemas/user-inventory.schema';
import { CreateInventoryItemDto } from './dto/create-inventory-item.dto';
import { CreateUserInventoryDto } from './dto/create-user-inventory.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class InventoryService {
  constructor(
    @InjectModel(InventoryItem.name)
    private readonly inventoryItemModel: Model<InventoryItemDocument>,
    @InjectModel(UserInventory.name)
    private readonly userInventoryModel: Model<UserInventoryDocument>,
  ) {}

  async createItem(
    createInventoryItemDto: CreateInventoryItemDto,
  ): Promise<InventoryItemDocument> {
    const item = new this.inventoryItemModel(createInventoryItemDto);
    return item.save();
  }

  async findAllItems(gameId: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      this.inventoryItemModel
        .find({ gameId, isActive: true })
        .skip(skip)
        .limit(limit)
        .exec(),
      this.inventoryItemModel.countDocuments({ gameId, isActive: true }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findItemById(id: string): Promise<InventoryItemDocument> {
    const item = await this.inventoryItemModel.findById(id);
    if (!item) {
      throw new NotFoundException('Inventory item not found');
    }
    return item;
  }

  async updateItem(
    id: string,
    updateData: Partial<CreateInventoryItemDto>,
  ): Promise<InventoryItemDocument> {
    const item = await this.inventoryItemModel.findByIdAndUpdate(
      id,
      updateData,
      {
        new: true,
      },
    );
    if (!item) {
      throw new NotFoundException('Inventory item not found');
    }
    return item;
  }

  async deleteItem(id: string): Promise<void> {
    const result = await this.inventoryItemModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Inventory item not found');
    }
  }

  async addToUserInventory(
    userId: string,
    createUserInventoryDto: CreateUserInventoryDto,
  ): Promise<UserInventoryDocument> {
    const item = await this.findItemById(createUserInventoryDto.itemId);
    if (!item.isActive) {
      throw new BadRequestException('This item is no longer available');
    }

    const existingInventory = await this.userInventoryModel.findOne({
      userId,
      itemId: createUserInventoryDto.itemId,
      gameId: createUserInventoryDto.gameId,
    });

    if (existingInventory) {
      existingInventory.quantity += createUserInventoryDto.quantity;
      if (createUserInventoryDto.expiresAt) {
        existingInventory.expiresAt = createUserInventoryDto.expiresAt;
      }
      return existingInventory.save();
    }

    const userInventory = new this.userInventoryModel({
      userId,
      ...createUserInventoryDto,
    });
    return userInventory.save();
  }

  async getUserInventory(
    userId: string,
    gameId: string,
    paginationDto: PaginationDto,
  ) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      this.userInventoryModel
        .find({
          userId,
          gameId,
          $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
        })
        .populate('itemId')
        .skip(skip)
        .limit(limit)
        .exec(),
      this.userInventoryModel.countDocuments({
        userId,
        gameId,
        $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
      }),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async useInventoryItem(
    userId: string,
    itemId: string,
    quantity = 1,
  ): Promise<UserInventoryDocument> {
    const userInventory = await this.userInventoryModel
      .findOne({
        userId,
        itemId,
        $or: [{ expiresAt: { $gt: new Date() } }, { expiresAt: null }],
      })
      .populate('itemId');

    if (!userInventory) {
      throw new NotFoundException('Item not found in user inventory');
    }

    if (userInventory.quantity < quantity) {
      throw new BadRequestException('Insufficient quantity');
    }

    userInventory.quantity -= quantity;

    if (userInventory.quantity === 0) {
      await userInventory.deleteOne();
      return null;
    }

    return userInventory.save();
  }
}

================
File: src/inventory/inventory.service.ts.meta
================
fileFormatVersion: 2
guid: 92a13350b6dc642d9acaa63c523747c5
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory/schemas.meta
================
fileFormatVersion: 2
guid: 54ff6e3c374dc42e9ae096ae4cd35abf
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-game-session.dto.ts
================
import { IsEnum, IsNumber, IsObject, Min, ValidateNested } from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

class GameStatsDto {
  @IsNumber()
  @Min(0)
  totalKills: number;

  @IsNumber()
  @Min(0)
  cashCollected: number;
}

export class CreateGameSessionDto {
  @IsEnum(GameType)
  gameId: string;

  @IsNumber()
  @Min(0)
  score: number;

  @ValidateNested()
  @Type(() => GameStatsDto)
  @IsObject()
  gameStats: GameStatsDto;
}

================
File: src/leaderboard/dto/create-game-session.dto.ts.meta
================
fileFormatVersion: 2
guid: 98170b60634254913a765deffc4d1d65
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-leaderboard-entry.dto.ts
================
import { IsEnum, IsNumber, IsObject, IsOptional, Min } from 'class-validator';
import { GameType } from '../../common/types/game.types';

export class CreateLeaderboardEntryDto {
  @IsNumber()
  @Min(0)
  score: number;

  @IsNumber()
  @Min(0)
  @IsOptional()
  extraPoints?: number;

  @IsNumber()
  @Min(1)
  seasonNumber: number;

  @IsEnum(GameType)
  gameId: string;

  @IsObject()
  gameStats: {
    totalKills?: number;
    cashCollected?: number;
  };
}

================
File: src/leaderboard/dto/create-leaderboard-entry.dto.ts.meta
================
fileFormatVersion: 2
guid: 64d427310842741789c7a4b7f14ee156
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto/create-leaderboard.dto.ts
================
import { IsDate, IsEnum, IsNumber, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { GameType } from '../../common/types/game.types';

export class CreateLeaderboardDto {
  @IsNumber()
  @Min(1)
  seasonNumber: number;

  @Type(() => Date)
  @IsDate()
  seasonStart: Date;

  @Type(() => Date)
  @IsDate()
  seasonEnd: Date;

  @IsEnum(GameType)
  gameId: string;
}

================
File: src/leaderboard/dto/create-leaderboard.dto.ts.meta
================
fileFormatVersion: 2
guid: a5d83126aa4f2421da954f1eb466236c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/game-session.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { GameType } from '../../common/types/game.types';

export type GameSessionDocument = GameSession & Document;

@Schema({ timestamps: true })
export class GameSession {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true })
  score: number;

  @Prop({ type: Object, required: true })
  gameStats: {
    totalKills: number;
    cashCollected: number;
  };

  @Prop({ default: true })
  isCompleted: boolean;
}

export const GameSessionSchema = SchemaFactory.createForClass(GameSession);

================
File: src/leaderboard/schemas/game-session.schema.ts.meta
================
fileFormatVersion: 2
guid: d9fa05f7d6123475aaede0092bc342cb
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/leaderboard-entry.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Schema as MongooseSchema } from 'mongoose';
import { User } from '../../user/schemas/user.schema';
import { Leaderboard } from './leaderboard.schema';
import { GameType } from '../../common/types/game.types';

export type LeaderboardEntryDocument = LeaderboardEntry & Document;

@Schema({ timestamps: true })
export class LeaderboardEntry {
  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'User', required: true })
  userId: User;

  @Prop({ type: MongooseSchema.Types.ObjectId, ref: 'Leaderboard', required: true })
  leaderboardId: Leaderboard;

  @Prop({ required: true })
  score: number;

  @Prop({ default: 0 })
  extraPoints: number;

  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ type: Object })
  gameStats: {
    totalKills?: number;
    cashCollected?: number;
  };
}

export const LeaderboardEntrySchema = SchemaFactory.createForClass(LeaderboardEntry);

// Create compound index for unique entries per user per leaderboard
LeaderboardEntrySchema.index({ userId: 1, leaderboardId: 1 }, { unique: true });

================
File: src/leaderboard/schemas/leaderboard-entry.schema.ts.meta
================
fileFormatVersion: 2
guid: acc6dfe0b86444395afe196db610b623
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas/leaderboard.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type LeaderboardDocument = Leaderboard & Document;

@Schema({ timestamps: true })
export class Leaderboard {
  @Prop({ required: true })
  seasonNumber: number;

  @Prop({ required: true })
  seasonStart: Date;

  @Prop({ required: true })
  seasonEnd: Date;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ default: true })
  isActive: boolean;
}

export const LeaderboardSchema = SchemaFactory.createForClass(Leaderboard);

================
File: src/leaderboard/schemas/leaderboard.schema.ts.meta
================
fileFormatVersion: 2
guid: bfb39edd798e2422790f667ce6052c5b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/dto.meta
================
fileFormatVersion: 2
guid: a3881637009d84c91ab8ae08f04e49a7
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { LeaderboardController } from './leaderboard.controller';

describe('LeaderboardController', () => {
  let controller: LeaderboardController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [LeaderboardController],
    }).compile();

    controller = module.get<LeaderboardController>(LeaderboardController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/leaderboard/leaderboard.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 0bfc5ba95cad94c4f8389299e410ce1c
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  DefaultValuePipe,
  ParseIntPipe,
  BadRequestException,
} from '@nestjs/common';
import { LeaderboardService } from './leaderboard.service';
import { CreateLeaderboardDto } from './dto/create-leaderboard.dto';
import { CreateGameSessionDto } from './dto/create-game-session.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { ApiOperation, ApiQuery, ApiResponse, ApiTags } from '@nestjs/swagger';

@ApiTags('leaderboard')
@Controller('leaderboard')
export class LeaderboardController {
  constructor(private readonly leaderboardService: LeaderboardService) {}

  @UseGuards(JwtAuthGuard)
  @Post()
  createLeaderboard(@Body() createLeaderboardDto: CreateLeaderboardDto) {
    return this.leaderboardService.createLeaderboard(createLeaderboardDto);
  }

  @Get('current/:gameId')
  getCurrentLeaderboard(@Param('gameId') gameId: string) {
    return this.leaderboardService.getCurrentLeaderboard(gameId);
  }

  @Get('top')
  @ApiOperation({ summary: 'Get top players from the current leaderboard' })
  @ApiQuery({ name: 'gameId', required: true, description: 'Game identifier' })
  @ApiQuery({ name: 'limit', required: false, description: 'Number of players to return (default: 10)' })
  @ApiResponse({
    status: 200,
    description: 'Returns the top players with their position, username, and score',
  })
  getTopPlayers(
    @Query('gameId') gameId: string,
    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number,
  ) {
    if (!gameId) {
      throw new BadRequestException('gameId is required');
    }
    
    return this.leaderboardService.getTopPlayers(gameId, limit);
  }

  @Get(':leaderboardId/entries')
  getLeaderboardEntries(
    @Param('leaderboardId') leaderboardId: string,
    @Query() paginationDto: PaginationDto,
  ) {
    return this.leaderboardService.getLeaderboardEntries(leaderboardId, paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Post('game-session')
  createGameSession(
    @Request() req,
    @Body() createGameSessionDto: CreateGameSessionDto,
  ) {
    return this.leaderboardService.createGameSession(req.user.userId, createGameSessionDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('player-stats/:gameId')
  getPlayerStats(@Request() req, @Param('gameId') gameId: string) {
    return this.leaderboardService.getPlayerStats(req.user.userId, gameId);
  }
}

================
File: src/leaderboard/leaderboard.controller.ts.meta
================
fileFormatVersion: 2
guid: e90109f122656465aa99ae8d480db37a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { LeaderboardService } from './leaderboard.service';
import { LeaderboardController } from './leaderboard.controller';
import { Leaderboard, LeaderboardSchema } from './schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntrySchema } from './schemas/leaderboard-entry.schema';
import { GameSession, GameSessionSchema } from './schemas/game-session.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: Leaderboard.name, schema: LeaderboardSchema },
      { name: LeaderboardEntry.name, schema: LeaderboardEntrySchema },
      { name: GameSession.name, schema: GameSessionSchema },
    ]),
  ],
  controllers: [LeaderboardController],
  providers: [LeaderboardService],
  exports: [LeaderboardService],
})
export class LeaderboardModule {}

================
File: src/leaderboard/leaderboard.module.ts.meta
================
fileFormatVersion: 2
guid: 73b9be81a58b84d818dcbcb327b80ebe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { LeaderboardService } from './leaderboard.service';

describe('LeaderboardService', () => {
  let service: LeaderboardService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [LeaderboardService],
    }).compile();

    service = module.get<LeaderboardService>(LeaderboardService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/leaderboard/leaderboard.service.spec.ts.meta
================
fileFormatVersion: 2
guid: e569a7696b4a54ee688f60363d4ab54d
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/leaderboard.service.ts
================
/* eslint-disable max-len */
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Leaderboard, LeaderboardDocument } from './schemas/leaderboard.schema';
import { LeaderboardEntry, LeaderboardEntryDocument } from './schemas/leaderboard-entry.schema';
import { GameSession, GameSessionDocument } from './schemas/game-session.schema';
import { CreateLeaderboardDto } from './dto/create-leaderboard.dto';
import { CreateLeaderboardEntryDto } from './dto/create-leaderboard-entry.dto';
import { CreateGameSessionDto } from './dto/create-game-session.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class LeaderboardService {
  constructor(
    @InjectModel(Leaderboard.name)
    private readonly leaderboardModel: Model<LeaderboardDocument>,
    @InjectModel(LeaderboardEntry.name)
    private readonly leaderboardEntryModel: Model<LeaderboardEntryDocument>,
    @InjectModel(GameSession.name)
    private readonly gameSessionModel: Model<GameSessionDocument>,
  ) {}

  async createLeaderboard(createLeaderboardDto: CreateLeaderboardDto): Promise<LeaderboardDocument> {
    const leaderboard = new this.leaderboardModel(createLeaderboardDto);
    return leaderboard.save();
  }

  async getCurrentLeaderboard(gameId: string): Promise<LeaderboardDocument> {
    const leaderboard = await this.leaderboardModel.findOne({
      gameId,
      isActive: true,
      seasonStart: { $lte: new Date() },
      seasonEnd: { $gte: new Date() },
    });

    if (!leaderboard) {
      throw new NotFoundException('No active leaderboard found for this game');
    }

    return leaderboard;
  }

  async getLeaderboardEntries(
    leaderboardId: string,
    paginationDto: PaginationDto,
  ) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [entries, total] = await Promise.all([
      this.leaderboardEntryModel
        .find({ leaderboardId })
        .sort({ score: -1, extraPoints: -1 })
        .skip(skip)
        .limit(limit)
        .populate('userId', '-password')
        .exec(),
      this.leaderboardEntryModel.countDocuments({ leaderboardId }),
    ]);

    return {
      entries,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async createGameSession(userId: string, createGameSessionDto: CreateGameSessionDto): Promise<GameSessionDocument> {
    // Create a new game session
    const session = new this.gameSessionModel({
      userId,
      ...createGameSessionDto,
      isCompleted: true, // Session is already completed
    });
    await session.save();

    // Update leaderboard entry if score is higher
    const currentLeaderboard = await this.getCurrentLeaderboard(String(session.gameId));
    await this.updateLeaderboardEntry(String(session.userId), currentLeaderboard._id.toString(), {
      score: session.score,
      gameId: String(session.gameId), 
      seasonNumber: currentLeaderboard.seasonNumber,
      gameStats: session.gameStats,
    });

    return session;
  }

  private async updateLeaderboardEntry(
    userId: string,
    leaderboardId: string | Types.ObjectId,
    data: CreateLeaderboardEntryDto,
  ): Promise<LeaderboardEntryDocument> {
    const existingEntry = await this.leaderboardEntryModel.findOne({
      userId,
      leaderboardId,
    });

    if (!existingEntry) {
      const entry = new this.leaderboardEntryModel({
        userId,
        leaderboardId,
        ...data,
      });
      return entry.save();
    }

    // Only update if new score is higher
    if (data.score > existingEntry.score) {
      existingEntry.score = data.score;
      existingEntry.gameStats = data.gameStats;
      return existingEntry.save();
    }

    return existingEntry;
  }

  async getPlayerStats(userId: string, gameId: string) {
    const currentLeaderboard = await this.getCurrentLeaderboard(gameId);
    const entry = await this.leaderboardEntryModel
      .findOne({
        userId,
        leaderboardId: currentLeaderboard._id,
      })
      .populate('userId', '-password');

    // Calculate player rank by getting all entries sorted by score
    const allEntries = await this.leaderboardEntryModel
      .find({ leaderboardId: currentLeaderboard._id })
      .sort({ score: -1 });
    
    // Find player's position in the sorted list
    let playerRank = 0;
    for (let i = 0; i < allEntries.length; i++) {
      if (String(allEntries[i].userId) === String(userId)) {
        playerRank = i + 1; // +1 because array is 0-indexed
        break;
      }
    }

    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);

    const todayEnd = new Date();
    todayEnd.setHours(23, 59, 59, 999);

    const todayGames = await this.gameSessionModel
      .find({
        userId,
        gameId,
        createdAt: { $gte: todayStart, $lte: todayEnd }, // Use createdAt instead of startTime
        isCompleted: true,
      })
      .sort({ score: -1 });

    return {
      currentSeasonBest: entry,
      allTimeHighScore: entry?.score || 0,
      playerRank: playerRank,
      todayGames,
      todayBestScore: todayGames[0]?.score || 0,
      gamesPlayedToday: todayGames.length,
      totalGamesPlayed: await this.gameSessionModel.countDocuments({ userId, gameId, isCompleted: true }),
      totalKills: await this.calculateTotalKills(userId, gameId),
      totalCashCollected: await this.calculateTotalCash(userId, gameId),
    };
  }

  // Helper methods
  async calculateTotalKills(userId, gameId) {
    const result = await this.gameSessionModel.aggregate([
      { $match: { userId, gameId, isCompleted: true } },
      { $group: { _id: null, total: { $sum: '$gameStats.totalKills' } } },
    ]);
    return result.length > 0 ? result[0].total : 0;
  }

  async calculateTotalCash(userId, gameId) {
    const result = await this.gameSessionModel.aggregate([
      { $match: { userId, gameId, isCompleted: true } },
      { $group: { _id: null, total: { $sum: '$gameStats.cashCollected' } } },
    ]);
    return result.length > 0 ? result[0].total : 0;
  }

  async getTopPlayers(gameId: string, limit: number = 10) {
    try {
      // Get the current active leaderboard for the specified game
      const currentLeaderboard = await this.getCurrentLeaderboard(gameId);
      
      // Fetch the top N entries, sorted by score (and extraPoints as tiebreaker)
      const topEntries = await this.leaderboardEntryModel
        .find({ leaderboardId: currentLeaderboard._id })
        .sort({ score: -1, extraPoints: -1 })
        .limit(limit)
        .populate('userId', 'username') // Only get the username field from the user document
        .exec();
      
      // Return empty array if no entries found
      if (!topEntries || topEntries.length === 0) {
        return {
          gameId,
          leaderboardId: currentLeaderboard._id,
          seasonNumber: currentLeaderboard.seasonNumber,
          entries: [],
        };
      }
      
      // Transform the entries to the required format (position, username, score)
      const formattedEntries = topEntries.map((entry, index) => {
        // Handle case where userId might not be populated properly
        const username = entry.userId && typeof entry.userId === 'object' ? 
          entry.userId.username : 'Unknown Player';
          
        return {
          position: index + 1, // Position is 1-indexed
          username,
          score: entry.score,
        };
      });
      
      return {
        gameId,
        leaderboardId: currentLeaderboard._id,
        seasonNumber: currentLeaderboard.seasonNumber,
        entries: formattedEntries,
      };
    } catch (error) {
      // Re-throw NotFoundException from getCurrentLeaderboard if no active leaderboard
      if (error instanceof NotFoundException) {
        throw error;
      }
      
      // Log error and return a generic error for other types
      console.error('Error fetching top players:', error);
      throw new BadRequestException('Could not retrieve leaderboard data');
    }
  }
}

================
File: src/leaderboard/leaderboard.service.ts.meta
================
fileFormatVersion: 2
guid: d86e1616d2db5491eb48f2477a276c87
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard/schemas.meta
================
fileFormatVersion: 2
guid: 0ae86c7a9db0a4d988fbb67e0df585a0
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto/create-player-progress.dto.ts
================
import { IsEnum, IsMongoId, IsNotEmpty, IsNumber, Min } from 'class-validator';
import { GameType } from '../../common/types/game.types';
import { Types } from 'mongoose';

export class CreatePlayerProgressDto {
  @IsNotEmpty()
  @IsMongoId()
  userId: Types.ObjectId;

  @IsNotEmpty()
  @IsEnum(GameType)
  gameId: string;

  @IsNotEmpty()
  @IsNumber()
  @Min(1)
  level: number = 1;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  experience: number = 0;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  experienceToNextLevel: number = 1000; // Default value for level 1

  rank: {
    current: string;
    history: { rank: string; achievedAt: Date }[];
  } = {
    current: 'Rookie',
    history: [{ rank: 'Rookie', achievedAt: new Date() }],
  };

  unlocks: {
    items: Types.ObjectId[];
    achievements: Types.ObjectId[];
    powerUps: Types.ObjectId[];
  } = {
    items: [],
    achievements: [],
    powerUps: [],
  };
}

================
File: src/player-progress/dto/create-player-progress.dto.ts.meta
================
fileFormatVersion: 2
guid: bf77b53ce5cff4915be5aa00ecc6424b
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto/update-player-progress.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Types } from 'mongoose';

export class UpdatePlayerProgressDto {
  @IsOptional()
  @IsNumber()
  @Min(0)
  experienceGained?: number;

  @IsOptional()
  unlockedItems?: Types.ObjectId[];

  @IsOptional()
  unlockedAchievements?: Types.ObjectId[];

  @IsOptional()
  unlockedPowerUps?: Types.ObjectId[];
}

================
File: src/player-progress/dto/update-player-progress.dto.ts.meta
================
fileFormatVersion: 2
guid: 91caae7e94a6e4040834d67e2aeadaef
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/schemas/player-progress.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { GameType } from '../../common/types/game.types';

export type PlayerProgressDocument = PlayerProgress & Document;

@Schema()
class RankHistory {
  @Prop({ required: true })
  rank: string;

  @Prop({ required: true })
  achievedAt: Date;
}

@Schema()
class Unlocks {
  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  items: Types.ObjectId[];

  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  achievements: Types.ObjectId[];

  @Prop({ type: [{ type: Types.ObjectId }], default: [] })
  powerUps: Types.ObjectId[];
}

@Schema({ timestamps: true })
export class PlayerProgress {
  _id: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true, enum: GameType })
  gameId: string;

  @Prop({ required: true, min: 1 })
  level: number;

  @Prop({ required: true, min: 0 })
  experience: number;

  @Prop({ required: true })
  experienceToNextLevel: number;

  @Prop({
    type: {
      current: { type: String, required: true },
      history: { type: [{ rank: String, achievedAt: Date }], default: [] }
    },
    required: true,
  })
  rank: {
    current: string;
    history: RankHistory[];
  };

  @Prop({ type: () => Unlocks, default: {} })
  unlocks: Unlocks;
}

export const PlayerProgressSchema = SchemaFactory.createForClass(PlayerProgress);

// Create compound index for unique progress per user per game
PlayerProgressSchema.index({ userId: 1, gameId: 1 }, { unique: true });

================
File: src/player-progress/schemas/player-progress.schema.ts.meta
================
fileFormatVersion: 2
guid: d9249f3c5cc1a458bb41b9a14054e829
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/dto.meta
================
fileFormatVersion: 2
guid: 99be4c58e909e4f988bb205fe09ff327
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Put,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam } from '@nestjs/swagger';
import { Types } from 'mongoose';
import { PlayerProgressService } from './player-progress.service';
import { CreatePlayerProgressDto } from './dto/create-player-progress.dto';
import { UpdatePlayerProgressDto } from './dto/update-player-progress.dto';
import { PlayerProgress } from './schemas/player-progress.schema';

@ApiTags('player-progress')
@Controller('player-progress')
export class PlayerProgressController {
  constructor(private readonly playerProgressService: PlayerProgressService) {}

  @Post()
  @ApiOperation({ summary: 'Create new player progress' })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'The player progress has been successfully created.',
    type: PlayerProgress,
  })
  create(@Body() createPlayerProgressDto: CreatePlayerProgressDto) {
    return this.playerProgressService.create(createPlayerProgressDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all player progress records' })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns all player progress records',
    type: [PlayerProgress],
  })
  findAll() {
    return this.playerProgressService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get player progress by ID' })
  @ApiParam({ name: 'id', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns the player progress record',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  findOne(@Param('id') id: string) {
    return this.playerProgressService.findOne(new Types.ObjectId(id));
  }

  @Get('user/:userId/game/:gameId')
  @ApiOperation({ summary: 'Get player progress by user ID and game ID' })
  @ApiParam({ name: 'userId', type: String })
  @ApiParam({ name: 'gameId', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Returns the player progress record',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  findByUserAndGame(
    @Param('userId') userId: string,
    @Param('gameId') gameId: string,
  ) {
    return this.playerProgressService.findByUserAndGame(
      new Types.ObjectId(userId),
      gameId,
    );
  }

  @Put('user/:userId/game/:gameId')
  @ApiOperation({ summary: 'Update player progress' })
  @ApiParam({ name: 'userId', type: String })
  @ApiParam({ name: 'gameId', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The player progress has been successfully updated.',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  update(
    @Param('userId') userId: string,
    @Param('gameId') gameId: string,
    @Body() updatePlayerProgressDto: UpdatePlayerProgressDto,
  ) {
    return this.playerProgressService.updateProgress(
      new Types.ObjectId(userId),
      gameId,
      updatePlayerProgressDto,
    );
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete player progress' })
  @ApiParam({ name: 'id', type: String })
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'The player progress has been successfully deleted.',
    type: PlayerProgress,
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: 'Player progress not found',
  })
  remove(@Param('id') id: string) {
    return this.playerProgressService.remove(new Types.ObjectId(id));
  }
}

================
File: src/player-progress/player-progress.controller.ts.meta
================
fileFormatVersion: 2
guid: bdbe8223e034647129f39e24b12576c0
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { PlayerProgressService } from './player-progress.service';
import { PlayerProgressController } from './player-progress.controller';
import { PlayerProgress, PlayerProgressSchema } from './schemas/player-progress.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([
      { name: PlayerProgress.name, schema: PlayerProgressSchema },
    ]),
  ],
  controllers: [PlayerProgressController],
  providers: [PlayerProgressService],
  exports: [PlayerProgressService],
})
export class PlayerProgressModule {}

================
File: src/player-progress/player-progress.module.ts.meta
================
fileFormatVersion: 2
guid: 321afff1fbbb049a59a59c53373d0ae6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/player-progress.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { PlayerProgress, PlayerProgressDocument } from './schemas/player-progress.schema';
import { CreatePlayerProgressDto } from './dto/create-player-progress.dto';
import { UpdatePlayerProgressDto } from './dto/update-player-progress.dto';

@Injectable()
export class PlayerProgressService {
  constructor(
    @InjectModel(PlayerProgress.name)
    private readonly playerProgressModel: Model<PlayerProgressDocument>,
  ) {}

  async create(createPlayerProgressDto: CreatePlayerProgressDto): Promise<PlayerProgress> {
    const createdProgress = new this.playerProgressModel(createPlayerProgressDto);
    return createdProgress.save();
  }

  async findAll(): Promise<PlayerProgress[]> {
    return this.playerProgressModel.find().exec();
  }

  async findOne(id: Types.ObjectId): Promise<PlayerProgress> {
    const progress = await this.playerProgressModel.findById(id).exec();
    if (!progress) {
      throw new NotFoundException(`Player progress with ID ${id} not found`);
    }
    return progress;
  }

  async findByUserAndGame(userId: Types.ObjectId, gameId: string): Promise<PlayerProgress> {
    const progress = await this.playerProgressModel
      .findOne({ userId, gameId })
      .exec();
    if (!progress) {
      throw new NotFoundException(`Progress not found for user ${userId} in game ${gameId}`);
    }
    return progress;
  }

  private calculateExperienceForNextLevel(currentLevel: number): number {
    // Experience required for next level increases by 20% each level
    return Math.floor(1000 * Math.pow(1.2, currentLevel - 1));
  }

  private determineRank(level: number): string {
    if (level >= 50) return 'Legend';
    if (level >= 40) return 'Master';
    if (level >= 30) return 'Expert';
    if (level >= 20) return 'Veteran';
    if (level >= 10) return 'Advanced';
    if (level >= 5) return 'Intermediate';
    return 'Rookie';
  }

  async updateProgress(
    userId: Types.ObjectId,
    gameId: string,
    updateDto: UpdatePlayerProgressDto,
  ): Promise<PlayerProgress> {
    const progress = await this.findByUserAndGame(userId, gameId) as PlayerProgressDocument;
    
    if (updateDto.experienceGained) {
      progress.experience += updateDto.experienceGained;
      
      // Level up logic
      while (progress.experience >= progress.experienceToNextLevel) {
        progress.experience -= progress.experienceToNextLevel;
        progress.level += 1;
        progress.experienceToNextLevel = this.calculateExperienceForNextLevel(progress.level);
        
        // Check for rank change
        const newRank = this.determineRank(progress.level);
        if (newRank !== progress.rank.current) {
          progress.rank.current = newRank;
          progress.rank.history.push({
            rank: newRank,
            achievedAt: new Date(),
          });
        }
      }
    }

    // Update unlocks
    if (updateDto.unlockedItems) {
      progress.unlocks.items.push(...updateDto.unlockedItems);
    }
    if (updateDto.unlockedAchievements) {
      progress.unlocks.achievements.push(...updateDto.unlockedAchievements);
    }
    if (updateDto.unlockedPowerUps) {
      progress.unlocks.powerUps.push(...updateDto.unlockedPowerUps);
    }

    return progress.save();
  }

  async remove(id: Types.ObjectId): Promise<PlayerProgress> {
    const deletedProgress = await this.playerProgressModel
      .findByIdAndDelete(id)
      .exec();
    if (!deletedProgress) {
      throw new NotFoundException(`Player progress with ID ${id} not found`);
    }
    return deletedProgress;
  }
}

================
File: src/player-progress/player-progress.service.ts.meta
================
fileFormatVersion: 2
guid: 41839e7aa62054091ad9108d81a822c9
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress/schemas.meta
================
fileFormatVersion: 2
guid: 8809ae8696655420eaa1ac9235cf5d5c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto/create-user.dto.ts
================
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString, MinLength, IsOptional, IsBoolean } from 'class-validator';

export class CreateUserDto {
  @ApiProperty({
    description: 'User\'s first name',
    example: 'John',
  })
  @IsNotEmpty()
  @IsString()
  firstName: string;

  @ApiProperty({
    description: 'User\'s last name',
    example: 'Doe',
    required: false,
  })
  @IsOptional()
  @IsString()
  lastName?: string;

  @ApiProperty({
    description: 'User\'s unique username',
    example: 'johndoe123',
  })
  @IsNotEmpty()
  @IsString()
  username: string;

  @ApiProperty({
    description: 'User\'s email address',
    example: 'john.doe@example.com',
  })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @ApiProperty({
    description: 'User\'s phone number',
    example: '+1234567890',
    required: false,
  })
  @IsOptional()
  @IsString()
  phoneNumber?: string;

  @ApiProperty({
    description: 'User\'s password (minimum 8 characters)',
    example: 'securePassword123',
  })
  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  password: string;

  @ApiProperty({
    description: 'Whether the user\'s email is verified',
    example: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isEmailVerified?: boolean = false;

  @ApiProperty({
    description: 'User\'s Instagram handle',
    example: '@johndoe',
    required: false,
  })
  @IsOptional()
  @IsString()
  instagram?: string;

  @ApiProperty({
    description: 'User\'s TikTok handle',
    example: '@johndoe',
    required: false,
  })
  @IsOptional()
  @IsString()
  tiktok?: string;
}

================
File: src/user/dto/create-user.dto.ts.meta
================
fileFormatVersion: 2
guid: e669338af4d1c4bce9e240b78553f869
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto/update-user.dto.ts
================
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString, MinLength } from 'class-validator';

export class UpdateUserDto {
  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  username?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  @MinLength(8)
  password?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  isEmailVerified?: boolean;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  instagram?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  tiktok?: string;
}

================
File: src/user/dto/update-user.dto.ts.meta
================
fileFormatVersion: 2
guid: 476c5e65ed366404a8660f052105bd26
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/schemas/user.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type UserDocument = User & Document;

@Schema({ timestamps: true })
export class User {
  _id: Types.ObjectId;

  @Prop({ required: true })
  firstName: string;

  @Prop()
  lastName?: string;

  @Prop({ required: true, unique: true })
  username: string;

  @Prop({ required: true, unique: true })
  email: string;

  @Prop()
  phoneNumber?: string;

  @Prop({ required: true })
  password: string;

  @Prop({ default: false })
  isEmailVerified: boolean;

  @Prop({ unique: true, sparse: true })
  instagram?: string;

  @Prop({ unique: true, sparse: true })
  tiktok?: string;

  @Prop({ default: 0 })
  points: number;
}

export const UserSchema = SchemaFactory.createForClass(User);

================
File: src/user/schemas/user.schema.ts.meta
================
fileFormatVersion: 2
guid: 58b754f15916447e6bf6bc76a3f15b6a
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/dto.meta
================
fileFormatVersion: 2
guid: 2020fc2e5f507496a8ead989b0e59a2b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/schemas.meta
================
fileFormatVersion: 2
guid: 83ef1d1717731417085620f5eb75f6b6
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});

================
File: src/user/user.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 18d3a0fcc5015424ab06c3c2330f7f25
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get()
  findAll(@Query() paginationDto: PaginationDto) {
    return this.userService.findAll(paginationDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findById(id);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-email/:email')
  findByEmail(@Param('email') email: string) {
    return this.userService.findByEmail(email);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-username/:username')
  findByUsername(@Param('username') username: string) {
    return this.userService.findByUsername(username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-instagram/:instagram')
  findByInstagram(@Param('instagram') instagram: string) {
    return this.userService.findByInstagram(instagram);
  }

  @UseGuards(JwtAuthGuard)
  @Get('by-tiktok/:tiktok')
  findByTiktok(@Param('tiktok') tiktok: string) {
    return this.userService.findByTiktok(tiktok);
  }

  @UseGuards(JwtAuthGuard)
  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(id, updateUserDto);
  }

  @UseGuards(JwtAuthGuard)
  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }
}

================
File: src/user/user.controller.ts.meta
================
fileFormatVersion: 2
guid: ffa964cf89c784330a74a957fe915852
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ConfigModule } from '@nestjs/config';
import { UserService } from './user.service';
import { UserController } from './user.controller';
import { User, UserSchema } from './schemas/user.schema';

@Module({
  imports: [
    ConfigModule,
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}

================
File: src/user/user.module.ts.meta
================
fileFormatVersion: 2
guid: b8fbb0eb536164ea5a6808afd81e9057
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.service.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserService],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});

================
File: src/user/user.service.spec.ts.meta
================
fileFormatVersion: 2
guid: 2c0c31d2dfba34f0cb4ecb86b14e8990
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user/user.service.ts
================
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<UserDocument> {
    try {
      const user = new this.userModel(createUserDto);
      return await user.save();
    } catch (error) {
      if (error.code === 11000) {
        throw new ConflictException('User with this email or username already exists');
      }
      throw error;
    }
  }

  async findAll(paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      this.userModel
        .find()
        .select('-password')
        .skip(skip)
        .limit(limit)
        .exec(),
      this.userModel.countDocuments(),
    ]);

    return {
      users,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<UserDocument> {
    const user = await this.userModel.findById(id).select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async findByEmail(email: string): Promise<UserDocument> {
    return this.userModel.findOne({ email });
  }

  async findByUsername(username: string): Promise<UserDocument> {
    return this.userModel.findOne({ username });
  }

  async findByInstagram(instagram: string): Promise<UserDocument> {
    return this.userModel.findOne({ instagram });
  }

  async findByTiktok(tiktok: string): Promise<UserDocument> {
    return this.userModel.findOne({ tiktok });
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<UserDocument> {
    try {
      const user = await this.userModel
        .findByIdAndUpdate(id, updateUserDto, { new: true })
        .select('-password');

      if (!user) {
        throw new NotFoundException('User not found');
      }

      return user;
    } catch (error) {
      if (error.code === 11000) {
        throw new ConflictException('Username or email already exists');
      }
      throw error;
    }
  }

  async remove(id: string): Promise<void> {
    const result = await this.userModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('User not found');
    }
  }
}

================
File: src/user/user.service.ts.meta
================
fileFormatVersion: 2
guid: 7a3443df197db49c6bb9d1455b3d03fe
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.spec.ts.meta
================
fileFormatVersion: 2
guid: 50dffc16c43354434b04108d669faf54
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.controller.ts.meta
================
fileFormatVersion: 2
guid: a5e13fdbc6f8f482b90cfd96b1b1cea6
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './user/user.module';
import { AuthModule } from './auth/auth.module';
import { LeaderboardModule } from './leaderboard/leaderboard.module';
import { InventoryModule } from './inventory/inventory.module';
import { DailyMissionsModule } from './daily-missions/daily-missions.module';
import { PlayerProgressModule } from './player-progress/player-progress.module';
import { EmailModule } from './email/email.module';
import { BattleRoyaleModule } from './battle-royale/battle-royale.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
      cache: true,
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        uri: configService.get<string>('MONGODB_URI') || 'mongodb://localhost:27017/naira-raid',
        useNewUrlParser: true,
        useUnifiedTopology: true,
      }),
      inject: [ConfigService],
    }),
    UserModule,
    AuthModule,
    LeaderboardModule,
    InventoryModule,
    DailyMissionsModule,
    PlayerProgressModule,
    EmailModule.register(),
    BattleRoyaleModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

================
File: src/app.module.ts.meta
================
fileFormatVersion: 2
guid: 74f84fd8938da4c88badc0d9fa3701cd
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/app.service.ts.meta
================
fileFormatVersion: 2
guid: 301ba0b2266b943f9b82fb1e2dd7e3ff
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/auth.meta
================
fileFormatVersion: 2
guid: f9355d8391d934dcb9e2de2ada98fc92
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/common.meta
================
fileFormatVersion: 2
guid: ce0ed22922c66488887da0301cb4302a
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/config.meta
================
fileFormatVersion: 2
guid: c549089747ad04b37a4bf6987e5f4ce2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/daily-missions.meta
================
fileFormatVersion: 2
guid: 1d8c3c567bbe141eb861e37f8a19dd92
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/database.meta
================
fileFormatVersion: 2
guid: b248e256102b94680b30b4f70c3260f2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/email.meta
================
fileFormatVersion: 2
guid: dc732dcbc628c46da86279de13f68a7b
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/inventory.meta
================
fileFormatVersion: 2
guid: 273db835828334faaa8c70ce586c1496
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/leaderboard.meta
================
fileFormatVersion: 2
guid: 53800c276ea8644e8a5d8133c0174aa3
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable validation pipe
  app.useGlobalPipes(new ValidationPipe());

  // Configure Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('Naira Raid API')
    .setDescription('The Naira Raid game API documentation')
    .setVersion('1.0')
    .addTag('player-progress', 'Player progression system')
    .addTag('inventory', 'Inventory management')
    .addTag('daily-missions', 'Daily missions system')
    .addTag('battle-royale', 'Battle Royale mode and multiplayer')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
}
bootstrap();

================
File: src/main.ts.meta
================
fileFormatVersion: 2
guid: d931ecf329c0241c1840581715c5a6e7
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/player-progress.meta
================
fileFormatVersion: 2
guid: 9f309d0061bb746da9a752db63683d4e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src/user.meta
================
fileFormatVersion: 2
guid: 89e8b7fe76d97476eba25ad56612d8e2
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/app.e2e-spec.ts.meta
================
fileFormatVersion: 2
guid: 781a12ab5dbd94a46b97d6b4d556848f
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: test/jest-e2e.json.meta
================
fileFormatVersion: 2
guid: 0902dd474475e45bf95b9675d8c5b034
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: .eslintrc.js
================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],
    'max-len': ['warn', { code: 100, ignoreStrings: true, ignoreTemplateLiterals: true }],
    'comma-dangle': ['warn', 'always-multiline'],
    'semi': ['warn', 'always'],
    'quotes': ['warn', 'single', { avoidEscape: true }],
    'indent': 'off',
    '@typescript-eslint/indent': 'off',
    'object-curly-spacing': ['warn', 'always'],
    'array-bracket-spacing': ['warn', 'never'],
    'no-multiple-empty-lines': ['warn', { max: 1, maxEOF: 0 }],
  },
};

================
File: .gitignore
================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: dist.meta
================
fileFormatVersion: 2
guid: be60e5e6c9a9d4a0da6af1701355393c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: nest-cli.json.meta
================
fileFormatVersion: 2
guid: 4da96a5088a29438fafdbfa83456ab84
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: node_modules.meta
================
fileFormatVersion: 2
guid: 627e38dd8c1984de19677e71ef1897de
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: package-lock.json.meta
================
fileFormatVersion: 2
guid: 5d125b82120ab4128a8b8332a08c6308
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: package.json
================
{
  "name": "naira-raid-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "seed": "ts-node src/database/seeders/seed.ts"
  },
  "dependencies": {
    "@nestjs-modules/mailer": "^2.0.2",
    "@nestjs/bull": "^11.0.2",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/mongoose": "^11.0.1",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/swagger": "7.1.17",
    "@types/bcrypt": "^5.0.2",
    "@types/bull": "^4.10.4",
    "@types/nodemailer": "^6.4.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/uuid": "^10.0.0",
    "bcrypt": "^5.1.1",
    "bull": "^4.16.5",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "handlebars": "^4.7.8",
    "mongoose": "^8.9.6",
    "nodemailer": "^6.10.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@faker-js/faker": "^9.5.0",
    "@nestjs/cli": "^10.0.0",
    "@nestjs/schematics": "^10.0.0",
    "@nestjs/testing": "^10.0.0",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/node": "^20.3.1",
    "@types/supertest": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: package.json.meta
================
fileFormatVersion: 2
guid: e735a2ce24b034aaaa02a914f74d7bbf
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).

================
File: README.md.meta
================
fileFormatVersion: 2
guid: be72004457e5f4d078e12f314b60c914
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: src.meta
================
fileFormatVersion: 2
guid: 1c2930681749b4f92b249774b21a6060
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: test.meta
================
fileFormatVersion: 2
guid: 5ef0b1c08c4ae4ad99bf790e65d3f998
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.build.json.meta
================
fileFormatVersion: 2
guid: b1ea20d3cc1424b65b795f4a996d8f28
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}

================
File: tsconfig.json.meta
================
fileFormatVersion: 2
guid: 68379272c5fa54e3199241a76503df97
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
